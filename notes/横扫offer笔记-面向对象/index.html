<ol>
<li>不可变数据类型是永远不会被改变的。</li>
</ol>
<pre><code>const int i = 0; //指定变量i为不可变常量
int * j = (int *)&amp;i; //强行将j的指针指向常变量i, &amp;i指的是得到变量i的内存地址
* j = 1;
printf(&quot;%d %d&quot;, i, *j) 最终得到0，1
</code></pre>
<p>因为i是常变量（不可改变的变量），所以即使指针变量j指向了i的地址之后重新赋值。这个时候内存会为常变量开辟一个新的内存地址来存储原始值0，并且在输出的时候使用的还是原来的值。</p>
<p><code>*j</code>指的是这个指针变量所指向的值，也就是它所存储的内存地址，通过该地址找到的值<br>
如果这个时候输出<code>j</code>,那么将打印出<code>*j</code>中存储的内存地址</p>
<ol start="2">
<li>在16位机器上，下面这段代码输出结果：</li>
</ol>
<pre><code>int i = 65536;
    std::cout &lt;&lt;i;
    i = 65535;
    std::cout&lt;&lt;i;
</code></pre>
<p><strong>65536部分</strong><br>
在c语言中int类型是带符号的32位整型。题中i=65536,我们把它转为2进制</p>
<p>1,0000,0000,0000,0000, 超过了16位二进制的范围，所以会把第一位去掉变成0000,0000,0000,0000，结果为0</p>
<p><strong>65535部分</strong><br>
补码的表示方法是: 正数的补码就是其本身, 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1. (即在反码的基础上 +1)<br>
65535 转换成二进制位1111 1111 1111 1111. int类型采用补码形式，所以最后会通过补码变为-1。</p>
<p>计算方式：<br>
原码：</p>
<p>[+1]原 = 0000 0001<br>
[-1]原 = 1000 0001</p>
<p>反码<br>
反码的表示方法是: 正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。<br>
[+1] = [00000001]原 = [00000001]反<br>
[-1] = [10000001]原 = [11111110]反</p>
<p>补码<br>
补码的表示方法是: 正数的补码就是其本身, 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1. (即在反码的基础上 +1)<br>
[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>
[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
<p><a href="https://juejin.im/entry/58e597dada2f60005fe947af">参考资料</a></p>
<ol start="3">
<li>下面这段代码输出d为：</li>
</ol>
<pre><code>int a=1, b=0, c=-1,d=0;
	d = ++a || ++b &amp;&amp; ++c;
	std::cout&lt;&lt;d&lt;&lt;endl;
</code></pre>
<p><code>++a</code>的结果为2，但是在逻辑运算中它就是真值True, 所以为1。 根据短路效应，||运算中左边如果为True则右边的无须再计算了。所以结果为1</p>
<ol start="4">
<li>
<p>在C++程序中调用被C编译器编译后的函数，为什么要加extern “C”声明？</p>
</li>
<li>
<p>extern int a;<br>
指的是告诉编译器在其他地方已经定义了变量a,需要从另外的内存中去找。</p>
</li>
<li>
<p><code>typedef void(*FUN)()</code><br>
定义以个名为FUN的类型，参数为空，返回值是void.</p>
</li>
<li>
<p>指针和引用的区别<br>
指针指的是一块内存的地址，而引用指的是某个变量的别名<br>
引用不能指向一个空值，否则会报错，而指针可以。所以在引用一个变量时，需要考虑好该变量会不会有可能存在空值的情况，如果有空值的情况就需要使用指针。同样在函数中作为参数传递的时候，</p>
</li>
</ol>
