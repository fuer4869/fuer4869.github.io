
<!DOCTYPE html>
<html lang="zh-CN">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="loannes&#39;s blog">
    <title>Tag: iOS - loannes&#39;s blog</title>
    <meta name="author" content="loannes">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="loannes&#39;s blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;tags&#x2F;iOS&#x2F;index.html">
<meta property="og:site_name" content="loannes&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="loannes">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/%20"
            aria-label=""
        >
            loannes&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/%20"
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Kategorien"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Kategorien</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archiv"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archiv</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Suche"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Suche</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="Über"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Über</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/" target="_blank" rel="noopener" title="Google Plus">
                    
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google Plus</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/profile/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/mailto"
                            title="E-Mail"
                        >
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">E-Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/02/03/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%20/"
                            aria-label=": iOS内存管理那些事"
                        >
                            iOS内存管理那些事
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-02-03T11:12:19+08:00">
	
		    03 2月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=================</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>今天在网上看到一道蛮有趣的问题，内容是”对于已经会使用ARC的iOS开发者来说还有必要学习手动内存管理吗？”<br>。换做一年前的我可能会觉得那必须不用学啊，手动管理内存管理太麻烦了而且很容易出错。ARC现在用下来完全能够解决我日常开发中的所有内存管理的问题，而且苹果在WWDC2011上已经强烈推荐开发者使用ARC，为什么不用ARC呢?</p>
<p>直到我有一次使用了第三方组件，当时这个组件是不支持ARC的。有一天在我做新功能的时候突然出现了一个没有任何踪迹的崩溃，经过了1个通宵的排查和网友的帮助最后才得知原来是非ARC和ARC的代码混用出现的问题，后来还是自己重新写了个非ARC的功能才解决了这个问题。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><hr>
<p>每当一个对象被创建的时候它的引用计数为1，为保证对象的存在不造成悬挂指针的情况出现，每当创建引用到对象需要为其的引用计数加1。否则如果其中一个引用被释放的时候因为对象的引用计数被清零，但是对象没有被彻底释放而造成崩溃。</p>
<blockquote>
<p>管理引用计数的目的就是在确保程序运行正常的情况下，能够合理的管理引用计数的递增或者递减。</p>
</blockquote>
<p>管理引用计数有一下3个消息：</p>
<ul>
<li>retain 对象的引用计数加1</li>
<li>release 对象的引用计数减1</li>
<li>autorelease 将对象放入自动释放池中</li>
</ul>
<h4 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h4><p>retain一般用在对象被创建或者引用被赋值的情况下</p>
<pre><code>NSArray * array = [[NSArray array] retain];</code></pre><p>这里创建了一个<code>array</code>的数组，它的引用计数为1。</p>
<pre><code>self.data = array;</code></pre><p><code>array</code> 的引用被赋值给了<code>self.data</code>。</p>
<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>当某个对象不再使用的时候，可以给对象发送<code>release</code>消息。这个时候该对象的引用计数就会减1,如果引用计数为0的时候，在dealloc函数被调用的之后会释放内存。</p>
<p>也就是说如果给对象发送release消息不一定会马上销毁该对象，有可能它还有其他对象引用着。</p>
<h4 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h4><p>有时候可能会遇到一些release不能解决的问题，如在一个函数中返回一个对象，这个时候必须给该对象发送autorelease消息,把对象放入<code>autoreleasepool</code>（自动释放池）中，当runloop执行自动释放池的时候，会从池中的对象列表中一一释放。</p>
<h3 id="assign-copy-retain之间的区别"><a href="#assign-copy-retain之间的区别" class="headerlink" title="assign,copy,retain之间的区别"></a>assign,copy,retain之间的区别</h3><p>在使用成员变量时，会给property传入上面三种参数，不同情况不同用法。</p>
<h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><p>assign<br>相当于是unsafe_unretained,它不会为变量做引用计数。所以一般都是用在基础数据类型上，如int<br>float等。这种类型的变量会由系统自动释放，程序员不用管理。</p>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>copy 会对旧对象另外分配内存给新对象，新对象引用计数加1，就对象不变。</p>
<pre><code>self.data = [array copy];</code></pre><p>这种情况下，<code>self.data</code> 和 <code>array</code><br>虽然是相同的，引用计数也都是1，但是它们不存在同一块内存中，也就是说即使<code>array</code>被释放了，<code>self.data</code>也不会受到任何影响。</p>
<h4 id="retain-1"><a href="#retain-1" class="headerlink" title="retain"></a>retain</h4><p>retain则是会对对象做引用计数，只有在引用计数为0的时候，执行dealloc才会释放对象。</p>
<h3 id="强变量"><a href="#强变量" class="headerlink" title="强变量"></a>强变量</h3><p>首先我们得知道所有的对象的指针都是强变量，也就是说当你把一个对象赋值给一个强变量的时候，强变量会引用到这个对象，旧对象则在赋值前会被释放，强变量会自动保持。不管是实例变量还是全局变量都是这么回事。<br>有一点需要注意，成员变量默认不是strong，其默认是assign。也就是说他默认不会被自动保持。</p>
<h3 id="弱变量"><a href="#弱变量" class="headerlink" title="弱变量"></a>弱变量</h3><p>弱变量的存在主要是为了解决循环保持（retain<br>cycle）的问题。也就是说当两个对象互相存在彼此的强引用时，比如说对象A中有一个强变量B，对象B有个强变量A，这样就会造成循环保持。当其中一个对象需要销毁的时候因为另外一个对象引用着它而造成无法销毁。解决这个问题可以通过在2个对象之间建立一个弱引用的方法。可以在父对象中声明一个强变量子对象，在子对象中声明一个弱变量父对象，这样就不会造成循环保持，因为弱变量不能阻止引用的对象被销毁，在这里就是子对象无法阻止父对象被销毁。而且这个时候子对象会被设置为nil，所以即使无意中给它发送了消息也不会造成奔溃现象。</p>
<h3 id="内存管理的规则总结"><a href="#内存管理的规则总结" class="headerlink" title="内存管理的规则总结"></a>内存管理的规则总结</h3><ul>
<li>一个对象执行了retain消息之后，它的引用计数会加1，这样它就不会被销毁，直到执行release消息之后。也就是说当对象的引用计数为0的时候，对象才会被销毁，然后系统会发送dealloc消息来释放内存。</li>
<li>如果想让一个对象在release之后不被销毁，只要让它的引用计数不为0就行了或者多执行一次retain。</li>
<li>所有发送过autorelease的对象都会被放入自动释放池中，当自动释放池执行至末尾时，会对池中的所有对象发送release消息。</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/02/03/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2017/01/08/%E5%AF%B9%E4%BA%8E%20iOS10%20%E4%B8%AD%20ATS%20%E7%9A%84%E7%90%86%E8%A7%A3%20/"
                            aria-label=": 对于 iOS10 中 ATS 的理解"
                        >
                            对于 iOS10 中 ATS 的理解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-01-08T11:12:19+08:00">
	
		    08 1月 2017
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>WWDC 15 后，对其中有一项新引入的 features 特别在意，那就是苹果将在 2017<br>年初即将强制实施的一项隐私保护功能 ATS(App Transport Security)。<br>在 WWDC 16 中也提到了 ATS，当时声明了 ATS 安全功能与 iOS 9 和 OS X 10.11<br>一同发布，旨在强制性地使用<br>HTTPS，以保护应用程序可安全地接入服务器。所有提交到 App Store<br>的应用程序都需要在 2016 年底执行 ATS 协议。</p>
<blockquote>
<p>此处更新于 2016 年 12 月 21 日。</p>
</blockquote>
<blockquote>
<p>收到消息称苹果将延后强制加入 HTTPS<br>服务，原因各说纷纭就不详细说明了。至于延期到什么时候还未曾有消息。</p>
</blockquote>
<h3 id="ATS（NSAppTransportSecurity）"><a href="#ATS（NSAppTransportSecurity）" class="headerlink" title="ATS（NSAppTransportSecurity）"></a>ATS（NSAppTransportSecurity）</h3><hr>
<blockquote>
<p>It improves privacy and data integrity by ensuring your app’s network<br>connections employ only industry-standard protocols and ciphers<br>without known weaknesses</p>
</blockquote>
<p>它为你的 app 在与规范的协议的网络连接当中对数据起到完美的保护作用。<br>意思就是在 app<br>的平时的网络连接中所涉及到的数据起到保护作用，防止外界的窃听或者盗用。能够逐渐对用户建立起一种信任，那就是你的<br>app 不会意外或者恶意传播用户隐私数据。</p>
<p><strong>NSAppTransportSecurity</strong> 这个功能仅在 iOS9.0 和 OS X v10.11<br>及以上才能使用。对于我们开发者来说将面临的是在苹果正式实施限制 HTTP<br>请求之后，我们最好要保证 app 中所有的请求都是 HTTPS<br>的，否则将会在审核过程中遇到麻烦。</p>
<p><strong>要使用 ATS 必须要满足以下条件</strong></p>
<ul>
<li>安全传输协议(TLS)必须是 1.2 版本，如果是老版本的话将不会使用 ATS</li>
<li>为了保证数据安全性，传输过程中须加密方式是 AES-128 或者 AES-256</li>
<li>客户端与服务端用到的数字证书必须是有可靠的由数字证书认证机构（CA）来负责签发和管理并承担<br>PKI 体系中公钥合法性的检验责任。一般 HTTPS 使用的是 SSL 数字证书</li>
<li>TLS 的密钥必须支持完全前向保密（PFS）</li>
<li>这个功能仅在 iOS9.0 和 OS X v10.11 及以上才能使用</li>
</ul>
<hr>
<p><strong>接下来讲讲在这次 ATS 功能中你需要注意到的规则</strong></p>
<ol>
<li>ATS<br>主要涉及到<strong>NSURLConnection</strong>,<strong>NSURLSession</strong>,<strong>UIWebView</strong>,<strong>WKWebView</strong>这几个类和<strong>AVFoundation</strong>框架中所有加载的<br>API。</li>
<li>如果 app 中涉及到的服务器暂时不支持 https，你可以使用<strong>Allow<br>Arbitrary Loads</strong>来禁用 ATS，但这项规则只有暂时的再过不久 Apple<br>将禁用这项功能。所以得在 Apple 正式禁用这项功能前把该升级成 https<br>的全部升级成 https，否则会在将来难以通过审核。</li>
<li>app<br>中也会用到一些多媒体文件，你可以通过<strong>NSAllowsArbitraryLoadsInWebContent</strong><br>和 <strong>NSAllowsArbitraryLoadsForMedia</strong> 从而不受 ATS 的限制。</li>
<li>其实 Apple 并不推荐直接将<strong>NSAllowsArbitraryLoads</strong>改为<strong>YES</strong>来禁用<br>ATS，所以它的默认值为<strong>NO</strong>。有一个比较容易被审核团队接受的方案那就是使用<strong>NSExceptionDomains</strong>来支持特定的域名。通过设置该域名下的<strong>NSExceptionAllowsInsecureHTTPLoads</strong>来让<br>ATS 接受此域名。</li>
</ol>
<h3 id="配置-ATS"><a href="#配置-ATS" class="headerlink" title="配置 ATS"></a>配置 ATS</h3><hr>
<p>在配置之前先来整理下我们将会用到哪些 key</p>
<ul>
<li><p><strong>NSAllowsArbitraryLoads</strong> 如果设定为<strong>YES</strong>将禁用<br>ATS，在上传的时候需要填写理由</p>
</li>
<li><p><strong>NSAllowsArbitraryLoadsForMedia</strong><br>如果设定为<strong>YES</strong>,将会禁用所有<strong>AV Foundation</strong>框架中的 ATS<br>约束。优先级高于<strong>NSAllowsArbitraryLoads</strong>，也就是说系统会优先看<strong>NSAllowsArbitraryLoadsForMedia</strong>来决定是否禁用<br>ATS。如果 app 需要兼容 iOS10<br>以下的话还是使用<strong>NSAllowsArbitraryLoads</strong>，因为<strong>NSAllowsArbitraryLoadsForMedia</strong>是从<br>iOS10 开始才有效。</p>
</li>
<li><p><strong>NSAllowsArbitraryLoadsInWebContent</strong> 如果设定为<strong>YES</strong>将会禁用 ATS<br>对特定的网页内容以及关于 NSURLSession<br>连接的限制。同样优先级会高于<strong>NSAllowsArbitraryLoads</strong>，和<strong>NSAllowsArbitraryLoadsForMedia</strong>是同级别的。同上，如果要支持老版本的话还是得用<strong>NSAllowsArbitraryLoads</strong>。</p>
</li>
<li><p><strong>NSAllowsLocalNetworking</strong> 如果设定为<strong>YES</strong> 会禁用 ATS<br>对不规则域名和本地域名的保护措施，不会禁用其他功能。并且在 iOS10<br>之后会忽略掉<strong>NSAllowsArbitraryLoads</strong>，如果为在 iOS10<br>以前那它的效果和<strong>NSAllowsArbitraryLoads</strong>一样。</p>
</li>
<li><p><strong>NSExceptionDomains</strong> 针对特定域名的字典，用于避开 ATS<br>规则的特殊域名，这个字段需要搭配<strong>NSAllowsArbitraryLoads</strong>使用，当<br>NSAllowsArbitraryLoads 为<strong>YES</strong>时会生效</p>
<ul>
<li>每个参数的 key<br>都为域名，例如：<a href="http://www.apple.com/" target="_blank" rel="noopener">www.apple.com</a></li>
<li>必须是小写字母</li>
<li>不能包含端口号</li>
<li>不能是一串 IP 地址</li>
<li>末尾不能为一个点</li>
</ul>
</li>
<li><p><strong>NSIncludesSubdomains:</strong> 为<strong>YES</strong>时 ，会对该域名的子域名做 ATS<br>保护</p>
</li>
<li><p><strong>NSRequiresCertificateTransparency</strong><br>为<strong>YES</strong>时，在请求合法的情况下，证书会被提交到 CT logs<br>的服务器来获得 SCT。(具体作用可以查看 <a href="https://imququ.com/post/certificate-transparency.html#toc-2-0" target="_blank" rel="noopener">Certificate Transparency<br>那些事 | JerryQu<br>的小站</a><br>)</p>
</li>
<li><p><strong>NSExceptionAllowsInsecureHTTPLoads</strong></p>
<ul>
<li>为<strong>YES</strong>时，允许加载不安全的 HTTP 并且不会去调整 TLS。</li>
<li>使用这个 key 时，上传时需要填写理由</li>
<li>可以连接安全的服务器和不安全的服务器</li>
</ul>
</li>
<li><p><strong>NSExceptionRequiresForwardSecrecy</strong></p>
<ul>
<li>支持(FS)完全前向保密，为<strong>YES</strong>时，加密方式会受到<strong>ATS<br>Configuration<br>Basics</strong>的限制。为<strong>NO</strong>时，以下这些会不支持<strong>FS</strong>但也能接受<ul>
<li>TLS_RSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_RSA_WITH_AES_128_GCM_SHA256</li>
<li>TLS_RSA_WITH_AES_256_CBC_SHA256</li>
<li>TLS_RSA_WITH_AES_256_CBC_SHA</li>
<li>TLS_RSA_WITH_AES_128_CBC_SHA256</li>
<li>TLS_RSA_WITH_AES_128_CBC_SHA</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>NSExceptionMinimumTLSVersion</strong></p>
<ul>
<li>配合 <strong>NSExceptionAllowsInsecureHTTPLoads</strong>使用，当服务器的 TLS<br>版本低于 1.2 的时候，需要在这里填写相应的版本 如：TLSv1.0</li>
<li>上传需要填写理由</li>
</ul>
</li>
</ul>
<hr>
<h3 id="这里做一个简单的总结"><a href="#这里做一个简单的总结" class="headerlink" title="这里做一个简单的总结"></a>这里做一个简单的总结</h3><p>如果 app 想兼容 iOS10 一下版本的，那么在配置 ATS<br>的时候只需要将<strong>NSAllowsArbitraryLoads</strong>设定为<strong>YES</strong>就可以了，因为 iOS9<br>只看这个。如果是在 iOS 10<br>的情况下，如果<strong>NSAllowsArbitraryLoadsForMedia</strong>，<strong>NSAllowsArbitraryLoadsInWebContent</strong>和<strong>NSAllowsArbitraryLoads</strong>同时存在那么会优先看<strong>NSAllowsArbitraryLoadsForMedia</strong>和<strong>NSAllowsArbitraryLoadsInWebContent</strong>。如果前<br>2 者不存在，那就看<strong>NSAllowsArbitraryLoads</strong>的设定了。</p>
<hr>
<p>下面是针对不同情况整理出来的 ATS 配置方案</p>
<p>![](./对于 iOS10 中 ATS 的理解 _<br>飞奔的蜗牛的博客_files/https_ats_01.png)</p>
<p>有一点忘记说了，要配置 ATS 只需在 Info.plist<br>文件中添加<strong>NSAppTransportSecurity</strong>，具体的结构如下：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<dl><dt>NSAppTransportSecurity : Dictionary {<br>NSAllowsArbitraryLoads : Boolean<br>NSAllowsArbitraryLoadsForMedia : Boolean<br>NSAllowsArbitraryLoadsInWebContent : Boolean<br>NSAllowsLocalNetworking : Boolean<br>NSExceptionDomains : Dictionary {</dt><dd>Dictionary {<br>NSIncludesSubdomains : Boolean<br>NSExceptionAllowsInsecureHTTPLoads : Boolean<br>NSExceptionMinimumTLSVersion : String<br>NSExceptionRequiresForwardSecrecy : Boolean // Default value is YES<br>NSRequiresCertificateTransparency : Boolean<br>}<br>}<br>}￼</dd></dl><hr>
<p>此次 ATS<br>的更新苹果在安全方面跨出了很大的一步，或者讲总算实施强制措施了。虽说不能达到百分之百的开发者都能够落实到这一计划当中，但起码很大一部分人都会去做这一件事情。这里唯一要吐槽的是因为此次举动只针对<br>iOS 10 用户，所以很大部分的开发者都不会原因去抛弃 iOS 10<br>以下的用户，所以才会导致此次措施只有<br>5%的完成度，相信再过一段时间会有更多的开发者会采用<br>ATS，因为安全始终是每个开发者最关心的事情也是对用户来说最重要的事情。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2017/01/08/%E5%AF%B9%E4%BA%8E%20iOS10%20%E4%B8%AD%20ATS%20%E7%9A%84%E7%90%86%E8%A7%A3%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2016/06/22/WWDC15%20%E6%80%BB%E7%BB%93%20/"
                            aria-label=": WWDC15 总结"
                        >
                            WWDC15 总结
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-06-22T11:12:19+08:00">
	
		    22 6月 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>===========</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>好吧，总算盼到了这次的WWDC，自从开始写博客后越来越喜欢关注这些比较前沿的技术动向。果然这次我热血澎湃的泡了杯咖啡穿上了大裤衩坐在电脑前等待着库克的”Good<br>Morning！”</p>
<p>这次发布会总体看下来对于我们这些开发者来说并没有什么颠覆性的改变，库克还穿着去年的那件深蓝色的T恤，Craig还是那么的幽默风趣。其实这次给我印象比较深刻的也就Multitasking和Swift2开源。</p>
<h3 id="Multitasking"><a href="#Multitasking" class="headerlink" title="Multitasking"></a>Multitasking</h3><hr>
<p>刚刚听到这个功能的时候有点没反应过来，在移动设备上做多任务处理是不是有点鸡肋。首先考虑运行的流畅性，在一个设备上同时运行两个程序我想如果使用以前的旧设备的话那肯定会非常卡。然后如果是在手机上做多任务的话，会因为屏幕太小导致操作起来十分不便，还好仅仅支持ipad。但是我觉得在我们这种ipad和手机分工明确的生活环境下，抱着ipad看电影的同时用手机回复微信已经算是多任务了，表示我等屌丝用到的机会不是很多。</p>
<p>不过既然是苹果出的新功能我相信还是有很多人会接受这种功能的，所以还是要稍微做些准备的。在iOS9中的多任务总共分三种形式，分别是Slide<br>Over(暂且称之为滑动覆盖吧，其实就是从侧边划出一个视图，可以打开支持Slide<br>Over的应用程序在这个视图中显示),Picture in picture（视频画中画），Splite<br>View(分割视图，相比Slide Over这个才算是真正的同时运行2个程序)。</p>
<p>虽说是新功能，但苹果在开发新功能的时候还是很考虑我们这些开发者的，对于Slider<br>Over和Splite View这2个功能我觉得只要会使用AutoLayout +<br>SizeClasses就行了。看似复杂的分屏功能就是要让app同时兼容ipad和iPhone尺寸。而视频画中画只要使用原本就已经存在的AVPlayerViewController<br>或者 AVPlayerLayer，其他什么都不用做，就可以完美支持了。<br>PS:据可靠消息，Media Player将不再维护，所以如果还在用Media<br>Player的同学要赶紧转移到AVKit了。</p>
<h3 id="App-Thinning"><a href="#App-Thinning" class="headerlink" title="App Thinning"></a>App Thinning</h3><hr>
<p>以前一直顾虑的问题这次苹果终于帮助我们解决了这个问题。平时在外面突发奇想去下载个app的时候看到庞大的程序和你那少的可怜的流量就只恨自己不是个土豪。</p>
<p>以前现在iOS<br>App都是同时包含了32bit和64bit两种包的，再加上iOS8更新的@3x的资源后app会变得很大。现在苹果终于发现了这个问题，在iOS9中可以自动为我们分配适合我们的slice下载了。</p>
<h3 id="Swift-2"><a href="#Swift-2" class="headerlink" title="Swift 2"></a>Swift 2</h3><hr>
<p>Swift<br>2将于年底开源，虽然不知道苹果有史以来第一次开源的决定会造成什么影响，但苹果确实有心想要把Swift拓展成一门普遍性语言，将来可能还会出现Swift后端，Swift开发的xxx工具等，未来出现Swift全栈工程师并不是不可能。</p>
<h3 id="watchOS-2"><a href="#watchOS-2" class="headerlink" title="watchOS 2"></a>watchOS 2</h3><hr>
<p>watchOS 这次跟新也并没有什么亮点，唯一值得庆幸的是Watch<br>App总算是摆脱了iPhone讲独立存在于iWatch中了。估计去年iwatch的销量并没有想象中那么好，收到的反馈意见可能很少，所以此次更新还是相对比较保守的，并没有添加一些很浮夸的功能。希望下个版本watchOS能有更惊人的表现吧。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><hr>
<p>其他的一些什么Homekit，HealthKit，CloudKit等框架也没什么亮点，稍微更新了些无关紧要的特性。虽说现在智能硬件可能会很火，但是一直到现在还是不温不火的状态所以我还是保持着期待的态度，暂时不会着手去接触。希望下次更新能有更出色的特性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>总的来说此次大会最重量级的就是Swift2的开源了，其他个人表示都不是很看好，勉强有点突破的就是Multitasking了。这段时间正好可以学一下Swift，巩固一下自己的专业技能吧。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2016/06/22/WWDC15%20%E6%80%BB%E7%BB%93%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2016/05/18/%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%83%8FClear%E7%9A%84%E6%97%B6%E9%AB%A6%E7%9A%84%E6%89%8B%E5%8A%BF%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95app%20/"
                            aria-label=": 学习如何制作一个像Clear的时髦的手势驱动的备忘录app"
                        >
                            学习如何制作一个像Clear的时髦的手势驱动的备忘录app
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-05-18T11:12:19+08:00">
	
		    18 5月 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>==================================================</p>
<p>原文链接：<a href="https://www.raywenderlich.com/21842/how-to-make-a-gesture-driven-to-do-list-app-part-13" target="_blank" rel="noopener">https://www.raywenderlich.com/21842/how-to-make-a-gesture-driven-to-do-list-app-part-13</a></p>
<p>[译]如何制作一个类似Clear支持手势驱动的备忘录App (一)</p>
<p>学习如何制作一个像Clear的时髦的手势驱动的备忘录app</p>
<p>这是由教程组的成员<a href="https://www.raywenderlich.com/?page_id=9#colineberhardt" target="_blank" rel="noopener">Colin<br>Eberhardt</a>,<br><a href="http://www.shinobicontrols.com/" target="_blank" rel="noopener">ShinobiControls</a>的CTO,<br>一名会打造有趣又强大的iOS控件的开发者。看看他们的app，<a href="http://click.linksynergy.com/fs-bin/stat?id=9QfxPcziZp0&offerid=146261&type=3&subid=0&tmpid=1826&RD_PARM1=https%253A%252F%252Fitunes.apple.com%252Fus%252Fapp%252Fshinobiplay%252Fid545634307%253Fmt%253D8%2526uo%253D4%2526partnerId%253D30" target="_blank" rel="noopener">ShinobiPlay</a>。你还能在<a href="https://plus.google.com/u/0/104181672098184856535?rel=author" target="_blank">Google+</a><br>和 <a href="https://twitter.com/ColinEberhardt" target="_blank" rel="noopener">Twitter</a>上找到Colin的踪迹。</p>
<p>这三部分教程将会带你通过开发一个简单的备忘录应用，并且没有button，switch<br>和其他常见的UI控件。</p>
<p>换言之，用户将会通过一系列直觉性的手势动作来与你的app产生交互行为，包括挥动，拖动添加，捏。<br>为了避免常见的界面组件，你将会提供给用户一个更加亮眼的又不杂乱的界面。这并不是意味着一个空的手势！</p>
<p>这个教程是给中级和更高级的开发者的-你将会做一些棘手的东西像倾斜的图层，执行动画，甚至创建一个自定义个tableview。如果你是个初级开发者，你应该先去学习我们的<a href="https://www.raywenderlich.com/?page_id=2519" target="_blank" rel="noopener">其他课程</a>。</p>
<p>如果你想让你的应用在手势方面更加好用，这里就有一个适合你的教程。读一读然后亲手操练起来吧！</p>
<h3 id="拟物化和触摸界面"><a href="#拟物化和触摸界面" class="headerlink" title="拟物化和触摸界面"></a>拟物化和触摸界面</h3><hr>
<p>在写代码之前，在UI设计中手势起到的作用这一点值得我们花一点时间去讨论下。不要急，这是一个很值得注意的话题。</p>
<p>手机的多点触控界面允许了更多直接的交互-因此也产生了更多的控制方式和表现方式-远超了一个单点触碰的设备。</p>
<p>一些非常酷又具有直觉性的手势被开发了出来，比如捏/张开,轻拍，拖曳，和点击长按。但是它们很少被使用！（有一个例外是捏/张开,这是将成为处理图像的标准机制。）</p>
<p>尽管现在的触摸技术已经表现的很自然了，我们的开发者仍旧会倒退到使用那些旧的UI组件，buttons，sliders，和<br>toggle switches。为什么？</p>
<p>我们继续使用这些旧的UI组件其中一个原因是我们所知的设计理念就是拟物化。</p>
<p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2012/09/Skeuomorph-480x147.jpg" alt=""></p>
<p>为了帮助用户理解这样一个计算机界面，我们把UI设计成像物体这样来给用户一种亲切感。Apple<br>已经在他们的应用中彻底接受了拟物化设计，那些物体甚至实现了照片般的效果，例如笔记本和书架。</p>
<p>但是没关系-设计会像科技一样容易演变。图形计算机界面已经有将近40年的历史了。那我们是不是该反问下自己，”按钮真的还有必要吗?”</p>
<p>我强烈推荐去看看Josh Clarke写的<a href="http://www.lukew.com/ff/entry.asp?1566" target="_blank" rel="noopener">Buttons are a<br>Hack</a>,文中他鼓励开发者能想出更多有创造性的手势和触摸交互。下次你在你的界面中去添加一个新的控制的时候，问下你自己，”我能不能通过手势来执行相同的方法？”</p>
<p>当一个应用出现时产生了很多好用的手势，那将会十分引人注目的。一个最近的例子就是Realmac<br>software 出的Clear。可以通过检查<a href="http://www.youtube.com/watch?v=S00H-rz7fGo" target="_blank" rel="noopener">great demo on<br>YouTube</a>,甚至可以<a href="http://click.linksynergy.com/fs-bin/stat?id=9QfxPcziZp0&offerid=146261&type=3&subid=0&tmpid=1826&RD_PARM1=https%253A%252F%252Fitunes.apple.com%252Fus%252Fapp%252Fclear%252Fid493136154%253Fmt%253D8%2526uo%253D4%2526partnerId%253D30" target="_blank" rel="noopener">download<br>the<br>app</a>来确认。</p>
<p>这个教程介绍了一个和Clear非常相似的备忘录应用的开发过程。这个教程的目的是为了鼓励你去思考如何为你的应用做出更好的手势，而不是去创造一个Clear的克隆版。我鼓励你的下载购买Clear，它确实能够给你带来灵感。</p>
<p>无论如何，我想是时候从我的soapbox中撤下来然后给你们展示所有的代码！</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><hr>
<p>打开Xcode并且通过<br>File\New\Project创建一个新的iPhone应用，选择<code>iOS\Application\Single View Application</code>模板然后点击<code>Next</code>。在下一个界面中，在项目名中输入<code>ClearStyle</code>，然后按照下图填写其他类似的详情：<br><img src="https://cdn4.raywenderlich.com/wp-content/uploads/2012/09/NewProject-471x320.jpg" alt=""><br>注意你将会使用 Automatic Reference Counting<br>(ARC)，但不使用Storyboards，因为它是个单个页面的应用。同样要注意的是类的前缀是在这里设置的-不过你可以无视它，如果你设置了，那你要注意自动生成的文件名将会和本课程中的不一样。</p>
<p>备忘录从本质上来说其实就是呈现在屏幕上的一列项目。在iPhone应用程序中想呈现一个滑动的列表最标准的做法就是使用UITableView。接下来你会从已经被创建好的项目模板中添加一个到View<br>Controller。</p>
<p>点击<code>SHCViewController.xib</code>来打开界面构建器然后拖一个table<br>view到view层:<br><img src="https://cdn4.raywenderlich.com/wp-content/uploads/2012/09/AddingTableView-420x320.jpg" alt=""></p>
<p>为了访问到UITableview，你必须添加一个相关的outlet。因此，打开Assistant<br>Editor（点击Xcode<br>Toolbar右上角按钮组中间那个按钮）并且把tableview拖到<code>SHCViewController.h</code>中，就像下面显示的，命名outlet为<code>tableview</code>:<br><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2012/09/TableViewOutlet-480x304.jpg" alt=""></p>
<p>至此，你的用户界面已经完成了！</p>
<p>眼神锐利的你可能觉得疑惑为什么我是以UIViewController配合UITableView使用，而不是用UITableViewController?<br>我先不透露太多，我会在下一教程说明，你将会把UITableView替换为自定义UITableView。</p>
<p>要呈现一个备忘录列表，你必须创建一个表示为每个任务的对象。因此让我们开始做这个！</p>
<p>在项目导航中右键根项目，然后选择<code>New File…</code>，然后选择<code>iOS\Cocoa Touch\Objective-C class</code>模板然后添加一个名为<code>SHCToDoItem</code>的类.继承于<code>NSObject</code>:</p>
<p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2012/09/AddToDoItemClass-469x320.jpg" alt=""></p>
<p>打开<code>SHCToDoItem.h</code>然后添加一系列属性和接口(在@interface和@end<br>line之间)：</p>
<p>// A text description of this item.<br>@property (nonatomic, copy) NSString *text;</p>
<p>// A Boolean value that determines the completed state of this item.<br>@property (nonatomic) BOOL completed;</p>
<p>// Returns an SHCToDoItem item initialized with the given text.<br>-(id)initWithText:(NSString*)text;</p>
<p>// Returns an SHCToDoItem item initialized with the given text.<br>+(id)toDoItemWithText:(NSString*)text;</p>
<p>一个备忘录项只是纯粹的有一个文本字符串，一个Boolean用来表示该项是否已经完成。</p>
<p>如果这部分你以前是按照老的课程来做的，你可能希望合成你刚刚添加的属性。Surprise!从Xcode4.5之后你不必再这么做了，以后编译器都会自动为你合成属性。非常方便对吧？</p>
<p>接下来你必须在<code>initWithText:</code>中做些动作了，<br>初始化一个支持text的SHCToDoItem实例。为了方便起见，使对象创建起来更方便就加了这个<code>toDoItemWithText:</code>类接口。</p>
<p>在<code>SHCToDoItem.m</code>的@implementation这行后添加如下代码：</p>
<p>-(id)initWithText:(NSString*)text {<br>if (self = [super init]) {<br>self.text = text;<br>}<br>return self;<br>}</p>
<p>+(id)toDoItemWithText:(NSString *)text {<br>return [[SHCToDoItem alloc] initWithText:text];<br>}</p>
<p>现在你有了自己的备忘录项的类，接下来创建一个备忘录项的数组然后通过UITableView来显示它们是相当标准的，所以我们尽快做接下来的几步。</p>
<p>在<code>SHCViewController.m</code>顶部添加如下代码（在已存在的#import<br>这行下面，替换空的类扩折和@implemetation 这行）:</p>
<p>#import “SHCToDoItem.h”</p>
<p>@implementation SHCViewController {<br>// an array of to-do items<br>NSMutableArray* _toDoItems;<br>}</p>
<p>-(id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle<br>*)nibBundleOrNil {<br>self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];<br>if (self)<br>{<br>// create a dummy to-do list<br>_toDoItems = [[NSMutableArray alloc] init];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Feed the<br>cat”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Buy eggs”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Pack bags for<br>WWDC”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Rule the<br>web”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Buy a new<br>iPhone”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Find missing<br>socks”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Write a new<br>tutorial”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Master<br>Objective-C”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Remember your<br>wedding anniversary!”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Drink less<br>beer”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Learn to<br>draw”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Take the car to<br>the garage”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Sell things on<br>eBay”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Learn to<br>juggle”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Give up”]];<br>}<br>return self;<br>}</p>
<p>到了这里当你导入了备忘录项类的头文件后，添加一个实例变量<br>_toDoItems,然后重写 <code>initWithNibName:bundle:</code><br>来构成一个由虚拟数据组成的数组。上面的代码表示了<code>toDoItemWithText</code>接口的值：已经去掉了重复的alloc/init<br>备忘录对象。</p>
<p>你必须为tableview提供一个datasource。对于一个简单的应用，使用view<br>controller来当做datasource是明智的选择，所以接着编辑<code>SHCViewController.h</code>文件采用UITableViewDataSource协议：</p>
<p>@interface SHCViewController : UIViewController</p>
<p>你必须设置view<br>controller来作为tableview的datasource。通常，你应该通过Interface<br>Builder来链接datasource tableview 的datasource 到<br>SHCViewController。但是你也能通过在<code>SHCViewController.m</code>的<code>viewDidLoad</code>中添加以下代码也能做到：</p>
<p>self.tableView.dataSource = self;<br>[self.tableView registerClass:[UITableViewCell class]<br>forCellReuseIdentifier:@”cell”];</p>
<p>以上代码也注册了UITableViewCell类这样这个类会给tableview提供cells。</p>
<p>UITableViewDataSource协议定义了2个接口并且在任何类中都必须采取这个协议。一个是（tableView:numberOfRowsInSection:）在每个分组中的行数，而另一个(tableView:cellForRowAtIndexPath:)是为一个特定行/组请求cell的实例。</p>
<p>执行那些接口十分简单-只要在<code>SHCViewController.m</code>的地步添加如下代码：</p>
<p>#pragma mark - UITableViewDataSource protocol methods<br>-(NSInteger)tableView:(UITableView *)tableView<br>numberOfRowsInSection:(NSInteger)section {<br>return _toDoItems.count;<br>}</p>
<p>-(UITableViewCell *)tableView:(UITableView *)tableView<br>cellForRowAtIndexPath:(NSIndexPath *)indexPath {<br>NSString *ident = @”cell”;<br>// re-use or create a cell<br>UITableViewCell *cell = [tableView<br>dequeueReusableCellWithIdentifier:ident forIndexPath:indexPath];<br>// find the to-do item for this index<br>int index = [indexPath row];<br>SHCToDoItem *item = _toDoItems[index];<br>// set the text<br>cell.textLabel.text = item.text;<br>return cell;<br>}</p>
<p>你只有一个单独的分组，这是tableview的默认行为，所以上面只通过<code>tableView:numberOfRowsInSection:</code>简单的返回了项目的数量。</p>
<p><code>tableView:cellForRowAtIndexPath:</code>的执行代码基本上都是模板：一个cell已经创建了，相关的备忘录项查找，cell上的文本已经设置了。</p>
<p>Note:在iOS6以前，当创建一个新的UITableViewCell,你不得不从队列中得到cell，如果你没能通过重用池得到一个cell，那你必须通过代码创建这个cell。这个在iOS6已经没有必要了，因为<code>dequeueReusableCellWithIdentifier:forIndexPath:</code>会当重用池中未能找到cell的情况下自动创建一个新的cell给你，只要你预先为这个cell注册过id。(这个你已经在<code>viewDidLoad</code>中做过了)</p>
<p>编译你的代码，你将会看到一个完美的简介备忘录，如下：</p>
<p><img src="https://cdn4.raywenderlich.com/wp-content/uploads/2012/09/ToDoListFirstCut.jpg" alt=""></p>
<h3 id="定制你的Cell"><a href="#定制你的Cell" class="headerlink" title="定制你的Cell"></a>定制你的Cell</h3><hr>
<p>在你开始添加手势之前，让我们把列表做的从视觉上更简便点。</p>
<p>UITableView<br>有一个分离的协议可以用来定制UITableViewDelegate。切换到<code>SHCViewController.h</code>然后为列表添加协议：</p>
<p>@interface SHCViewController : UIViewController<br>&lt;UITableViewDataSource, UITableViewDelegate&gt;</p>
<p>当然，tableview的委托可以通过Interface Builder 或者<br>代码来设置。现在用代码的方式来添加到<code>SHCViewController.m</code>的<code>viewDidLoad</code>中：</p>
<p>self.tableView.delegate = self;</p>
<p>self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;<br>self.tableView.backgroundColor = [UIColor blackColor];</p>
<p>这些代码移除了tableview的分割线并且设置了背景色。</p>
<p>现在你能添加下面这些代码在文件底部来增加每行的高度和设置每行的背景色：</p>
<p>-(UIColor_)colorForIndex:(NSInteger) index {<br>NSUInteger itemCount = <em>toDoItems.count - 1;<br>float val = ((float)index / (float)itemCount)</em> 0.6;<br>return [UIColor colorWithRed: 1.0 green:val blue: 0.0 alpha:1.0];<br>}</p>
<p>#pragma mark - UITableViewDataDelegate protocol methods<br>-(CGFloat)tableView:(UITableView *)tableView<br>heightForRowAtIndexPath:(NSIndexPath *)indexPath {<br>return 50.0f;<br>}</p>
<p>-(void)tableView:(UITableView *)tableView<br>willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath<br>*)indexPath {<br>cell.backgroundColor = [self colorForIndex:indexPath.row];<br>}</p>
<p>这个是从colorForIndex返回的由红变黄的渐变色，只是考虑到审美的关系。编译项目你就会看到：</p>
<p><img src="https://cdn3.raywenderlich.com/wp-content/uploads/2012/09/ToDoListColored.jpg" alt=""></p>
<p>现在我们要为每一行设置了一个特定的颜色。当用户往下滑动的时候整体的颜色也会随着改变，注意这个很难说明哪一个cell开始变化哪一个cell结束变化，尤其在接近顶部的时候，几乎每个cell都是红色背景。</p>
<p>所以接下来的步骤就是为每个cell添加一个渐变效果这样来更方便地区分cell。你能通过datasource和delegate更方便的修改cell的样式，不过还有更优雅的解决方案就是继承UITableViewCell来自定义cell。</p>
<p>在项目中添加一个<code>iOS\Cocoa Touch\Objective-C class</code>模块的新类。命名为<code>SHCTableViewCell</code>，然后让它继承<code>UITableViewCell</code>：</p>
<p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2012/09/AddCustomCell-473x320.jpg" alt=""></p>
<p>替换一下内容到<code>SHCTableViewCell.m</code>中：</p>
<p>#import &lt;QuartzCore/QuartzCore.h&gt;<br>#import “SHCTableViewCell.h”</p>
<p>@implementation SHCTableViewCell<br>{<br>CAGradientLayer* _gradientLayer;<br>}</p>
<p>-(id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString<br>*)reuseIdentifier {<br>self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];<br>if (self) {<br>// add a layer that overlays the cell adding a subtle gradient effect<br>_gradientLayer = [CAGradientLayer layer];<br>_gradientLayer.frame = self.bounds;<br>_gradientLayer.colors = @[(id)[[UIColor colorWithWhite:1.0f<br>alpha:0.2f] CGColor],<br>(id)[[UIColor colorWithWhite:1.0f alpha:0.1f] CGColor],<br>(id)[[UIColor clearColor] CGColor],<br>(id)[[UIColor colorWithWhite:0.0f alpha:0.1f] CGColor]];<br>_gradientLayer.locations = @[@0.00f, @0.01f, @0.95f, @1.00f];<br>[self.layer insertSublayer:_gradientLayer atIndex:0];<br>}<br>return self;<br>}</p>
<p>-(void) layoutSubviews {<br>[super layoutSubviews];<br>// ensure the gradient layers occupies the full bounds<br>_gradientLayer.frame = self.bounds;<br>}</p>
<p>@end</p>
<p>这里你添加了一个CAGradientLayer<br>实例变量并且在初始化接口中创建了一个四层色阶。注意到的是色阶中的白色值在最顶端，黑色的在最底部。这会覆盖在已存在的颜色顶部，会产生高亮部分在顶部而暗部分在底部的效果，这样就能创建出一个从上到下都很流畅的模拟发光效果。</p>
<p>Note:仍旧要尝试如何做出合适的覆盖效果和其他的模拟发光效果？看看Vicki写的<a href="http://www.vickiwenderlich.com/2011/09/three-dimensional-characters-objects-light-sources/" target="_blank" rel="noopener">this<br>lighting<br>tutorial</a>。</p>
<p>试着编译代码，你会发现会报一堆链接上的错。这是因为上面的代码使用了QuartzCore框架。</p>
<p>为了让编译器满意，点击项目的根目录切换到project<br>settings，然后展开<code>Build Phases</code>标签的<code>Link Binary With Libraries</code>分组，然后点击(+)按钮把框架添加到你的项目中。你会发现QuartzCore在列表中。</p>
<p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2012/09/AddFramework-480x250.jpg" alt=""></p>
<p>到此框架添加完成，但是你现在还是不能使用你的自定义UITableViewCell！你必须使用自定义cell。</p>
<p>切换到<code>SHCViewController.m</code> 然后在顶部导入以下代码：</p>
<p>#import “SHCTableViewCell.h”</p>
<p>然后在<code>viewDidLoad</code>中替换下面这行代码：</p>
<p>[self.tableView registerClass:[UITableViewCell class]<br>forCellReuseIdentifier:@”cell”];</p>
<p>到 ：</p>
<p>[self.tableView registerClass:[SHCTableViewCell class]<br>forCellReuseIdentifier:@”cell”];</p>
<p>最后，在<code>tableView:cellForRowAtIndexPath:</code>类中把cell的类替换成SHCTableCelClass,像如下代码：</p>
<pre><code>SHCTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ident forIndexPath:indexPath];</code></pre><p>cell.textLabel.backgroundColor = [UIColor clearColor];</p>
<p>这样就可以了！因为你在<code>viewDidLoad</code>中被注册用来创建新的tableview cell<br>在执行<code>tableView:cellForRowAtIndexPath:</code>时需要这个table<br>cell，你的新类将会被自动调用</p>
<p>编译你的项目，然后你的备忘录项会有一个比较明显的坡度，这样能使每行之间更容易区分：</p>
<p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2012/09/ToDoListGradient.jpg" alt=""></p>
<h3 id="滑动删除"><a href="#滑动删除" class="headerlink" title="滑动删除"></a>滑动删除</h3><hr>
<p>现在你的列表已经呈现出来了，是时候添加你的第一个收拾啦。真是令人兴奋啊！</p>
<p>就用户的交互而言多点触碰设备提供了app开发者更加复杂和详尽的信息。当每个手指位于屏幕上是，它会把跟踪到的点位通过一系列的touch事件反馈到你的应用。设计这些低等级的touch事件到高等级的手势，比如拖动或者捏，都是很有挑战性的。</p>
<p>对大部分需要精确定位的设备来说一根手指是不够的!而且手势必然会有内置的偏差。举个例子，手指准备拖动的前不得不移动一段距离。</p>
<p>幸运的是，iOS的框架已经提供了完完整整的一套手势。那些方便又轻便的类管理着低等级的touch事件，节省你从复杂的事件中标记手势类型所花的时间并且允许你把注意力放在更高级的任务上来响应每个手势。</p>
<p>这篇课程会跳过这些细节，如果你想学习更多相关知识的话可以去看下我们的<a href="https://www.raywenderlich.com/?p=6567" target="_blank" rel="noopener">UIGestureRecognizer<br>tutorial</a>。</p>
<p>在你的自定义table view<br>cell中<code>SHCTableViewCell.m</code>的init中方法添加一个滑动手势，如下面代码:</p>
<p>UIGestureRecognizer* recognizer = [[UIPanGestureRecognizer alloc]<br>initWithTarget:self action:@selector(handlePan:)];<br>recognizer.delegate = self;<br>[self addGestureRecognizer:recognizer];</p>
<p>这样任何滑动手势都会被发送到<code>handlePan:</code>事件中，但是在添加该接口之前，你需要几个实例变量。如下面已存在的实例变量_gradientLayer:</p>
<p>CGPoint _originalCenter;<br>BOOL _deleteOnDragRelease;</p>
<p>然后添加如下代码:</p>
<p>#pragma mark - horizontal pan gesture methods<br>-(BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer<br>*)gestureRecognizer {<br>CGPoint translation = [gestureRecognizer translationInView:[self<br>superview]];<br>// Check for horizontal gesture<br>if (fabsf(translation.x) &gt; fabsf(translation.y)) {<br>return YES;<br>}<br>return NO;<br>}</p>
<p>-(void)handlePan:(UIPanGestureRecognizer *)recognizer {<br>// 1<br>if (recognizer.state == UIGestureRecognizerStateBegan) {<br>// if the gesture has just started, record the current centre location<br>_originalCenter = self.center;<br>}</p>
<pre><code>// 2
if (recognizer.state == UIGestureRecognizerStateChanged) {
    // translate the center
    CGPoint translation = [recognizer translationInView:self];
    self.center = CGPointMake(_originalCenter.x + translation.x, _originalCenter.y);
    // determine whether the item has been dragged far enough to initiate a delete / complete
    _deleteOnDragRelease = self.frame.origin.x &lt; -self.frame.size.width / 2;

}

// 3
if (recognizer.state == UIGestureRecognizerStateEnded) {
    // the frame this cell would have had before being dragged
    CGRect originalFrame = CGRectMake(0, self.frame.origin.y,
                                      self.bounds.size.width, self.bounds.size.height);
    if (!_deleteOnDragRelease) {
        // if the item is not being deleted, snap back to the original location
        [UIView animateWithDuration:0.2
                         animations:^{
                             self.frame = originalFrame;
                         }
         ];
    }
}</code></pre><p>}</p>
<p>这些代码中做了不少的事情。我们先执行<code>handlePan</code>:,一步一步来。</p>
<ol>
<li>手势处理，比如这个接口，它通过手势的生命周期调在各种各样的点上调用：手势的开始，变化（前提是手势在执行中），然后是结束。当滑动手势第一次执行的时候，cell的中心点会被记录到_originalCenter。</li>
<li>当滑动过程中（当用户移动他们的手指时），这个接口确定了cell和通过手势而产生的新的点之间的偏差，然后就相应地偏移了center属性。如果偏移量超过cell宽度的一般，接下来你要考虑删除操作了。用_deleteOnDragRelease实例变量来作为标签来标记当前的行为是删除动作。</li>
<li>当然，当手势结束时，你通过检查这个标签来确定当前的动作是不是删除动作（用户可能拖到一半的时候又拖回去了，其实这根本没执行删除操作）。</li>
</ol>
<p>接下来是<code>gestureRecognizerShouldBegin</code>-<br>它做了什么?你可能注意到了当<code>handlePan:</code>作为手势的动作时，上面的代码也说明了cell<br>这个类被用来作为滑动手势的委托。</p>
<p>这个借口将允许你在它开始之前取消手势。在这个例子中，你要确定滑动的方向是横向还是竖向。如果是竖向就取消，因为你不必要处理任何竖向滑动。</p>
<p>这是非常重要的一步！你的cells是存在于一个竖向滑动的view中。所以如果取消竖向的滑动那scrollview<br>就会失效，这样任务列表将不能滑动。</p>
<p>编译项目，你将会发现你可以向左或者向右滑动item。当你释放的时候，该项就会返回到中心，除非你往左拖动它超过半个屏幕的时候，这就表示该项将要被删除:</p>
<p><img src="https://cdn4.raywenderlich.com/wp-content/uploads/2012/09/DeleteItem.jpg" alt=""></p>
<p>当然，你也会注意到项目并没有被删除。那么你该如何从你的列表中删除一个项目？</p>
<p>任务清单的项目是被存储在你的view<br>controller中的NSMutableArray中。所以你应该找到一些方法来标记这个view<br>controller这样当一个项目被删除的时候可以从数组中删除该项。</p>
<p>UI<br>controls是通过协议来标记状态变化和用户交互。你也同样可以在这里采用它。</p>
<p>在项目中通过<code>iOS\Cocoa Touch\Objective-C protocol</code>模板添加一个新的协议。命名为<code>SHCTableViewCellDelegate</code>。</p>
<p>现在打开<code>SHCTableViewCellDelegate.h</code> 然后替换内容为：</p>
<p>#import “SHCToDoItem.h”</p>
<p>// A protocol that the SHCTableViewCell uses to inform of state change<br>@protocol SHCTableViewCellDelegate</p>
<p>// indicates that the given item has been deleted<br>-(void) toDoItemDeleted:(SHCToDoItem*)todoItem;</p>
<p>@end</p>
<p>上面的代码添加了一个简单的接口用来说明一个项目已经被删除了。</p>
<p>自定义cell类必须声明这个委托，并且它需要知道它呈现了哪个项目。在<code>SHCTableViewCell.h</code>中替换这些内容来添加这些信息：</p>
<p>#import “SHCToDoItem.h”<br>#import “SHCTableViewCellDelegate.h”</p>
<p>// A custom table cell that renders SHCToDoItem items.<br>@interface SHCTableViewCell : UITableViewCell</p>
<p>// The item that this cell renders.<br>@property (nonatomic) SHCToDoItem *todoItem;</p>
<p>// The object that acts as delegate for this cell.<br>@property (nonatomic, assign) id delegate;</p>
<p>@end</p>
<p>为了能够使用这个委托，在<code>SHCTableViewCell.h</code>中<code>handlePan:</code>中需要添加如下代码来更新逻辑：</p>
<p>if (_deleteOnDragRelease) {<br>// notify the delegate that this item should be deleted<br>[self.delegate toDoItemDeleted:self.todoItem];<br>}</p>
<p>上面的代码是指当用户拖动这个项目足够距离的时候就会调用委托接口。</p>
<p>接下来该利用上面的代码来做些修改。切换到<code>SHCViewController.h</code><br>并且声明这个类让它支持新的协议（也就是添加有必要的#import）:</p>
<p>#import “SHCTableViewCellDelegate.h”</p>
<p>@interface SHCViewController : UIViewController<br>&lt;UITableViewDataSource, UITableViewDelegate, SHCTableViewCellDelegate&gt;</p>
<p>然后，打开<code>SHCViewController.m</code>然后在<code>tableView:cellForRowAtIndex:</code>中添加如下代码:</p>
<p>cell.delegate = self;<br>cell.todoItem = item;</p>
<p>最后，在新增的委托接口中添加删除项目：</p>
<p>-(void)toDoItemDeleted:(id)todoItem {<br>// use the UITableView to animate the removal of this row<br>NSUInteger index = [_toDoItems indexOfObject:todoItem];<br>[self.tableView beginUpdates];<br>[_toDoItems removeObject:todoItem];<br>[self.tableView deleteRowsAtIndexPaths:@[[NSIndexPath<br>indexPathForRow:index inSection:0]]<br>withRowAnimation:UITableViewRowAnimationFade];<br>[self.tableView endUpdates];<br>}</p>
<p>上面的代码移除了任务清单的项目，然后使用了UITableView的动画去删除，用的是默认动画之一。</p>
<p>##滑动完成</p>
<p>你的任务清单应用允许用户删除项目，但是如何把它们标记成完成呢？为了这个，你将要使用到右滑的手势。</p>
<p>当一个项目标记成完成的时候，它会变成绿色的背景并且在文本上有一条删除线。不幸的是，iOS不支持删除线，所以你不得不自己做出来！</p>
<p>我通过在<a href="http://stackoverflow.com/" target="_blank" rel="noopener">StackOverfolw</a>找到了一些关于UILabel的删除线效果的方法，但是都是通过使用drawRect和Quartz<br>2D来实现的。我更倾向于layers这类方式，因为这些代码更易读，而且<br>layers更容易通过它们的隐藏属性来打开或者关闭删除线。</p>
<blockquote>
<p>注意:此外，你也可以通过iOS6更新的<br>NSAttributedString的功能来实现。若想知道更多，可以查看iOS6教程的第15章，”What’s<br>New with Attributed Strings.”</p>
</blockquote>
<p>那么，在<code>iOS\Cocoa Touch\Objective-C class</code>模板中创建一个新文件.一个继承于UILabel的名为<code>SHCStrikethroushLabel</code>。</p>
<p>// A UILabel subclass that can optionally have a strikethrough.<br>@interface SHCStrikethroughLabel : UILabel</p>
<p>// A Boolean value that determines whether the label should have a<br>strikethrough.<br>@property (nonatomic) bool strikethrough;</p>
<p>@end</p>
<p>切换到<code>SHCStrikethroushLabel.m</code>中替换如下内容到类中：</p>
<p>#import &lt;QuartzCore/QuartzCore.h&gt;<br>#import “SHCStrikethroughLabel.h”</p>
<p>@implementation SHCStrikethroughLabel {<br>bool _strikethrough;<br>CALayer* _strikethroughLayer;<br>}</p>
<p>const float STRIKEOUT_THICKNESS = 2.0f;</p>
<p>-(id)initWithFrame:(CGRect)frame {<br>self = [super initWithFrame:frame];<br>if (self) {<br>_strikethroughLayer = [CALayer layer];<br>_strikethroughLayer.backgroundColor = [[UIColor whiteColor]<br>CGColor];<br>_strikethroughLayer.hidden = YES;<br>[self.layer addSublayer:_strikethroughLayer];<br>}<br>return self;<br>}</p>
<p>-(void)layoutSubviews {<br>[super layoutSubviews];<br>[self resizeStrikeThrough];<br>}</p>
<p>-(void)setText:(NSString *)text {<br>[super setText:text];<br>[self resizeStrikeThrough];<br>}</p>
<p>// resizes the strikethrough layer to match the current label text<br>-(void)resizeStrikeThrough {<br>CGSize textSize = [self.text sizeWithFont:self.font];<br>_strikethroughLayer.frame = CGRectMake(0, self.bounds.size.height/2,<br>textSize.width, STRIKEOUT_THICKNESS);<br>}</p>
<p>#pragma mark - property setter<br>-(void)setStrikethrough:(bool)strikethrough {<br>_strikethrough = strikethrough;<br>_strikethroughLayer.hidden = !strikethrough;<br>}</p>
<p>@end</p>
<p>删除线是基本上就是一个放在文本上的图层。因为删除线的属性已经设置了，删除线图层的显示和隐藏就变得很有必要。</p>
<p>好了，现在你有了自己的删除线标签，接下来需要添加到自己的自定义cell中。打开<code>SHCTableViewCell.m</code>然后把你的新类导进去:</p>
<p>#import “SHCStrikethroughLabel.h”</p>
<p>然后在实例变量_deleteOnDragRelease下面添加如下一系列的实例变量:</p>
<p>SHCStrikethroughLabel *_label;<br>CALayer *_itemCompleteLayer;</p>
<p>接下来在<code>initWithStyle:reuseIdentifier:</code> 的顶部添加如下代码:</p>
<p>// create a label that renders the to-do item text<br>_label = [[SHCStrikethroughLabel alloc] initWithFrame:CGRectNull];<br>_label.textColor = [UIColor whiteColor];<br>_label.font = [UIFont boldSystemFontOfSize:16];<br>_label.backgroundColor = [UIColor clearColor];<br>[self addSubview:_label];<br>// remove the default blue highlight for selected cells<br>self.selectionStyle = UITableViewCellSelectionStyleNone;</p>
<p>仍旧是在<code>initWithStyle:reuseIdentifier:</code>,在添加手势前添加如下代码:</p>
<p>// add a layer that renders a green background when an item is complete<br>_itemCompleteLayer = [CALayer layer];<br>_itemCompleteLayer.backgroundColor = [[[UIColor alloc]<br>initWithRed:0.0 green:0.6 blue:0.0 alpha:1.0] CGColor];<br>_itemCompleteLayer.hidden = YES;<br>[self.layer insertSublayer:_itemCompleteLayer atIndex:0];</p>
<p>上面添加到你的自定义cell的代码中既有删除线标签也有一个军绿色图层，它们将会在项目完成的时候显示出来。</p>
<p>现在在<code>layoutSubviews</code>中替换一下代码:</p>
<p>const float LABEL_LEFT_MARGIN = 15.0f;</p>
<p>-(void)layoutSubviews {<br>[super layoutSubviews];<br>// ensure the gradient layers occupies the full bounds<br>_gradientLayer.frame = self.bounds;<br>_itemCompleteLayer.frame = self.bounds;<br>_label.frame = CGRectMake(LABEL_LEFT_MARGIN, 0,<br>self.bounds.size.width - LABEL_LEFT_MARGIN,self.bounds.size.height);<br>}</p>
<p>然后按照一下代码为<code>todoItem</code>属性setter:</p>
<p>-(void)setTodoItem:(SHCToDoItem *)todoItem {<br>_todoItem = todoItem;<br>// we must update all the visual state associated with the model item<br>_label.text = todoItem.text;<br>_label.strikethrough = todoItem.completed;<br>_itemCompleteLayer.hidden = !todoItem.completed;<br>}</p>
<p>现在你通过setter设置了标签的文本，打开<code>SHCViewController.m</code>注释的那行就是用来设置label的：</p>
<p>//cell.textLabel.text = item.text;</p>
<p>最后你要做的事就是发现当cell往右拖动超过一半的时候，任务清单项被设置为完成。这里有一个非常相似的处理方式，想要用自己的方式尝试下吗？你想吗?好，我会等你尝试一下，走你！</p>
<p>。。。</p>
<p>。。。</p>
<p>。。。</p>
<p><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2010/09/Tsan_angry.jpg" alt=""></p>
<p>你是不是还在试？继续，我在这里等着! :]<br>…</p>
<p>…</p>
<p>…</p>
<p>修复好了吗？如果没有，让我们来检查一下。<br>你开始添加一个新的实例变量到<code>SHCTableViewcell.m</code>中，它会作为一个标记项目是否完成的标签：</p>
<p>BOOL _markCompleteOnDragRelease;</p>
<p>接下来，在<code>handlePan:</code>函数中的<code>UIGestureRecognizerStateChanged</code>这块，你设置的标签依赖于cell向右滑动多少距离，如下（当_deleteOnDragRelease被设置的时候你可以添加如下代码）：</p>
<p>_markCompleteOnDragRelease = self.frame.origin.x &gt;<br>self.frame.size.width / 2;</p>
<p>最后，仍旧在<code>handlePan:</code>不过是在<code>UIGestureRecognizerStateEnded</code>块中，如果完成的标签被设置了你标记cell为完成：</p>
<p>if (_markCompleteOnDragRelease) {<br>// mark the item as complete and update the UI state<br>self.todoItem.completed = YES;<br>_itemCompleteLayer.hidden = NO;<br>_label.strikethrough = YES;<br>}</p>
<p>如你所注意到的，这些代码把项目标记为完成，显示了完成的图层并且在label上产生了删除线效果。</p>
<p>完成！现在你能过通过滑动项目来完成或者删除。最新添加的绿色图层位于你的删除线后面，所以完成的行仍旧会有阴影效果。</p>
<p>现在编译项目，然后你就能看到如下效果：</p>
<p><img src="https://cdn4.raywenderlich.com/wp-content/uploads/2012/09/ToDoListMarkComplete.jpg" alt=""></p>
<p>现在它看起来棒多了！</p>
<p>##</p>
<p>任务清单现在已经有了一个新颖的，简洁的交互方式…当你知道这是怎么回事的话。有一个关于手势的小问题那就是它们和传统的拟物化相比没有直接显示给用户。</p>
<p>有一样东西你是可以做到的那就是通过用户对基于界面的手势的理解，除了妥协于简单朴素的界面之外。为了一个更棒的手势效果，我推荐阅读这篇我朋友Graham<br>Odds写的<a href="http://www.scottlogic.co.uk/blog/graham/2010/05/contextual-cues-in-ui-design/" target="_blank" rel="noopener">博客</a>，这里有很多这种例子。</p>
<p>这种手势交互通常通过这些功能和行为来给用户的所作所为得到响应。举个例子，鼠标指针从桌面浏览器被用户移到在一个超链接上的时候。</p>
<p>同样的方法会被用到基于界面的手势上。当一个用户开始与界面产生交互的时候，你可以提供很微妙的可见的线索来促进进一步的交互来表示这个功能，这样的话这个手势就会被触发。</p>
<p>对于你的任务清单，可以用一个简单的标记来表示当用户往左或者往右拖动一个项目的时候是删除还是完成。所以记下来就要添加它们！</p>
<p>添加一系列<strong>UILabel</strong>的实例变量到<code>SHCTableViewCell.m</code>中，</p>
<p>如下:</p>
<p>UILabel *_tickLabel;<br>UILabel *_crossLabel;</p>
<p>接下来，在<code>initWithStyle:reuseIdentifier：</code>上面上面定义一些常量：</p>
<p>const float UI_CUES_MARGIN = 10.0f;<br>const float UI_CUES_WIDTH = 50.0f;</p>
<p>现在在<code>initWithStyle:reuseIdentifier：</code>中的<code>if(self)</code>的结构里添加如下代码:</p>
<p>// add a tick and cross<br>_tickLabel = [self createCueLabel];<br>_tickLabel.text = @”\u2713”;<br>_tickLabel.textAlignment = NSTextAlignmentRight;<br>[self addSubview:_tickLabel];<br>_crossLabel = [self createCueLabel];<br>_crossLabel.text = @”\u2717”;<br>_crossLabel.textAlignment = NSTextAlignmentLeft;<br>[self addSubview:_crossLabel];</p>
<p>然后添加下面这个创建label的接口:</p>
<p>// utility method for creating the contextual cues<br>-(UILabel<em>) createCueLabel {<br>UILabel</em> label = [[UILabel alloc] initWithFrame:CGRectNull];<br>label.textColor = [UIColor whiteColor];<br>label.font = [UIFont boldSystemFontOfSize:32.0];<br>label.backgroundColor = [UIColor clearColor];<br>return label;<br>}</p>
<p>对于标记和叉的图标来说与其用图片素材，还不如使用Unicode编码就像上面的代码一样来得好。你可能找到了一些比较漂亮的素材，但是这些编码能够很快执行出这样的效果，所以无需添加图片素材。</p>
<blockquote>
<p>注意：为什么我知道这些代表着对号和叉号的unicode值？可以通过<a href="http://en.wikibooks.org/wiki/Unicode/List_of_useful_symbols" target="_blank" rel="noopener">list of<br>useful Unicode<br>symbols</a>很方便的找到!</p>
</blockquote>
<p>现在在<code>layoutSubviews</code>函数末尾添加如下代码来重定位这些标签:</p>
<pre><code>_tickLabel.frame = CGRectMake(-UI_CUES_WIDTH - UI_CUES_MARGIN, 0,</code></pre><p>UI_CUES_WIDTH, self.bounds.size.height);<br>_crossLabel.frame = CGRectMake(self.bounds.size.width +<br>UI_CUES_MARGIN, 0,<br>UI_CUES_WIDTH, self.bounds.size.height);</p>
<p>上面的代码让标签位于屏幕外，勾号再左边叉号再右边。</p>
<p>最后，在<code>handlePan:</code>中添加代码，在block中处于<code>UIGestureRecognizerStateChanged</code>状态哪里添加如下代码，用来在用户拖动cell的时候调整label的透明度:</p>
<p>// fade the contextual cues<br>float cueAlpha = fabsf(self.frame.origin.x) / (self.frame.size.width /<br>2);<br>_tickLabel.alpha = cueAlpha;<br>_crossLabel.alpha = cueAlpha;</p>
<p>// indicate when the item have been pulled far enough to invoke the<br>given action<br>_tickLabel.textColor = _markCompleteOnDragRelease ?<br>[UIColor greenColor] : [UIColor whiteColor];<br>_crossLabel.textColor = _deleteOnDragRelease ?<br>[UIColor redColor] : [UIColor whiteColor];</p>
<p>这个勾和叉号通过改变颜色更加明显的体现了用户拖动的项目是否足够远-接下来编译项目你就会注意到这个现象了：</p>
<p>完成这个最后的功能之后，你已经完成了整套系列的三分之一！</p>
<h3 id="接下来该做什么"><a href="#接下来该做什么" class="headerlink" title="接下来该做什么?"></a>接下来该做什么?</h3><hr>
<p>这里有一些<a href="http://www.raywenderlich.com/downloads/ClearStyle1Final.zip" target="_blank" rel="noopener">示例</a>，里面包含了这个部分的所有源代码。</p>
<p>下一步做什么呢？好遥远，现在这个app只是能够允许用户标记项目完成或者删除项目。这里显然需要更多的手势或者特性来是的应用更丰富。</p>
<p>不过，我不是很想用很常见的UITableView提供的删除动画。我肯定这里应该需要用一个更加炫的方法。</p>
<p>不幸的是，使用继承UITableView多多少少限制了一些功能，这也是为什么接下来的一部分将会替换这部分你写的自定义功能。不过它一直都是一个很大的话题，你会等到第二部分才能找出所有有关它的一切。</p>
<p>其实，为什么不自己思考更多有趣的东西和手势来想替换现有的控件。当然，如果你使用手势，不要忘记怎么去提醒用户来发现它们和使用它们的可能性。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2016/05/18/%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%83%8FClear%E7%9A%84%E6%97%B6%E9%AB%A6%E7%9A%84%E6%89%8B%E5%8A%BF%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95app%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2016/04/13/%E8%B0%88%E8%B0%88Http%E5%92%8CHttps%20/"
                            aria-label=": 谈谈Http和Https"
                        >
                            谈谈Http和Https
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-04-13T11:12:19+08:00">
	
		    13 4月 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/https/">https</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>===============</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>继续上一篇文章深入研究网络相关的知识，因为上一篇还是有很多没有解释很清楚的地方，所以在这里想讲讲自己对http和https的理解。</p>
<p>自从苹果更新了iOS9.0之后一直没机会研究它为什么把所以的请求都改为了https，第一反应肯定是考虑安全方面，那到底http和https有什么区别，https改善了http的哪些安全方面的不足呢？</p>
<h3 id="Http的缺点"><a href="#Http的缺点" class="headerlink" title="Http的缺点"></a>Http的缺点</h3><hr>
<p>Http从1990年正式推出到后面更新到Http/2之后就再也没更新。而在安全方面它只是更新到了1.1，也就是说这么多年来Http一直都没有解决安全方面的问题。</p>
<p>1.因为Http的通信是明文的，所以存在被窃听的风险。<br>2.无法确认身份。<br>3.无法验证报文的完整性。</p>
<h3 id="通信明文"><a href="#通信明文" class="headerlink" title="通信明文"></a>通信明文</h3><p>因为Http本身没有加密功能，所以在通信过程中都是明文通信的，这样会造成被第三方窃听的危险。</p>
<p>目前比较普遍的解决方式就是对通信内容进行加密，在客户端与服务端在通信之间对通信的数据进行加密，这样即使被窃听了，窃听方必须进行解密才能看到数据内容。但是这并不是最安全的方式，因为还是有可能会被解密的。</p>
<h3 id="无法验证通信方的身份"><a href="#无法验证通信方的身份" class="headerlink" title="无法验证通信方的身份"></a>无法验证通信方的身份</h3><p>因为Http没有验证身份的功能，所以很有可能会被人伪装。</p>
<ul>
<li>目前很多都是用用户密码的方式来验证身份，但是一旦密码被窃取就会被其他人伪装，所以也不是很安全，这是第一点。</li>
<li>是如果服务器不对客户端请求进行身份认证的话，那随便哪个客户端都能对服务器进行通信，这样可能造成恶意攻击等问题而使服务器浪费不必要的资源甚至瘫痪。</li>
<li>因为无法验证身份所以，在通信过程中服务端无法得知客户端是谁，客户端也不知道得到的响应是谁发送过来的，其中很有可能伪装的。</li>
</ul>
<h3 id="无法验证报文的完整性"><a href="#无法验证报文的完整性" class="headerlink" title="无法验证报文的完整性"></a>无法验证报文的完整性</h3><p>因为Http无法验证收到的报文信息的完整性。因此通信双方无法在收到信息前得知发送过来的报文是否和接收到的报文是否一致，也就是说无法验证在途中是否被篡改过。</p>
<h1 id="Https的优点"><a href="#Https的优点" class="headerlink" title="Https的优点"></a>Https的优点</h1><hr>
<p>那知道了以上的缺点之后大概也能猜得出Https和Http有什么区别了吧。Https就是Http</p>
<ul>
<li>通信加密 + 身份认证 +<br>数据完整性的保护。Https主要应用在需要在安全上面做一些保护的通信上，比如像平时登录淘宝，浏览器的地址栏会有一个带锁的标志，这个就是Https通信的标识。</li>
</ul>
<p>有一点需要先说清楚，Https并不是新的协议，它只是对原先的Http套了一层壳，这个壳的作用就是起到了保护的作用，可以说是对Http给了套装备，但是它还是Http。而这层壳的名字就叫SSL（Secure<br>Socket Layer），通常都是Http和TCP通信，加了SSL层之后就变成先是 Http 和<br>SSL通信，然后再由SSL和TCP通信。</p>
<p>经过SSL这一层的保护之后，Http就有了通信加密，身份认证(证书)和数据完整性验证的功能了。</p>
<p>![](./谈谈Http和Https _ 飞奔的蜗牛的博客_files/https_01.jpg)</p>
<h3 id="Https是如何解决这些问题的"><a href="#Https是如何解决这些问题的" class="headerlink" title="Https是如何解决这些问题的"></a>Https是如何解决这些问题的</h3><hr>
<p>SSL使用了公开秘钥加密技术，从而解决了通信加密和身份认证的问题。</p>
<h3 id="相互交换的公开密钥加密技术"><a href="#相互交换的公开密钥加密技术" class="headerlink" title="相互交换的公开密钥加密技术"></a>相互交换的公开密钥加密技术</h3><p>大家都知道，外面的很多加密算法都是公开的，所以不是很安全。这里所指的公开密钥加密技术就是在通信双方各持2种密钥，一种是公开密钥一种是私钥，公钥和密钥的关系就是公钥加密了，就要用对方的私钥解密。</p>
<p>比方说客户端有份需要加密的数据需要发送给服务器，它首先持手中的公钥对数据进行了加密，然后连同数据一起发送给服务器，这个时候服务器拿到加密后的数据和客户端发过来的公钥后，它会对公钥进行验证确认下是不是自己人，这里就先解决了身份认证的问题。然后服务器持手中的私钥，这个是只有服务器才有的钥匙，对数据进行解密。因为私钥从未公开过，所以没有人能拿到这个私钥，而发送过来的公钥是不能够对这份数据进行解密的，所以也解决了数据加密而防止被人破解的问题。</p>
<p>![](./谈谈Http和Https _ 飞奔的蜗牛的博客_files/https_02.jpg)</p>
<p>为什么要用公钥私钥两把钥匙，因为如果通信双方公用一把钥匙的话就可能会被拦截，然后使用这把钥匙给解密。但是如果不发送钥匙的话又不知道对方的身份。</p>
<p>这里有个疑问，密钥是从何而来的？密钥其实就是一种加密算法。如果被攻击者偷偷替换掉了公钥，那数据不就危险了吗？这个是这个技术唯一的缺点，当然也有解决方法，那就是从第三方证书颁发机构申请，当然这个是需要付费的。当你用自己的密钥向可靠的第三方申请数字证书的时候，第三方颁布的它会把密钥和带有数字签名的证书绑定在一起，这个时候当你需要验证这份公钥是否是自己的就可以通过第三方验证。</p>
<p>![](./谈谈Http和Https _ 飞奔的蜗牛的博客_files/https_03.jpg)</p>
<p><strong><em>关于第三点，因为通信被加密了所以也就不存在数据被人篡改的问题了</em></strong></p>
<h3 id="已知SSL的缺点"><a href="#已知SSL的缺点" class="headerlink" title="已知SSL的缺点"></a>已知SSL的缺点</h3><p>其实SSL真正用起来的话比刚刚所说的还要复杂，除了密钥公钥，验证密钥，加密解密等步骤，还有一些零零碎碎的会话需要处理，所以相比http会慢很多。不过起码保证了安全嘛，而且平时开发中只有涉及到敏感数据才使用SSL。否则对服务器压力太大也是件麻烦事。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看过书之后以前一直觉得远不可攀的这些东西，自己琢磨之后也就那回事情，虽然本文章并没有把Https的方方面面给讲透，但已经把核心部分给说明了。总结下来就是</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2016/04/13/%E8%B0%88%E8%B0%88Http%E5%92%8CHttps%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2016/03/18/SDWebImage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
                            aria-label=": SDWebImage源码分析"
                        >
                            SDWebImage源码分析
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-03-18T11:12:19+08:00">
	
		    18 3月 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>==================</p>
<p>###前言</p>
<p>使用SDWebImage这个第三方开源库也有一段时间了，一直没有机会去深入理解这个库为何如此强大。这次本着冒险的精神花了点时间去里面探索了一番。虽然过程有点痛苦结果也是弄的自己灰头土脸的，不过起码还是有收获的。所以在本blog做一次第一次探险的记录吧。</p>
<hr>
<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage github地址</a></p>
<p>原文是这么说的：SDWebImage是一个图片的异步下载器并且支持缓存。<br>作者是 <a href="https://github.com/mythodeia" target="_blank" rel="noopener">Konstantinos<br>K.</a>,目前star数已超过1.3w。目前有很多著名的app都在使用这个库，如携程，Facebook等。<br>虽然它的主要功能就这2点，但是它无可厚非的成为了目前主流的iOS第三方开源库的王者之一。</p>
<p>下面来看一下SDWebImage的类关系图</p>
<p>PS: 图片来自于 <a href="http://www.jianshu.com/p/c07df06c60be" target="_blank" rel="noopener">http://www.jianshu.com/p/c07df06c60be</a></p>
<hr>
<p>自从更新iOS5.0之后，NSURLCache这个类已成为处理内存或者硬盘存储源数据的必需品。但是当你将原始缓存数据转换成UIImage的时候，这个举动其实是很浪费资源的，包括数据处理和内存拷贝等。<br>而SDWebImage就是为了解决这个问题而诞生的，SDWebImage会缓存UIimage的描述到内存中，并把经过压缩过的图片放到磁盘中（或者内存中），这样大大减小了在频繁从内存中获取图片的性能开销。<br>然后关于SDWebImage的压缩方式也很人性化的使用了后台线程的方式，避免了线程阻塞的问题。</p>
<p>参考文章：<a href="https://github.com/rs/SDWebImage/wiki/How-is-SDWebImage-better-than-X%3F" target="_blank" rel="noopener">https://github.com/rs/SDWebImage/wiki/How-is-SDWebImage-better-than-X%3F</a></p>
<p>以上2点是SDWebImage的优势所在，接下来为了论证它的这些特点我们详细分析下它的源码：</p>
<ol>
<li>SDWebImage 在缓存中进行写的操作是异步执行的，所以不会对UI造成延迟</li>
<li>SDWebImage 会在后台解压缩图片</li>
<li>异步下载图片，不会阻塞线程</li>
<li>良好的缓存管理</li>
<li>支持arm64位系统</li>
</ol>
<p>先来看一下SDWebImageDownloader，在SDWebImageDownloader类中</p>
<p><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock</code></p>
<p>该接口中这么写到</p>
<blockquote>
<p>In order to prevent from potential duplicate caching (NSURLCache +<br>SDImageCache) we disable the cache for image requests if told<br>otherwise</p>
</blockquote>
<p>它为了不与SDImageCache类产生冲突造成重复缓存，所以在请求的时候并没有做图片的存储工作。它把下载图片和缓存全部都交由SDWebImageManager来管理了。</p>
<dl><dt>然后关于URL的缓存策略不出乎意料的还是就常见的2中方式<code>NSURLRequestUseProtocolCachePolicy</code></dt><dd>默认的缓存策略，<br>如果缓存不存在，直接从服务端获取。如果缓存存在，会根据response中的Cache-Control字段判断下一步操作，如:<br>Cache-Control字段为must-revalidata,<br>则询问服务端该数据是否有更新，无更新的话直接返回给用户缓存数据，若已更新，则请求服务端.</dd></dl><p><code>NSURLRequestReloadIgnoringLocalCacheData</code> :<br>忽略本地缓存，直接向服务器请求数据。</p>
<pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL*)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock {
__block SDWebImageDownloaderOperation *operation;
__weak __typeof(self)wself = self;

[self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^{
    NSTimeInterval timeoutInterval = wself.downloadTimeout;
    if (timeoutInterval == 0.0) {
        timeoutInterval = 15.0;
    }

    // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise
    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];
    request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);
    request.HTTPShouldUsePipelining = YES;
    if (wself.headersFilter) {
        request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);
    }
    else {
        request.allHTTPHeaderFields = wself.HTTPHeaders;
    }
    operation = [[wself.operationClass alloc] initWithRequest:request
                                                      options:options
                                                     progress:^(NSInteger receivedSize, NSInteger expectedSize) {
                                                         SDWebImageDownloader *sself = wself;
                                                         if (!sself) return;
                                                         __block NSArray *callbacksForURL;
                                                         dispatch_sync(sself.barrierQueue, ^{
                                                             callbacksForURL = [sself.URLCallbacks[url] copy];
                                                         });
                                                         for (NSDictionary *callbacks in callbacksForURL) {
                                                             dispatch_async(dispatch_get_main_queue(), ^{
                                                                 SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];
                                                                 if (callback) callback(receivedSize, expectedSize);
                                                             });
                                                         }
                                                     }
                                                    completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) {
                                                        SDWebImageDownloader *sself = wself;
                                                        if (!sself) return;
                                                        __block NSArray *callbacksForURL;
                                                        dispatch_barrier_sync(sself.barrierQueue, ^{
                                                            callbacksForURL = [sself.URLCallbacks[url] copy];
                                                            if (finished) {
                                                                [sself.URLCallbacks removeObjectForKey:url];
                                                            }
                                                        });
                                                        for (NSDictionary *callbacks in callbacksForURL) {
                                                            SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];
                                                            if (callback) callback(image, data, error, finished);
                                                        }
                                                    }
                                                    cancelled:^{
                                                        SDWebImageDownloader *sself = wself;
                                                        if (!sself) return;
                                                        dispatch_barrier_async(sself.barrierQueue, ^{
                                                            [sself.URLCallbacks removeObjectForKey:url];
                                                        });
                                                    }];
    operation.shouldDecompressImages = wself.shouldDecompressImages;

    if (wself.urlCredential) {
        operation.credential = wself.urlCredential;
    } else if (wself.username &amp;&amp; wself.password) {
        operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];
    }

    if (options &amp; SDWebImageDownloaderHighPriority) {
        operation.queuePriority = NSOperationQueuePriorityHigh;
    } else if (options &amp; SDWebImageDownloaderLowPriority) {
        operation.queuePriority = NSOperationQueuePriorityLow;
    }

    [wself.downloadQueue addOperation:operation];
    if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {
        // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency
        [wself.lastAddedOperation addDependency:operation];
        wself.lastAddedOperation = operation;
    }
}];

return operation;
}</code></pre><p>SDWebImageDownLoader默认的缓存策略是<code>NSURLRequestReloadIgnoringLocalCacheData</code>，它会把已经设置好的request交由SDWebImageDownloaderOperation处理图片方向，标记标签等，它命名的标签就是URL。最终通过block返回给SDWebImageManager做本地存储工作。直到下次加载图片的时候会通过标签进行本地搜寻直接返回图片，如果本地没有该图片就会再通过NSURLConnection请求资源。</p>
<p>在上面几个步骤中有几个问题需要讲一下：</p>
<ul>
<li><p>为什么SDWebImage不直接使用NSURLConection自己的缓存策略，反而还另外写了个SDImageCache类。那么麻烦的事情肯定有其中的原因在。</p>
<ul>
<li>因为NSURLConection的缓存方式是把图片以data的形式存在本地的，所以SDWebImage考虑到如果频繁使用图片的情况下会花很多的资源在处理data转成UIImage对象上，所以才避开了这个缓存方式改以用SDImageCache。</li>
</ul>
</li>
<li><p>使用过程当中有什么值得注意的细节</p>
<ul>
<li><p>都知道压缩图片是一件很伤神伤力的事情，强大的SDWebImage也无法轻松承受多张图片同时解压缩过程，所以特地把这个过程放在了自动释放池中进行。但是在iOS7上面还是要记得通过调用<code>[SDImageCache sharedImageCache] clearMemory]</code>来清理缓存。详细可查看<code>SDWebImageDecoder</code>类。<br>PS:它是不会对gif格式的图片进行压缩的。</p>
</li>
<li><p>常用的图片格式有gif，jpg，png,tiff,bmp，webp等都是支持的。</p>
</li>
<li><p>目前使用的是NSURLConnection，所以还不支持后台运行。</p>
</li>
</ul>
</li>
</ul>
<p>大致的缓存处理过程就是这么回事，核心思路就是这些，其他辅助类都不多做解释了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结构十分清晰，该避免的一些基础性的错误都避免了，类似retain<br>cycle，线程的管理。耗时长的请求都放在异步执行了。这个缓存策略是我以前从没想过的问题，为了追求性能的极致确实需要做到这份儿上。</p>
<p>代码上面没有什么难度，大量的基础知识非常适合中级iOS程序员做提升自己的训练课程，以上。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2016/03/18/SDWebImage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2016/02/13/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89UIViewController%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/"
                            aria-label=": 创建自定义UIViewController过渡动画"
                        >
                            创建自定义UIViewController过渡动画
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-02-13T11:12:19+08:00">
	
		    13 2月 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>原文来自<a href="http://www.raywenderlich.com/110536/custom-uiviewcontroller-transitions" target="_blank" rel="noopener">Creating Custom UIViewController<br>Transitions</a></p>
<p><code>Push，pop，cover vertically...</code><br>你从iOS中学会了一些漂亮的视图过渡效果，但是如果让你自己制作的话也会很有趣。自定义<code>UIViewController</code>过渡效果能显著地增加用户体验并且让你的app与其他的与众不同。如果你以前没亲自做过自定义过渡，你会发现它的工作量比你预期的要少很多。</p>
<p>在此次课程中，你将会制作一个带有一些自定义<code>UIViewController</code>过渡效果的猜测游戏。当你完成的时候，你将会获得以下技能：</p>
<ul>
<li>Transition的API是怎样的结构</li>
<li>如何使用自定义过渡来实现呈现和消除view controller</li>
<li>如何做有交互的过渡效果</li>
</ul>
<blockquote>
<p>Note:<br>在此教程中所示的过渡效果是利用<code>UIView</code>动画，所以你必须熟悉关于此次主题的知识，至少需要熟悉基础知识。可以查看我们的教程<a href="http://www.raywenderlich.com/113674/ios-animation-tutorial-getting-started" target="_blank" rel="noopener">iOS<br>Animation</a>中的简介。</p>
</blockquote>
<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>下载 <a href="http://www.raywenderlich.com/110536/custom-uiviewcontroller-transitions" target="_blank" rel="noopener">starter project for this<br>tutorial</a>.运行项目,你会看到如下效果：<br><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/07/starter.gif" alt=""></p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/08/cuteness-overload-322x320.jpg" alt=""></p>
<hr>
<p>你会看到app中一个page view<br>controller有好几张卡。每张卡都在形容一种动物，点击卡片会展示这张卡所描述的动物。</p>
<p>而你的工作就是猜这个动物！是只猫，狗还是一条鱼？玩玩看，看你能玩的怎么样。</p>
<p>大部分的导航逻辑做的已经蛮到位了，但是这个app还是感觉有点单调乏味。你来用自定义过渡来使这个app变的更加有趣吧。</p>
<h3 id="探索Transitioning-API"><a href="#探索Transitioning-API" class="headerlink" title="探索Transitioning API"></a>探索Transitioning API</h3><p>具体的来说，就是过渡效果API大量的使用了协议。在本章节末尾，你会理解每个协议之间的联系和职责。下面这张示例图会告诉你API中分为那几个主要部分：<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/07/parts.001-667x500.jpg" alt=""></p>
<h3 id="参与者（The-Participants）"><a href="#参与者（The-Participants）" class="headerlink" title="参与者（The Participants）"></a>参与者（The Participants）</h3><p>（这个标题不知道怎么翻译，）<br>尽管这个示例图看起来很复杂，当你理解了其中各部分是如何工作之后你就会觉得它其实很简单。</p>
<h3 id="Transitioning-Delegate"><a href="#Transitioning-Delegate" class="headerlink" title="Transitioning Delegate"></a>Transitioning Delegate</h3><p>每一个<code>view controller</code>都可能会有一个遵循<code>UIViewControllerTransitioningDelegate</code>协议的<code>transitioningDelegate</code></p>
<p>当你去呈现或者消除一个<code>view controller</code>的时候，UIKit会向transitioning<br>delegate请求使用<code>animation controller</code>,把view controller的<br><code>transitioningDelegate</code>设置为你自己写的类并且返回给它，这样自定义的动画会替代默认动画。</p>
<h3 id="Animation-Controller"><a href="#Animation-Controller" class="headerlink" title="Animation Controller"></a>Animation Controller</h3><p>对一个实现<code>UIViewControllerAnimatedTransitioning</code>协议的对象执行过渡动画。</p>
<h3 id="过渡环境（Transitioning-Context）"><a href="#过渡环境（Transitioning-Context）" class="headerlink" title="过渡环境（Transitioning Context）"></a>过渡环境（Transitioning Context）</h3><p>你没有必要自己亲手去写代码来执行这协议。相反，当过渡开始时你的animation<br>controller会从UIKit得到一个完整的配置环境。</p>
<h3 id="过渡过程（The-Transitioning-Process）"><a href="#过渡过程（The-Transitioning-Process）" class="headerlink" title="过渡过程（The Transitioning Process）"></a>过渡过程（The Transitioning Process）</h3><p>这里是几个在呈现过渡时的步骤：</p>
<ol>
<li>你用代码或者连接触发了过渡效果。</li>
<li>然后UIKit向”to” view controller（将要被呈现的view<br>controller）请求transitioninig<br>delegate。如果它没有，UIKit会使用默认的那个，内置到过渡效果中。</li>
<li>然后UIKit通过<code>animationControllerForPresentedController(_:presentingController:sourceController:)</code>向transitioninig<br>delegate请求一个animation<br>controller。如果它返回<code>nil</code>，将会使用默认过渡动画效果。</li>
<li>一旦它有了一个有效的animation<br>controller,UIKIt就会构建出一个过渡环境。</li>
<li>然后UIKit会从animation<br>controller使用<code>transitionDuration(_:)</code>查询动画的持续时间。</li>
<li>然后UIKit会在animation<br>controller中唤醒<code>animateTransition(_:)</code>来执行过渡。</li>
<li>最后，animation<br>controller会在过渡体系中调用<code>completeTransition(_:)</code>接口来表示动画已经结束。</li>
</ol>
<h3 id="创建一个自定义的呈现过渡效果（Creating-a-Custom-Presentation-Transition）"><a href="#创建一个自定义的呈现过渡效果（Creating-a-Custom-Presentation-Transition）" class="headerlink" title="创建一个自定义的呈现过渡效果（Creating a Custom Presentation Transition）"></a>创建一个自定义的呈现过渡效果（Creating a Custom Presentation Transition）</h3><p>是时候实践下你新学到的知识了！</p>
<p>你的目标是执行以下动画：</p>
<ul>
<li>当用户点击一张卡片，快速翻转并呈现出一张缩小至和卡片一样大小的第二个界面。</li>
<li>快速翻转之后，界面放大至整个屏幕一样大小。</li>
</ul>
<h3 id="创建动画"><a href="#创建动画" class="headerlink" title="创建动画"></a>创建动画</h3><p>你将开始制作animation controller。</p>
<p>打开<code>File\New\File…</code>,选择<code>iOS\Source\Cocoa Touch Class</code>,然后点击<code>Next</code>。起名为<code>FlipPresentAnimationController</code>,设置它的超类为<code>NSObject</code>语言为<code>Swift</code>。点击<code>Next</code>然后设置群组为<code>Animation Controllers</code>。点击<code>Create</code>来创建你的新文件。</p>
<p>Animation<br>controllers必须执行<code>UIViewControllerAnimatedTransitioning</code>的协议。打开<code>FlipPresentAnimationController.swift</code>,然后更新类的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import UIKit</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">class FlipPresentAnimationController: NSObject,     UIViewControllerAnimatedTransitioning &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>注意由于缺少接口你可能会遇到一些编译错误；不要慌-你正在解决这些问题。<br><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/08/staring-at-pc-462x320.gif" alt=""></p>
<p>Compiler errors…don’t panic…</p>
<hr>
<p>接下来你将要使用被点击的卡片的frame来当做动画的起始点。按照下面这句话写在类中来保存这个值。</p>
<pre><code>var originFrame = CGRect.zeroRect</code></pre><p>为了满足<code>UIViewControllerAnimatedTransitioning</code>的需求，你还需要在类中加2个接口。</p>
<p>在类的底部加接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func transitionDuration(transitionContext: UIViewControllerContextTransitioning) -&gt; NSTimeInterval &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      return 2.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>顾名思义，这个接口指的是过渡的持续时间。在开发期间先设置两秒,这样我们有足够的时间来观察动画。</p>
<p>现在添加下面这条接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个协议是用来执行过渡动画的。接下来把下面这段代码插入接口顶部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">guard let fromVC &#x3D; transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">let containerView &#x3D; transitionContext.containerView(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">let toVC &#x3D;     transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    return</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">let initialFrame &#x3D; originFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">let finalFrame &#x3D; transitionContext.finalFrameForViewController(toVC)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">let snapshot &#x3D; toVC.view.snapshotViewAfterScreenUpdates(true)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">snapshot.frame &#x3D; initialFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">snapshot.layer.cornerRadius &#x3D; 25</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">snapshot.layer.masksToBounds &#x3D; true</span></pre></td></tr></table></figure>
<p>上面的代码发生了什么：</p>
<ol>
<li>过渡环境会提供需要用到的view<br>controllers并且它们的view会参与进过渡效果。你可以通过合适的key来获得它们。</li>
<li>你接下来定义了”to”<br>view的frame开始和最后的大小。在这个例子中，frame由过渡开始的卡片大小到放大至整个屏幕。</li>
<li><code>UIView</code> 快速翻转至”to”<br>view并且使它变成一个轻便的界面;这会把你的view和其层级结构做成动画。snapshot的frame刚开始为卡片的frame。你也可以修改它的corner<br>radius至卡片一样。</li>
</ol>
<p>继续在接口中添加鞋面几行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">containerView.addSubview(toVC.view)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">containerView.addSubview(snapshot)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">toVC.view.hidden &#x3D; true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">AnimationHelper.perspectiveTransformForContainerView(containerView)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">snapshot.layer.transform &#x3D; AnimationHelper.yRotation(M_PI_2)</span></pre></td></tr></table></figure>
<p>一个新成员出现了：contriner<br>view。你可以把它想象成一块跳舞的地板而你的过渡正在上面扭。虽然container<br>view已经包含了”from” view，但是你还必须去添加”to”view。</p>
<p>你现在已经添加了container的截图并且隐藏了真正的view。这个完整的动画会将截图旋转出view然后隐藏掉。</p>
<blockquote>
<p>注意：不要被<code>AnimationHelper</code><br>混淆。它是一个功能性的类，主要负责对view做变形动画和增加透视效果。随意看一下就行。</p>
</blockquote>
<p>此时，你已经具备了执行动画的所有条件。在接口底部添加最后的一部分代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let duration &#x3D; transitionDuration(transitionContext)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">UIView.animateKeyframesWithDuration(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  duration,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  delay: 0,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  options: .CalculationModeCubic,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  animations: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">UIView.addKeyframeWithRelativeStartTime(0.0, relativeDuration: 1&#x2F;3, animations: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  fromVC.view.layer.transform &#x3D; AnimationHelper.yRotation(-M_PI_2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">UIView.addKeyframeWithRelativeStartTime(1&#x2F;3, relativeDuration: 1&#x2F;3, animations: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  snapshot.layer.transform &#x3D; AnimationHelper.yRotation(0.0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">UIView.addKeyframeWithRelativeStartTime(2&#x2F;3, relativeDuration: 1&#x2F;3, animations: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">          snapshot.frame &#x3D; finalFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">   &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  completion: &#123; _ in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    toVC.view.hidden &#x3D; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    fromVC.view.layer.transform &#x3D;     AnimationHelper.yRotation(0.0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    snapshot.removeFromSuperview()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">transitionContext.completeTransition(!transitionContext.transitionWasCancelled())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr></table></figure>
<p>现在来对每个部分进行讨论：</p>
<ol>
<li>首先，你确定了动画持续时间。注意到了<code>transitionDuration(_:)</code>接口的用法，在类的顶部实施。你必须确保你声明的过渡效果持续时间和动画的持续时间相匹配这样UIKit才能保持它们同步。</li>
<li>在”from”view的y轴旋转到一半左右的时候你先把它隐藏起来。</li>
<li>接下来你用同样的技术把截图呈现了出来。</li>
<li>然后你对截图设置了frame并放大至整个屏幕大小。</li>
<li>最后，才能把”to”view给呈现出来。当屏幕截图不再使用的时候把它给移除掉。然后你把”from”view旋转至原来的样子；还有，当过渡回来的时候它有可能是隐藏着的。调用<code>completeTransition</code>的时候会通知过渡环境动画已经结束。UIKit为了保证最后的状态不变会把”from”view从container中移除。</li>
</ol>
<p>现在你可以准备使用animation controller！</p>
<h3 id="完整的写出动画"><a href="#完整的写出动画" class="headerlink" title="完整的写出动画"></a>完整的写出动画</h3><p>打开<code>CardViewController.swift</code>然后在类中声明这样的一个property：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">private let flipPresentAnimationController &#x3D; FlipPresentAnimationController()</span></pre></td></tr></table></figure>
<p>UIKit认为transitioning delegate会为了过渡去声明animation<br>controller。这样的话你必须先提供给<code>UIViewControllerTransitioningDelegate</code>一个合理的对象。</p>
<p>在此例子中，<code>CardViewController</code>将承担<code>transitioning delegate</code>的工作。在源文件底部添加下面的这个继承<code>UIViewControllerTransitioningDelegate</code>的扩展类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">extension CardViewController: UIViewControllerTransitioningDelegate &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>接下来，只要在扩展类中添加如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  flipPresentAnimationController.originFrame &#x3D; cardView.frame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  return flipPresentAnimationController</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个时候你已经返回了你自己创建的自定义animation<br>controller。这个接口会保证过渡开始的时候使用的frame的正确性。</p>
<p>最后一步把<code>CardViewController</code>标记为transitioning delegate。View<br>controllers<br>本身有一个<code>transitioningDelegate</code>属性，如果它可能使用了自定义过渡UIKit会请求去查看。</p>
<p>添加<code>prepareForSeque(_:sender:)</code>,就在卡片指定的部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">destinationViewController.transitioningDelegate &#x3D; self</span></pre></td></tr></table></figure>
<p>如果<code>view controller being presented</code>是需要transitioning<br>delegate这一点很重要，不是view controller 执行了呈现效果。</p>
<p>编译项目，点击卡片你会看到如下效果：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/07/frontflip-slow.gif" alt=""></p>
<p>到了这里你有了自己的第一个自定义过渡效果。但是完成呈现新的view只解决了一般；你必须同样要一个华丽的消除效果！</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/08/yay.jpg" alt=""></p>
<p>Showy? I got yer showy right here!</p>
<hr>
<h3 id="消除-View-Controller"><a href="#消除-View-Controller" class="headerlink" title="消除 View Controller"></a>消除 View Controller</h3><p>定位到<code>File\New\File…</code>,选择<code>iOS\Source\Cocoa Touch Class</code>,点击<code>Next</code>。设置名字为<code>FlipDismissAnimationController</code>，确保它继承NSObject设置语言为<code>Swift</code>，点击<code>Next</code>并且确保保存在<code>Animation Controllers</code>这个群组。点击<code>Create</code>创建文件。</p>
<p>把新文件的内容替换成下面这些代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">import UIKit</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">class FlipDismissAnimationController: NSObject, UIViewControllerAnimatedTransitioning &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  var destinationFrame &#x3D; CGRectZero</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  func transitionDuration(transitionContext: UIViewControllerContextTransitioning) -&gt; NSTimeInterval &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    return 0.6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>其实这个类在本质上和presentation animation是相反的：</p>
<ul>
<li>把view缩回到和卡片一样大小；<code>destinationFrame</code>用来保存这个值。</li>
<li>快速翻转view之后显示原来的那张卡片。</li>
</ul>
<p>在<code>animateTransition(_:):</code>接口中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">guard let fromVC &#x3D; transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">let containerView &#x3D; transitionContext.containerView(),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">let toVC &#x3D; transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">return</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">let initialFrame &#x3D; transitionContext.initialFrameForViewController(fromVC)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">let finalFrame &#x3D; destinationFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">let snapshot &#x3D; fromVC.view.snapshotViewAfterScreenUpdates(false)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">snapshot.layer.cornerRadius &#x3D; 25</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">snapshot.layer.masksToBounds &#x3D; true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">containerView.addSubview(toVC.view)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">containerView.addSubview(snapshot)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">fromVC.view.hidden &#x3D; true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">AnimationHelper.perspectiveTransformForContainerView(containerView)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">toVC.view.layer.transform &#x3D; AnimationHelper.yRotation(-M_PI_2)</span></pre></td></tr></table></figure>
<p>这是对每部分你做了什么做出的讨论：</p>
<ol>
<li>从view的缩小动画开始之后，你需要快速翻转所用到的initialFrame和finalFrame。</li>
<li>因为这个时候你需要操作”from”view，所以你获取了它的截图。</li>
<li>就像之前一样，你添加了”to”view 并且添加了之前获取的截图到container<br>view。然后隐藏”from”view，这样不会与截图产生冲突。</li>
<li>最后，用同样的旋转方法把”to”view给隐藏掉。</li>
</ol>
<p>剩下的就是帮它自己添加动画。<br>直接把这段代码放入<code>animateTransition(_:):</code>底部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">let duration &#x3D; transitionDuration(transitionContext)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">UIView.animateKeyframesWithDuration(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> duration,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> delay: 0,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> options: .CalculationModeCubic,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> animations: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   &#x2F;&#x2F; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   UIView.addKeyframeWithRelativeStartTime(0.0, relativeDuration: 1&#x2F;3, animations: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">     snapshot.frame &#x3D; finalFrame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">   UIView.addKeyframeWithRelativeStartTime(1&#x2F;3, relativeDuration: 1&#x2F;3, animations: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">     snapshot.layer.transform &#x3D; AnimationHelper.yRotation(M_PI_2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">   &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">       UIView.addKeyframeWithRelativeStartTime(2&#x2F;3, relativeDuration: 1&#x2F;3, animations: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">         toVC.view.layer.transform &#x3D; AnimationHelper.yRotation(0.0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">       &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"> &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"> completion: &#123; _ in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">       &#x2F;&#x2F; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">       fromVC.view.hidden &#x3D; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">       snapshot.removeFromSuperview()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">       transitionContext.completeTransition(!transitionContext.transitionWasCancelled())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<p>这个效果差不多就是和反过来的presentation animation一样；</p>
<ol>
<li>你首先缩放了view，然后在旋转的同时隐藏了截图。接下来你通过往相反的方向并绕着y轴旋转”to”view<br>到一半后呈现出来。</li>
<li>最后，在过渡结束的时候你移除了截图并通知过渡环境过渡已经结束。这样就允许了UIKit能够分层的刷新视图并且对过渡过程中的视图进行整理。</li>
</ol>
<p>打开<code>CardViewController.swift</code>,把下面这句代码声明在之前那个animation<br>controller右下方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">private let flipDismissAnimationController &#x3D; FlipDismissAnimationController()</span></pre></td></tr></table></figure>
<p>接下来，在类中创建一个如下所示的拓展类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      flipDismissAnimationController.destinationFrame &#x3D; cardView.frame</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      return flipDismissAnimationController</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>通过这个接口把正确的frame给到dismissing animation controller并且返回它。</p>
<p>跟最后一步一样，修改<code>transitionDuration</code>和<br><code>FlipPresentAnimationController</code>让动画变的更漂亮。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func transitionDuration(transitionContext: UIViewControllerContextTransitioning) -&gt; NSTimeInterval &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      return 0.6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>编译app，点击卡片你会看到呈现和消除动画。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/07/flip-ready.gif" alt=""></p>
<p>你的自定义动画看上去有点尖锐，不过你可以通过为它添加用户交互动画来提升效果。</p>
<h3 id="使它有交互性"><a href="#使它有交互性" class="headerlink" title="使它有交互性"></a>使它有交互性</h3><p>iOS中的设置就是一个典型的有交互动画的好例子：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/07/settings.gif" alt=""></p>
<p>你在这一章节的任务就是手势在屏幕左侧挥动的时候卡片导航回面朝下的状态。过渡过程会跟随用户的手指变化。</p>
<h3 id="交互动画是如何工作的"><a href="#交互动画是如何工作的" class="headerlink" title="交互动画是如何工作的"></a>交互动画是如何工作的</h3><p>interaction controller<br>会对touch事件或者加速，减速甚至相反的过渡效果都会产生回应。<br>为了激活交互过渡效果，transition delegate还必须提供一个interaction<br>controller。<br>任何对象都可以执行<code>UIViewControllerInteractiveTransitioning</code>协议。你已经做完了过渡动画；interaction<br>controller会在对手势产生反馈的时候移动动画而不是播放视频。</p>
<p>Apple<br>提供了了现成的<code>UIPercentDrivenInteractiveTransition</code>类，它就是interaction<br>controller的实体类。你可以通过这个类制作你的交互过渡效果。</p>
<h3 id="创建一个交互过渡"><a href="#创建一个交互过渡" class="headerlink" title="创建一个交互过渡"></a>创建一个交互过渡</h3><p>你的第一个工作就是创建一个interaction<br>controller。定位到<code>File\New\File…</code>,然后选择<code>iOS\Source\Cocoa Touch Class.</code>。起名为<code>SwipeInteractionController</code>,选择它的超类为<code>UIPercentDrivenInteractiveTransition</code>。确保选中的语言为<code>Swift</code>然后点击<code>Next</code>。选择<code>Interaction Controllers</code>群组然后点击<code>Create</code>。</p>
<p>打开<code>SwipeInteractionController.swift</code>，然后在类的顶部定义一下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var interactionInProgress &#x3D; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">private var shouldCompleteTransition &#x3D; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">private weak var viewController: UIViewController!</span></pre></td></tr></table></figure>
<p>上面的代码十分简单:</p>
<ol>
<li>顾名思义，<code>interactionInProgress</code>指的是是否已经在交互过程中。</li>
<li>你将会使用<code>shouldCompleteTransition</code>在内部控制过渡-你将会在后面看到它。</li>
<li>interaction controller会直接呈现和消除view<br>controllers，所以你必须在<code>viewController</code>中捕获当前的view<br>controller。</li>
</ol>
<p>在类中添加一下接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func wireToViewController(viewController: UIViewController!) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      self.viewController &#x3D; viewController</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      prepareGestureRecognizerInView(viewController.view)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>你所有的执行会依靠检测手势来控制过渡。在上面那个接口中，你获得了view<br>controller的引用，并且对它的view建立了手势识别器。</p>
<p>如下面所示执行<code>prepareGestureRecognizerInView(_:)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">private func prepareGestureRecognizerInView(view: UIView) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      let gesture &#x3D; UIScreenEdgePanGestureRecognizer(target: self, action:     &quot;handleGesture:&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      gesture.edges &#x3D; UIRectEdge.Left</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      view.addGestureRecognizer(gesture)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这是你声明的手势识别器，当在左侧边缘滑动的时候它会被触发并添加到view上。</p>
<p>最后一个谜题就是如下面所示添加<code>handleGesture(_:)</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func handleGesture(gestureRecognizer: UIScreenEdgePanGestureRecognizer) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  let translation &#x3D; gestureRecognizer.translationInView(gestureRecognizer.view!.superview!)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  var progress &#x3D; (translation.x &#x2F; 200)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  progress &#x3D; CGFloat(fminf(fmaxf(Float(progress), 0.0), 1.0))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  switch gestureRecognizer.state &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  case .Began:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    interactionInProgress &#x3D; true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    viewController.dismissViewControllerAnimated(true, completion: nil)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  case .Changed:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    shouldCompleteTransition &#x3D; progress &gt; 0.5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    updateInteractiveTransition(progress)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  case .Cancelled:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    interactionInProgress &#x3D; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    cancelInteractiveTransition()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  case .Ended:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    interactionInProgress &#x3D; false</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    if !shouldCompleteTransition &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">      cancelInteractiveTransition()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">      &#125; else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">      finishInteractiveTransition()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  default:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">      println(&quot;Unsupported&quot;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>解谜：</p>
<ol>
<li>你首先声明了一个本地变量当做动画过程的轨迹。你会记录下view的过渡并且计算动画过程。滑动200点的距离等于100%的完成度，所以你可以通过这个数字来计算过渡进度。</li>
<li>当手势开始的时候，你适当的在view<br>controller中调整了<code>interactionInProgress</code>并且触发了消除事件。</li>
<li>当手势开始移动的时候，你随着进度量连续的调用了<code>updateInteractiveTransition</code>。这是一个<code>UIPercentDrivenInteractiveTransition</code>的接口它沿着你传入的百分比值来移动过渡效果。</li>
<li>如果手势被取消，你更新了<code>interactionInProgress</code>并且让过渡滚回到原来的状态。</li>
<li>只要手势已经结束，你当前使用的过渡进度会给用户决定这个时候是取消过渡还是完成过渡。</li>
</ol>
<p>来把剩下的都写完</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/08/glory-pc-480x279.jpg" alt=""></p>
<p>打开<code>CardViewController.swift</code>然后在interaction<br>controller中声明如下的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">private let swipeInteractionController &#x3D; SwipeInteractionController()</span></pre></td></tr></table></figure>
<p>UIKit会在<code>interactionControllerForDismissal(_:).</code>这个接口中向transitioning<br>delegate请求一个interaction controller。</p>
<p>在文件底部加入如下的扩展类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">func interactionControllerForDismissal(animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">          return swipeInteractionController.interactionInProgress ?        swipeInteractionController : nil</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这里会去检查当前的view是否在检查手势，意思就是这里有个交互效果正在进行中。然后它会返回一个合适的view<br>controller。</p>
<p>现在定位到<code>prepareForSegue(_:sender:)</code>,在<code>transitioningDelegate</code>下面添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">swipeInteractionController.wireToViewController(destinationViewController)</span></pre></td></tr></table></figure>
<p>这个会给interaction controller一个被呈现的view controller的引用。</p>
<p>编译项目，点击卡片，在左侧滑动你就会看到最终效果：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/07/interactive.gif" alt=""></p>
<p>恭喜-你创建了一个漂亮的交互动画！</p>
<h3 id="接下来该怎么办"><a href="#接下来该怎么办" class="headerlink" title="接下来该怎么办?"></a>接下来该怎么办?</h3><p>你可以从<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/12/GuessThePet-Finished.zip" target="_blank" rel="noopener">这里</a>下载本次教程的完整案例。</p>
<p>去学习更多的知识，找到第3章，在<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials" target="_blank" rel="noopener">iOS 7 by<br>Tutorials</a><br>“Custom View Controller Transitions”以及第19章，在<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="noopener">iOS Animations by<br>Tutorials</a>中的”Custom<br>Presentation Controller &amp; Device Orientation Animations”。</p>
<p>本次教程针对了modal presentation 和 dismissal<br>transitions。指出使用container view<br>controllers的时候自定义UIViewController 交互动画也能使用是很重要的：</p>
<ul>
<li>当在使用navigation controller，声明animation<br>controllers是它的delegate的责任，一个遵循于<code>UINavigationControllerDelegate</code>的对象。这个delegate可以在<code>navigationController(_:animationControllerForOperation:fromViewController:toViewController:)</code>接口中提供一个animation<br>controller。</li>
<li>tab bar<br>controller则是依赖于<code>tabBarController(_:animationControllerForTransitionFromViewController:toViewController:)</code>接口中执行<code>UITabBarControllerDelegate</code>协议来返回animation<br>controller的一个对象。</li>
</ul>
<p>我希望你能对本次教程感兴趣；如果你有什么问题或者建议，请加入我们的论坛！</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2016/02/13/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89UIViewController%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/12/29/%E7%BB%86%E8%B0%88iOS8%E7%9A%84Self-Sizing%20Cells%20/"
                            aria-label=": 细谈iOS8的Self-Sizing Cells"
                        >
                            细谈iOS8的Self-Sizing Cells
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-12-29T11:12:19+08:00">
	
		    29 12月 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>===========================</p>
<p>之前有篇文章介绍了<br>FDTemplateLayoutCell，对于UITableViewCell自动计算高度没有做详细的解释，最近用下来感觉自己不能老是依靠第三方控件，这次返回来讲解下iOS8的Working<br>with Self-Sizing Tableview cells 。</p>
<p>对，我要使用Self-Sizing<br>Cells。虽然有点打脸，但身为一个合格的程序员你必须得学会靠自己来解决这些问题，最起码得理解。如果频繁依靠第三方控件我觉得并不是一个优秀程序员该做的事情。</p>
<h1 id="我要使用Self-Sizing-Cells"><a href="#我要使用Self-Sizing-Cells" class="headerlink" title="我要使用Self-Sizing Cells"></a>我要使用Self-Sizing Cells</h1><hr>
<p>首先有句话要说，这篇文章仅是个人观点，有不同意见的欢迎讨论。<br>都知道Self-Sizing是iOS8才更新的，最近又做了些调查，发现使用iOS8以前的用户占了8%左右。比我去年写的那篇文章iOS8一下的用户少了%2。这里先不详细分析这剩余的8%是什么样的用户，为什么不升级，对公司业务走向有什么影响。</p>
<p>其实个人觉得还是得考虑这么几方面，8%的人中有多少是使用app的，为什么不升级系统。可能这之中有一些不会使用app的中老年人，有只是用来当做电话用的老年人，或者因为手机内存不够而不愿更新的，这是一点。第二点，如果是小公司，在人手不是很足的情况下最好还是不要去支持iOS8以下，不光是这一点，还有其他功能上面都会给开发团队造成大量的维护更新工作。</p>
<h1 id="Self-Sizing-Cells"><a href="#Self-Sizing-Cells" class="headerlink" title="Self-Sizing Cells"></a>Self-Sizing Cells</h1><hr>
<p>在iOS8以前，决定tableviewcell<br>的高度的接口都是<code>tableView:heightForRowAtIndexPath:</code>。也就是说你需要在这个接口中手动计算高度。当你把cell和self-sizing<br>绑定在一起的时候你就可以不必去管这个接口了，不用再去考虑计算这个高度了。我们只需要给<code>estimatedRowHeight</code>一个估算值，然后设置tableview的<code>rowHeight</code>属性为<br><code>UITableViewAutomaticDimension</code>就可以了，接下来就是设置约束了。</p>
<p>只要设置标签与cell的高度保持一定的距离，那么这个约束就会完成cell的self-sizing。值得注意的是估高尽量设置的稍微贴切点，设置的越精确效率就更高。</p>
<p>相关文章:</p>
<p><a href="https://developer.apple.com/videos/" target="_blank" rel="noopener">WWDC 2014 Session 226 What’s New in Table and Collection<br>Views</a></p>
<p><a href="http://useyourloaf.com/blog/self-sizing-table-view-cells/" target="_blank" rel="noopener">Self Sizing Table View<br>Cells</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/12/29/%E7%BB%86%E8%B0%88iOS8%E7%9A%84Self-Sizing%20Cells%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/07/14/iOS8%E6%96%B0%E7%89%B9%E6%80%A7%20UIPresentationController%20/"
                            aria-label=": iOS8新特性 UIPresentationController"
                        >
                            iOS8新特性 UIPresentationController
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-07-14T11:12:19+08:00">
	
		    14 7月 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>================================</p>
<p>先推荐几篇关于UIPresentationController的好文章</p>
<ul>
<li><a href="http://nonomori.farbox.com/post/ios-8-presentation-controller" target="_blank" rel="noopener">iOS8 Presentation<br>Controller</a></li>
<li><a href="http://zappdesigntemplates.com/custom-presentations-using-uipresentationcontroller-swift/" target="_blank" rel="noopener">Custom presentations using UIPresentationController in<br>Swift</a><br>自从iOS8更新之后，swift成为了各个程序员平时议论的焦点，包括我。这几天回顾了下去年的WWDC发现了这次Apple更新了很多好玩的东西，其中我就发现了一个叫<code>UIPresentationController</code><br>以前一直都很想做一个比较酷炫的界面过渡效果，但一直没有花时间去研究，这次正好被我机缘巧合的碰到了就顺手拿来研究了一下。</li>
</ul>
<h3 id="什么是UIPresentationController"><a href="#什么是UIPresentationController" class="headerlink" title="什么是UIPresentationController"></a>什么是UIPresentationController</h3><p>其实从我上面说的话就可以知道<code>UIPresentationController</code>就是专门控制界面之间的过渡效果的类。<br>这是官方文档的原话</p>
<blockquote>
<p>A UIPresentationController object provides advanced view and<br>transition management for presented view controllers.</p>
</blockquote>
<p>意思就是<code>UIPresentationController</code>提供了对view<br>controllers的呈现和移动的管理，<br>你可以通过这个类来对<code>被跳转</code>和<br><code>将要呈现的</code>界面进行管理。你可以让他们缩小变大，翻转可以加上一些其他的动画效果。</p>
<p>早在iOS7的时候其实苹果已经开放了类似的功能<code>UIViewControllerTransitioning</code>，而此次更新主要解决了自适应的问题，以前在<br>Compact<br>的宽度条件下如果要使用<code>popoverPresentationController</code>的话必须先判断iPhone和iPad设备，入下面的代码：</p>
<pre><code>if UIDevice.currentDevice().userInterfaceIdiom == .Pad {
    let popOverController = UIPopoverController(contentViewController: nextVC)
popOverController.presentPopoverFromRect(aRect, inView: self.view,         permittedArrowDirections: .Any, animated: true)
} else {
    presentViewController(nextVC, animated: true, completion: nil)
}</code></pre><p>现在有了<code>UIPresentationController</code>就不需要这样做了。从Size<br>Classes改革了.m文件中全是判断设备的代码之后，这次把这仅存的需要判断设备的代码也清除了，同时你也可以看到相关的判断设备的方法已经被弃用了。</p>
<p>下面就用个实例来说明UIPensentationController是如何使用和工作的吧，就做一个模仿twitter分享效果的例子吧</p>
<h3 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a>UIViewControllerTransitioningDelegate</h3><p>先来看一下<code>UIViewControllerTransitioningDelegate</code><br>我们现在将要呈现的页面中实现<code>UIViewControllerTransitioningDelegate</code>的接口</p>
<pre><code>func presentationControllerForPresentedViewController(presented: UIViewController, presentingViewController presenting: UIViewController, sourceViewController source: UIViewController) -&gt; UIPresentationController? {
    return CustomPresentationController(presentedViewController:presented,presentingViewController:presenting)
}

func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
    return NormalDismissAnimation()
}
func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
   return PresentationAnimation()
}</code></pre><p>其中我对第二第三个接口返回了自定义的动画效果,对第一个接口返回了继承<code>UIPresentationController</code>的类并初始化。</p>
<blockquote>
<p>Initializes and returns a presentation controller for transitioning<br>between the specified view controllers</p>
</blockquote>
<h3 id="UIPresentationController"><a href="#UIPresentationController" class="headerlink" title="UIPresentationController"></a>UIPresentationController</h3><p>先看下<code>UIPresentationController</code>的4个接口</p>
<ul>
<li>presentationTransitionWillBegin</li>
<li>presentationTransitionDidEnd</li>
<li>dismissalTransitionWillBegin</li>
<li>dismissalTransitionDidEnd</li>
</ul>
<p>顾名思义，想要创建一些效果的话就必须在<code>presentationTransitionWillBegin</code>实现,如果在init函数中实现的话会获取不到<code>containerView</code>。</p>
<pre><code>import UIKit

class CustomPresentationController: UIPresentationController {
   lazy var dimmingView:UIView = {
    let view = UIView(frame: self.containerView!.bounds)
    view.backgroundColor = UIColor(red: 0.0, green: 0.0, blue:         0.0, alpha: 0.5)
return view
    }()
override init(presentedViewController: UIViewController,     presentingViewController: UIViewController) {
super.init(presentedViewController: presentedViewController,             presentingViewController: presentingViewController)
}</code></pre><p>这里必须重写init方法，否则上面的四个接口不会执行。</p>
<pre><code> override func presentationTransitionWillBegin() {

        let containerView = self.containerView!
        let presentedView = self.presentedView()!

    //在containerView中加载dimmingView，dimmingView就是在界面过渡中的一个效果
    dimmingView.frame = containerView.bounds
    containerView.addSubview(dimmingView)
    containerView.addSubview(presentedView)
    self.dimmingView.alpha = 0

    //对dimmingView做一个渐变效果
    if let transitionCoordinator = self.presentingViewController.transitionCoordinator() {
        transitionCoordinator.animateAlongsideTransition({(context: UIViewControllerTransitionCoordinatorContext!) -&gt; Void in
            self.dimmingView.alpha = 0.7
            }, completion:nil)
    }
}

override func presentationTransitionDidEnd(completed: Bool) {

}

override func dismissalTransitionWillBegin() {
    if let transitionCoordinator = self.presentingViewController.transitionCoordinator() {
        transitionCoordinator.animateAlongsideTransition({(context: UIViewControllerTransitionCoordinatorContext!) -&gt; Void in
            self.dimmingView.alpha = 0.0
            }, completion:nil)
    }
}

override func dismissalTransitionDidEnd(completed: Bool) {
    if completed {
        self.dimmingView.removeFromSuperview()
    }
}</code></pre><p>对这4个接口分别写上处理dimmingView的逻辑，动画效果基本就做好了。</p>
<h3 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a>UIViewControllerAnimatedTransitioning</h3><p>接下来是2个自定义的动画，其实如果像方便点的话直接把这2个动画写在<code>UIPresentationController</code>里也是可以的。不过为了重用性，我选择把这2个动画拿出来</p>
<pre><code>class PresentationAnimation: NSObject ,UIViewControllerAnimatedTransitioning{

let duration = 0.7

func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval {
    return self.duration
}

func animateTransition(transitionContext: UIViewControllerContextTransitioning) {
    //将呈现的视图
    let presentedView = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!
    let presentingView = transitionContext.viewForKey(UITransitionContextToViewKey)!
    let contrainerView = transitionContext.containerView()!
    //被过渡的视图
    let fromView = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)
    let center = fromView!.view.center


    let pSize = CGSizeMake(presentingView.frame.size.width*0.95, presentingView.frame.size.height*0.95)
    presentingView.frame = transitionContext.finalFrameForViewController(presentedView)
    presentingView.center.y += contrainerView.bounds.size.height
    contrainerView.addSubview(presentingView)



    UIView.animateWithDuration(self.duration, delay: 0.0, usingSpringWithDamping: 1.0, initialSpringVelocity: 0.0, options: .AllowUserInteraction, animations: {
        fromView!.view.frame.size = pSize
        fromView!.view.center = center
        presentingView.center.y -= contrainerView.bounds.size.height
        }, completion: {(completed: Bool) -&gt; Void in
            transitionContext.completeTransition(completed)
            contrainerView.insertSubview(fromView!.view, atIndex: 0)
    })
}</code></pre><p>我对fromView也就是被过渡的视图的宽高缩小到95%的动画效果，在dismiss动画就反过来。</p>
<p>有一点要注意的是当dismiss动画结束之后，fromview会莫名其妙的被移除掉。这个问题很奇怪我也没找到很好的解释，解决方案可以参考stackoverflow上的一篇问答</p>
<p><a href="http://stackoverflow.com/questions/24338700/from-view-controller-disappears-using-uiviewcontrollercontexttransitioning" target="_blank" rel="noopener">“From View Controller” disappears using<br>UIViewControllerContextTransitioning</a></p>
<p>在动画结束后重新加载fromview就可以了。</p>
<pre><code>UIApplication.sharedApplication().keyWindow!.addSubview(fromView.view)</code></pre><p>下面看下效果：</p>
<p>附上源码</p>
<p><a href="https://github.com/fuer4869/UIPresentationController.git" target="_blank" rel="noopener">UIPresentationControllerDemo</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/07/14/iOS8%E6%96%B0%E7%89%B9%E6%80%A7%20UIPresentationController%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/04/14/%E7%94%A8xctool%E6%89%93%E5%8C%85ipa%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0fir%20/"
                            aria-label=": 用xctool打包ipa文件自动上传到fir"
                        >
                            用xctool打包ipa文件自动上传到fir
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-04-14T11:12:19+08:00">
	
		    14 4月 2015
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>================================</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>HomeBrew 环境<br>在这里就不多介绍了，可以看我写的另外一篇<a href="http://fuer4869.github.io/2015/04/14/%E7%94%A8xctool%E6%89%93%E5%8C%85ipa%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0fir/" target="_blank" rel="noopener">Mac安装记录</a>的文章</li>
<li>安装xctool <a href="https://github.com/facebook/xctool" target="_blank" rel="noopener">xctool</a></li>
<li>如何使用xctool</li>
<li>安装fir<br><a href="https://github.com/FIRHQ/fir-cli/blob/master/README.md" target="_blank" rel="noopener">fir.im-cli</a></li>
<li>创建.sh文件（本例用的是sh脚本）,如果想用php语言的就创建.php文件。</li>
<li>自动上传fir</li>
</ol>
<hr>
<h3 id="xctool"><a href="#xctool" class="headerlink" title="xctool"></a>xctool</h3><hr>
<p>xctool<br>是facebook专门对xcode开发的构建工具，在苹果的xcodebuild限制条件种种的环境下很多人都选择了这款工具，并且它是开源的。</p>
<h4 id="如何安装xctool"><a href="#如何安装xctool" class="headerlink" title="如何安装xctool"></a>如何安装xctool</h4><hr>
<pre><code>brew update

brew install xctool</code></pre><p>很方便，这就是为什么要装Homebrew的原因。</p>
<hr>
<p>下面简单介绍下xctool的命令：<br>先输入下面的命令</p>
<ul>
<li>xctool -help</li>
<li>xctool [BASE OPTIONS] clean <code>清理工程,功能等同于Xcode中的clean</code></li>
<li>xctool [BASE OPTIONS] build <code>Xcode中的build</code></li>
<li>xctool [BASE OPTIONS] build-tests [-only TARGET] [-omit<br>TARGET] [-skip-deps]</li>
<li>xctool [BASE OPTIONS] run-tests [-test-sdk SDK] [-only SPEC]<br>[-omit SPEC] [-freshSimulator] [-resetSimulator]<br>[-noResetSimulatorOnFailure] [-freshInstall] [-parallelize]<br>[-logicTestBucketSize N] [-appTestBucketSize N] [-bucketBy<br>BUCKETBY] [-failOnEmptyTestBundles] [-listTestsOnly]<br>[-targetedDeviceFamily FAMILY] [-testTimeout N] [-logicTest<br>BUNDLE] [-appTest BUNDLE:HOST_APP]</li>
<li>xctool [BASE OPTIONS] test [-test-sdk SDK] [-only SPEC]<br>[-omit SPEC] [-skip-deps] [-freshSimulator]<br>[-resetSimulator] [-noResetSimulatorOnFailure] [-freshInstall]<br>[-parallelize] [-failOnEmptyTestBundles] [-logicTestBucketSize<br>N] [-appTestBucketSize N] [-bucketBy BUCKETBY]<br>[-listTestsOnly] [-testTimeout N]</li>
<li>xctool [BASE OPTIONS] archive [-archivePath PATH]<br><code>生成编译文件,也是打包ipa核心命令</code></li>
<li>xctool [BASE OPTIONS] analyze [-only TARGET] [-skip-deps]<br>[-failOnWarnings]<ul>
<li>xctool [BASE OPTIONS] install</li>
</ul>
</li>
</ul>
<p>另外3个测试的暂时不讲。</p>
<h3 id="如何使用xctool"><a href="#如何使用xctool" class="headerlink" title="如何使用xctool"></a>如何使用xctool</h3><h4 id="Base-Options"><a href="#Base-Options" class="headerlink" title="Base Options"></a>Base Options</h4><p>这个参数其实就是选择工程，为什么说是工程而不是项目，xctool很做的十分全面，它不但能帮你编译和清理项目更方便的是它能够帮你测试项目。所以这里需要明确的告诉xctool你要编译哪个工程或者测试哪个工程。具体看下面的命令：</p>
<pre><code>-help                    show help

-workspace PATH          path to workspace---针对workspace项目的命令，如果你的项目集成了cocoapods，那么用这个命令就行了。

-project PATH            path to project----反之这个命令就是对没有集成cocoapods的

-scheme NAME             scheme to use for building or testing ----- scheme用来告诉xctool test 和 build的对象工程名称

-find-target TARGET      Search for the workspace/project/scheme to build the target                      ------也可以根据target名称来找到workspace或者project，但是这个太慢了不建议用来做这次测试，不过可以当做一个搜索工具来用。

-find-target-path PATH   Path to search for -find-target. 同上

-find-target-exclude-pathColon-separated list of paths to exclude for -find-target.

-sdk VERSION             sdk to use for building (e.g. 6.0, 6.1)

-configuration NAME      configuration to use (e.g. Debug, Release)

-jobs NUMBER             number of concurrent build operations to run

-arch ARCH               arch to build for (e.g. i386, armv7)

-toolchain PATH          path to toolchain

-xcconfig PATH           path to an xcconfig

-reporter TYPE[:FILE]    add reporter

-showBuildSettings       display a list of build settings and values

-version                 print version and exit

SETTING=VALUE            Set the build &apos;setting&apos; to &apos;value&apos;</code></pre><p>其他都是些很简单的命令就不做解释了。<br>这里给大家一个小技巧，在编译工程的时候项目中的证书必须使用正确才能编译通过，但是我们的项目证书有时候一直在换的不可能为了编译一次项目再去换证书，这样很麻烦。所以可以在项目中增加个自定义的Configuration,如下图我添加了一个名为DailyBuild的Configuration</p>
<p>![](./用xctool打包ipa文件自动上传到fir _<br>飞奔的蜗牛的博客_files/3344ggg.png)</p>
<p>添加好后会在项目的Target-&gt;Build Setting-&gt;Code<br>Signing中多出一个DailyBuild选项，你可以在这里配置你需要打包的证书，这样就不用一直把证书换来换去了。<br>![](./用xctool打包ipa文件自动上传到fir _<br>飞奔的蜗牛的博客_files/2015-12-22-02.png)</p>
<hr>
<h3 id="编写-sh脚本并且上传到fir"><a href="#编写-sh脚本并且上传到fir" class="headerlink" title="编写.sh脚本并且上传到fir"></a>编写.sh脚本并且上传到fir</h3><p>安装完fir命令行工具后就可以开始编写脚本了</p>
<pre><code><figure class="highlight plain"><figcaption><span>shtest.sh```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">最后在终端中输入命令：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#96;&#96;&#96;.&#x2F;shtest.sh</span></pre></td></tr></table></figure></code></pre><p>然后你就可以去做其他事情了，让它帮你解决接下来的事情吧！</p>
<p>上传成功</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个懒人程序猿繁多的时代中，这种能够帮我们解决很多繁琐工作的工具真是业界良心啊。有句话真没说错，facebook出品必属精品。后面我还稍微研究了下xctool，发现它的测试功能也很强大，比苹果自带的强大不少，log界面也十分清晰。</p>
<p>本来想上传成功之后邮件通知的，查阅资料后本地发送邮件不是很靠谱。之后会尝试看看能不能通过服务器帮我们构建ipa上传和发送邮件。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/04/14/%E7%94%A8xctool%E6%89%93%E5%8C%85ipa%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0fir%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/tags/iOS/page/2/"
                aria-label="ÄLTERE BEITRÄGE"
            >
              <span>ÄLTERE BEITRÄGE</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">Seite 1 von 2</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 loannes. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">loannes</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
