<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>loannes's blog</title><meta name="description"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/widget-post-list.css"><meta name="generator" content="Hexo 5.3.0"></head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">loannes's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><span>标签 · 中等</span></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><article class="post-container is-flex is-justify-content-center section container is-max-widescreen pt-4 px-2"><div class="columns is-variable is-1-tablet is-3-desktop-only is-2-widescreen is-full-width"><section class="column"><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><i class="tag post-item-tag">广度优先搜索</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">剑指-Offer-32-I-从上到下打印二叉树</a></h2><time class="has-text-grey" datetime="2021-02-20T23:39:24.000Z">2021-02-21</time><p class="is-flex-grow-2 mt-2">

前往此题  

广度优先搜索这题比较简单，使用迭代法很轻松就能解出来。本题实际上求的是逐层遍历整个二叉树，按照从左至右的顺序依次打印。这里我们只需要借助队列queue将每层的节点放入其中，按照先进先出的规则依次访问节点值并放入最终答案res中即可。
代码# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -&amp;gt; Lis..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><i class="tag post-item-tag">深度优先搜索</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/">129. 求根到叶子节点数字之和</a></h2><time class="has-text-grey" datetime="2021-02-06T10:54:44.000Z">2021-02-06</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路这是一道很典型的深度优先搜索题。题目很明确的告诉我们需要从根节点出发按照节点路径走到底来遍历整个二叉树。我们可以通过total这个变量来记录每条路径上的值。total * 10 + root.val，total记录数值的终止条件为走到节点的末尾，也就是找不到它的左右子节点。total记录的终止条件 :root.left == null &amp;amp;&amp;amp; root.right == null

代码
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#        ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%95%B0%E7%BB%84"><i class="tag post-item-tag">数组</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><i class="tag post-item-tag">二分查找</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/">81. 搜索旋转排序数组 II</a></h2><time class="has-text-grey" datetime="2021-02-06T07:24:27.000Z">2021-02-06</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路按照例题可以把该数组拆为2个区间。
第一种情况：
[2,5,6,0,0,1,2]拆解为[2,5,6]和[0,0,1,2]。

这种情况这两个区间都是升序的，在查找过程中只要确定target在哪个区间内就能通过二分查找直接锁定
第二种情况
[3,2,0,1,2] 拆解为 [3,2] 和 [0,1,2]
这种前者肯定是无序的，后者是有序的情况下（包括重复元素）。所以后者的判断条件如果写成nums[left] &amp;lt; nums[mid]的时候需要考虑到重复元素的情况，否则如[0,0,1]会出错。

第三种情况最后一种情况[1,1,1,0,1]拆解为[1,1,1,1]和[0] 以及 [3,1]都无法确定是否有序。这里特殊情况也要考虑进去, 通过left = left + 1来过滤掉重复项。..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88"><i class="tag post-item-tag">双指针</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/">19. 删除链表的倒数第 N 个结点</a></h2><time class="has-text-grey" datetime="2021-02-02T11:30:46.000Z">2021-02-02</time><p class="is-flex-grow-2 mt-2">

前往此题

双指针解法通过两个指针slow,fast可以很方便的解决这个问题。我们记录一个快指针，一个慢指针，slow指针起始点是链表头部，fast指针起始点为n。随即两个指针同时开始往下走，当fast走到链表末尾的时候，slow指针的下一个指针就是l-n，也就是倒数第n个节点。slow.next = slow.next.next删除即可。

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, h..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E9%80%92%E5%BD%92"><i class="tag post-item-tag">递归</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E8%BF%AD%E4%BB%A3"><i class="tag post-item-tag">迭代</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/">145. 二叉树的后序遍历</a></h2><time class="has-text-grey" datetime="2021-01-30T10:21:11.000Z">2021-01-30</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路按照后序遍历左子节点-&amp;gt;右子节点-&amp;gt;根节点的顺序来，下图的最终结果就是4 5 2 6 7 3 1

递归法递归法十分简单，直接套模板即可
class Solution:
    def postorderTraversal(self, root: TreeNode) -&amp;gt; List[int]:
        res = []
        self.dfs(root, res)
        return res


    def dfs(self, root, res):
        if not root: return

        self.dfs(root.left, res)
        self.dfs(root.right, re..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E9%80%92%E5%BD%92"><i class="tag post-item-tag">递归</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E8%BF%AD%E4%BB%A3"><i class="tag post-item-tag">迭代</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/">144. 二叉树的前序遍历</a></h2><time class="has-text-grey" datetime="2021-01-30T08:46:54.000Z">2021-01-30</time><p class="is-flex-grow-2 mt-2">

前往此题

基本概念要解决这道题首先得了解二叉树前序遍历
前序遍历
以下面这个二叉树为例，前序遍历的遍历顺序为根节点-&amp;gt;左子节点-&amp;gt;右子节点:

前序遍历一切都以左子节点为优先，即遍历结果为1 2 4 5 3 6 7
递归解法递归解法十分简单，直接上代码了
代码class Solution:
    def preorderTraversal(self, root: TreeNode) -&amp;gt; List[int]:
        def preorder(root:TreeNode):
            if not root: return
            res.append(root.val)
            root.left = preorder(roo..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E6%A0%88"><i class="tag post-item-tag">栈</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/">94. 二叉树的中序遍历</a></h2><time class="has-text-grey" datetime="2021-01-30T05:46:39.000Z">2021-01-30</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路预备知识：

二叉树结构基础
中序遍历是什么

什么是中序遍历
有个口诀叫：左根右意思就是在遍历过程中，先找到根节点然后会去找左子节点，如果有左子节点就继续在往下找，直到找到最地下一层的左子节点。如果没有左子节点就返回根节点，最后才返回右子节点。

如图：中序遍历最终返回的顺序为：BDCAEHGKF
递归法
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inor..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-04-03-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><i class="tag post-item-tag">广度优先搜索</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-04-03-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/">面试题-04-03-特定深度节点链表</a></h2><time class="has-text-grey" datetime="2021-01-20T23:36:19.000Z">2021-01-21</time><p class="is-flex-grow-2 mt-2">

前往此题  

广度优先搜索法用层序遍历能很方便的解这道题。将每层的节点放入队列queue，为每层生成一个链表将节点的值赋值到链表cur中。因为cur在遍历二叉树结束时，它指向的是链表的末尾，所以我们需要在初始化的时候将cur指向链表dummy， 最后将链表dummy放入结果res中
算法思路初始化队列queue, 结果列表res, 初始链表dummy。队列作为遍历的条件，它始终存储着二叉树每层的节点。由于链表最后会走到末尾，所以需要初始化一个dummy来指向它的头节点。层序遍历二叉树，将每层的值赋值到链表中，将链表放入res
代码# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#  ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-04-03-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">leetcode刷题笔记(一)</a></h2><time class="has-text-grey" datetime="2019-10-22T03:12:19.000Z">2019-10-22</time><p class="is-flex-grow-2 mt-2">======================

题一=========================================================================================================================
在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。
「黑皇后」在棋盘上的位置分布用整数坐标数组 queens表示，「白国王」的坐标用数组 king 表示。
「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。
请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。


输入：queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">更多</a></section></article></section><aside class="column is-hidden-mobile is-4-tablet is-3-widescreen"><div style="position: sticky; top: 50px;"><main class="aside-card-container tag-widget is-in-tag-page"><h3>标签</h3><section><a href="/tags/iOS"><span class="tag post-item-tag" style="margin-bottom: 5px;">iOS</span></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="tag post-item-tag" style="margin-bottom: 5px;">数据结构</span></a><a href="/tags/Python,%20NumPy"><span class="tag post-item-tag" style="margin-bottom: 5px;">Python, NumPy</span></a><a href="/tags/Python%EF%BC%8CNumPy"><span class="tag post-item-tag" style="margin-bottom: 5px;">Python，NumPy</span></a><a href="/tags/Python,%20Pandas"><span class="tag post-item-tag" style="margin-bottom: 5px;">Python, Pandas</span></a><a href="/tags/Python,%20pandas"><span class="tag post-item-tag" style="margin-bottom: 5px;">Python, pandas</span></a><a href="/tags/Python,%20Pandas,%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="tag post-item-tag" style="margin-bottom: 5px;">Python, Pandas, 数据存储</span></a><a href="/tags/Python,%20Scrapy"><span class="tag post-item-tag" style="margin-bottom: 5px;">Python, Scrapy</span></a><a href="/tags/ios%E9%80%86%E5%90%91"><span class="tag post-item-tag" style="margin-bottom: 5px;">ios逆向</span></a><a href="/tags/Python"><span class="tag post-item-tag" style="margin-bottom: 5px;">Python</span></a><a href="/tags/Python,%20Django"><span class="tag post-item-tag" style="margin-bottom: 5px;">Python, Django</span></a><a href="/tags/TCP/IP"><span class="tag post-item-tag" style="margin-bottom: 5px;">TCP/IP</span></a><a href="/tags/MySQL"><span class="tag post-item-tag" style="margin-bottom: 5px;">MySQL</span></a><a href="/tags/%E7%BB%83%E4%B9%A0"><span class="tag post-item-tag" style="margin-bottom: 5px;">练习</span></a><a href="/tags/python%E5%9F%BA%E7%A1%80,%20C++"><span class="tag post-item-tag" style="margin-bottom: 5px;">python基础, C++</span></a><a href="/tags/python%E5%9F%BA%E7%A1%80%EF%BC%8C%E7%AC%94%E8%AE%B0"><span class="tag post-item-tag" style="margin-bottom: 5px;">python基础，笔记</span></a><a href="/tags/%E5%9F%BA%E7%A1%80,%20NumPY"><span class="tag post-item-tag" style="margin-bottom: 5px;">基础, NumPY</span></a><a href="/tags/iOS,%E9%80%82%E9%85%8D"><span class="tag post-item-tag" style="margin-bottom: 5px;">iOS,适配</span></a><a href="/tags/%E5%8A%A8%E7%94%BB"><span class="tag post-item-tag" style="margin-bottom: 5px;">动画</span></a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="tag post-item-tag" style="margin-bottom: 5px;">内存管理</span></a><a href="/tags/%E9%80%82%E9%85%8D"><span class="tag post-item-tag" style="margin-bottom: 5px;">适配</span></a><a href="/tags/iOS,%20%E5%8A%A8%E7%94%BB"><span class="tag post-item-tag" style="margin-bottom: 5px;">iOS, 动画</span></a><a href="/tags/iOS%EF%BC%8CATS"><span class="tag post-item-tag" style="margin-bottom: 5px;">iOS，ATS</span></a><a href="/tags/%E6%A0%91"><span class="tag post-item-tag" style="margin-bottom: 5px;">树</span></a><a href="/tags/%E6%8E%92%E5%BA%8F"><span class="tag post-item-tag" style="margin-bottom: 5px;">排序</span></a><a href="/tags/%E9%80%92%E5%BD%92"><span class="tag post-item-tag" style="margin-bottom: 5px;">递归</span></a><a href="/tags/hashmap"><span class="tag post-item-tag" style="margin-bottom: 5px;">hashmap</span></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90"><span class="tag post-item-tag" style="margin-bottom: 5px;">计算机组成</span></a><a href="/tags/iOS,%20URL"><span class="tag post-item-tag" style="margin-bottom: 5px;">iOS, URL</span></a><a href="/tags/MySQL,%E7%AC%94%E8%AE%B0"><span class="tag post-item-tag" style="margin-bottom: 5px;">MySQL,笔记</span></a><a href="/tags/OOP,%20python"><span class="tag post-item-tag" style="margin-bottom: 5px;">OOP, python</span></a><a href="/tags/%E7%AE%80%E5%8D%95%EF%BC%8C%E6%95%B0%E7%BB%84%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88"><span class="tag post-item-tag" style="margin-bottom: 5px;">简单，数组，双指针</span></a><a href="/tags/%E7%AE%80%E5%8D%95"><span class="tag post-item-tag" style="margin-bottom: 5px;">简单</span></a><a href="/tags/DFS"><span class="tag post-item-tag" style="margin-bottom: 5px;">DFS</span></a><a href="/tags/%E6%95%B0%E7%BB%84"><span class="tag post-item-tag" style="margin-bottom: 5px;">数组</span></a><a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="tag post-item-tag" style="margin-bottom: 5px;">字符串</span></a><a href="/tags/%E9%93%BE%E8%A1%A8"><span class="tag post-item-tag" style="margin-bottom: 5px;">链表</span></a><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88"><span class="tag post-item-tag" style="margin-bottom: 5px;">双指针</span></a><a href="/tags/%E4%B8%AD%E7%AD%89"><span class="tag post-item-tag" style="margin-bottom: 5px;">中等</span></a><a href="/tags/LRU"><span class="tag post-item-tag" style="margin-bottom: 5px;">LRU</span></a><a href="/tags/%E6%A0%88"><span class="tag post-item-tag" style="margin-bottom: 5px;">栈</span></a><a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="tag post-item-tag" style="margin-bottom: 5px;">哈希表</span></a><a href="/tags/%E4%B8%AD%E7%AD%89%EF%BC%8C%20BFS"><span class="tag post-item-tag" style="margin-bottom: 5px;">中等， BFS</span></a><a href="/tags/BFS"><span class="tag post-item-tag" style="margin-bottom: 5px;">BFS</span></a><a href="/tags/%E8%BF%AD%E4%BB%A3"><span class="tag post-item-tag" style="margin-bottom: 5px;">迭代</span></a><a href="/tags/%E4%B8%AD%E7%AD%89%EF%BC%8C%E6%95%B0%E7%BB%84"><span class="tag post-item-tag" style="margin-bottom: 5px;">中等，数组</span></a><a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="tag post-item-tag" style="margin-bottom: 5px;">二分查找</span></a><a href="/tags/MySQL,%20%E4%BA%8B%E5%8A%A1"><span class="tag post-item-tag" style="margin-bottom: 5px;">MySQL, 事务</span></a><a href="/tags/%E6%B1%87%E6%80%BB"><span class="tag post-item-tag" style="margin-bottom: 5px;">汇总</span></a><a href="/tags/%E8%81%94%E7%BB%93"><span class="tag post-item-tag" style="margin-bottom: 5px;">联结</span></a><a href="/tags/%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><span class="tag post-item-tag" style="margin-bottom: 5px;">全文本搜索</span></a><a href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="tag post-item-tag" style="margin-bottom: 5px;">触发器</span></a><a href="/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="tag post-item-tag" style="margin-bottom: 5px;">存储过程</span></a><a href="/tags/%E8%A7%86%E5%9B%BE"><span class="tag post-item-tag" style="margin-bottom: 5px;">视图</span></a><a href="/tags/%E6%B8%B8%E6%A0%87"><span class="tag post-item-tag" style="margin-bottom: 5px;">游标</span></a><a href="/tags/%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="tag post-item-tag" style="margin-bottom: 5px;">子查询</span></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="tag post-item-tag" style="margin-bottom: 5px;">正则表达式</span></a><a href="/tags/%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="tag post-item-tag" style="margin-bottom: 5px;">组合查询</span></a><a href="/tags/%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93"><span class="tag post-item-tag" style="margin-bottom: 5px;">高级联结</span></a><a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="tag post-item-tag" style="margin-bottom: 5px;">归并排序</span></a><a href="/tags/Redis"><span class="tag post-item-tag" style="margin-bottom: 5px;">Redis</span></a><a href="/tags/MySQL%E9%94%81%EF%BC%8CInnoDB"><span class="tag post-item-tag" style="margin-bottom: 5px;">MySQL锁，InnoDB</span></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="tag post-item-tag" style="margin-bottom: 5px;">深度优先搜索</span></a><a href="/tags/%E6%A8%A1%E6%8B%9F%E6%B3%95"><span class="tag post-item-tag" style="margin-bottom: 5px;">模拟法</span></a><a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="tag post-item-tag" style="margin-bottom: 5px;">贪心算法</span></a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="tag post-item-tag" style="margin-bottom: 5px;">动态规划</span></a><a href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="tag post-item-tag" style="margin-bottom: 5px;">广度优先搜索</span></a><a href="/tags/%E8%AE%BE%E8%AE%A1"><span class="tag post-item-tag" style="margin-bottom: 5px;">设计</span></a><a href="/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="tag post-item-tag" style="margin-bottom: 5px;">分治算法</span></a></section></main></div></aside></div></article><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fuer4869"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> loannes 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></body></html>