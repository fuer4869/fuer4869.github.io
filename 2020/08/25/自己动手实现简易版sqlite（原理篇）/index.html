<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="loannes">





<title>自己动手实现简易版sqlite（原理篇） | loannes&#39;s blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    




<meta name="generator" content="Hexo 4.1.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">loannes&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">loannes&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">自己动手实现简易版sqlite（原理篇）</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">loannes</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">八月 25, 2020&nbsp;&nbsp;14:58:52</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>layout: ‘false’<br>title: 实现简易版sqlite（原理篇）<br>date: 2020-08-25 14:58:52<br>tags: sqlite, c, BTree<br>category: 数据库</p>
<p><img src="https://i.loli.net/2020/09/11/aUoXEGc1jF83MOp.jpg" alt=""></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在动手学习这块知识之前本身是抱着想了解数据库是如何实现的目的，但越往后越觉得数据库这个项目真的是复杂，但是也十分有趣。所以特地在此记录下我这些天来对sqlite的理解。</p>
<p>本篇文章是以简易版的sqlite(后面简称sqlite)为基础写出来的原理剖析，还有很多sqlite的基本功能还未涉及到，之后我会逐步添加上去。</p>
<h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><ul>
<li>本项目用纯c语言实现，</li>
<li>测试工具为<a href="http://rspec.info/" target="_blank" rel="noopener">rspec</a></li>
</ul>
<p>本sqlite的基本架构分为：</p>
<ul>
<li>核心层<ul>
<li>接口</li>
<li>SQL命令处理程序<ul>
<li>分词器(Tokenizer)</li>
<li>分析器(Parser)</li>
<li>代码生成器(Code Generator)</li>
</ul>
</li>
<li>虚拟机（后台）<ul>
<li>B树 (B-Tree)</li>
<li>页面调度程序（Pager）</li>
<li>操作系统接口 (OS Interface)</li>
</ul>
</li>
</ul>
</li>
<li>其他辅助类</li>
</ul>
<p><img src="https://i.loli.net/2020/09/19/gkwIPC5RoOM4Y9d.gif" alt=""></p>
<p>一般我们把<strong>接口</strong>和<strong>SQL命令处理程序</strong>称为<strong>前端</strong>，把<strong>虚拟机</strong>称为<strong>后端</strong>。前端负责处理应用程序传递过来的SQL语句和SQLite命令，对获取的编码分析、优化，并转换为后端能够执行的SQLite内部字节编码。</p>
<p>而<strong>后端</strong>才是真正的数据库处理工作，对数据的存储，如何做到快速的读写以及减少对磁盘的压力等都是它的工作。</p>
<p><strong>接口（Interface）</strong></p>
<p>在本程序中只有<code>main.c</code>这一个接口，作为<code>sqlite</code>的的程序入口。</p>
<p><strong>分词器（Tokenizer）</strong></p>
<p>当接口程序收到一条SQL语句时要把这个字符串传递给tokenizer。Tokenizer负责把这条SQL语句分割成一个个标识符（token），并把这些标识符传递给解析器。简单来讲就是区分这条语句到底是<code>select</code>还是<code>insert</code>等。</p>
<p><strong>分析器（Parser）</strong></p>
<p>而分析器就负责分词器剩下的工作， 在哪个表操作数据，选取哪些数据，插入到哪个表等。</p>
<p><strong>代码生成器（Code Generater）</strong></p>
<p>分析器解析完成后最终由代码生成器生成虚拟机能看懂的内部代码。如果是更新就传递给虚拟机<code>update</code>，如果是插入就传递给虚拟机<code>insert</code>等。</p>
<p><strong>虚拟机 （Virtual Machine）</strong></p>
<p>虚拟机才是本程序的灵魂啊，它是专为数据库文件操作而存在的引擎。将代码生成器传递过来的代码分配给对应的函数执行相关操作。</p>
<p><strong>B树（B-Tree)</strong></p>
<p>B-Tree是一种专为磁盘等存储设备设计的一种平衡查找树，学过操作系统的同学都知道磁盘的性能开销是十分宝贵的，它的每次IO都很慢很吃性能。而B-Tree这种数据结构能最大程度的优化在查找数据过程中的IO开销，减少查询次数。</p>
<p><strong>页面调度程序（Pager）</strong></p>
<p>B-Tree的每个节点都是按照数据页的形式存储在磁盘中，而Pager则负责读写以及缓存数据页。</p>
<p><strong>OS接口</strong></p>
<p>OS Interface也成为VFS，该模块提供了跨操作系统的可移植性。简单来讲就是能够使sqlite适应在不同的操作系统上。如read（）、write（）、lseek（）等都是OS接口部分。</p>
<p><strong>测试代码</strong></p>
<p>测试脚本，负责对sqlite大部分功能的测试工作。本项目使用的是<code>ruby</code>的<code>rspec</code>测试框架。</p>
<h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><p>目前只实现了<code>select</code>·<code>insert</code> <code>exit</code> </p>
<p>为分词器设计了一个缓冲区结构<code>InputBuffer</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">InputBuffer</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">char</span>* <span class="built_in">buffer</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">size_t</span> buffer_length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">ssize_t</span> input_length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;InputBuffer;</span></pre></td></tr></table></figure>

<p>而分词器的功能就是从输入流中获取一行二进制字符串(对的，目前只能一行一行分)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> bytes_read = getline(&amp;(input_buffer-&gt;<span class="built_in">buffer</span>), &amp;(input_buffer-&gt;buffer_length), <span class="built_in">stdin</span>);</span></pre></td></tr></table></figure>

<p>然后将获取到的数据流封装进<code>InputBuffer</code>中传递给解析器<strong>Parser</strong></p>
<h3 id="解析器-Parser"><a href="#解析器-Parser" class="headerlink" title="解析器(Parser)"></a>解析器(Parser)</h3><p>解析器收到分词器的数据后通过<code>strncmp</code>函数进行截取来判断将执行什么操作。对的，只支持插入、查询业务功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 解析器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * SQL Command Processor</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">PrepareResult <span class="title">prepare_statement</span><span class="params">(InputBuffer* input_buffer,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                                Statement* statement)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_buffer-&gt;<span class="built_in">buffer</span>, <span class="string">"insert"</span>, <span class="number">6</span>) == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> prepare_insert(input_buffer, statement);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;<span class="built_in">buffer</span>, <span class="string">"select"</span>) == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    statement-&gt;type = STATEMENT_SELECT;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> PREPARE_SUCCESS;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> PREPARE_UNRECOGNIZED_STATEMENT;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p>其他解析器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer, Table* table)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;<span class="built_in">buffer</span>, <span class="string">".exit"</span>) == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    db_close(table);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;<span class="built_in">buffer</span>, <span class="string">".btree"</span>) == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Tree:\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    print_tree(table-&gt;pager, <span class="number">0</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;<span class="built_in">buffer</span>, <span class="string">".constants"</span>) == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Constants:\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    print_constants();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>为虚拟机创建了两个类 <strong>Pager</strong> 、 <strong>Table</strong> 、<strong>Row</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pager</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> file_descriptor;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint32_t</span> file_length;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint32_t</span> num_pages;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span>* pages[TABLE_MAX_PAGES];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;Pager;</span></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  Pager* pager;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint32_t</span> root_page_num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;Table;</span></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Row_t</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint32_t</span> id;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">char</span> username[COLUMN_USERNAME_SIZE + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">char</span> email[COLUMN_EMAIL_SIZE + <span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Row_t</span> <span class="title">Row</span>;</span></span></pre></td></tr></table></figure>



<ul>
<li>Pager：这个页面调度程序负责管理所有节点，整个数据表中的节点都存储在<code>Pager-&gt;pages</code>中。</li>
<li>Table： 表对象充当着BTree的管理，它直接联系着BTree的根节点<code>root_page_num</code></li>
<li>Row:： 代表一行数据</li>
</ul>
<p><strong>OS接口</strong></p>
<p>在设计<code>select</code>与<code>insert</code>之前，先来研究下OS接口部分。</p>
<p><strong>write</strong></p>
<p>write()会把参数buf所指的内存写入count个字节到所指的文件fd内</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">write</span> (<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> count);</span></pre></td></tr></table></figure>

<p>这里也按照了操作系统的<strong>分页</strong>的内存管理方式，将数据一页一页的写入到指定文件中。</p>
<p>根据<strong>分页地址结构</strong>规则，一个页码<code>page_num</code>对应着一个偏移量，所以在确定了<strong>页码</strong>之后还需要确定<strong>偏移量</strong></p>
<p><img src="https://i.loli.net/2020/09/26/VIvb4wijqA9eQBT.png" alt=""></p>
<p>分页的<strong>偏移量</strong><code>offset</code> 也是OS部分的工作，在插入之前先移动到文件的读写位置<code>page*PAGE_SIZE</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> offset = lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);</span></pre></td></tr></table></figure>

<p>写入数据到指定文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> bytes_written =</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);</span></pre></td></tr></table></figure>

<p>在这里我们将每页大小设计为4096bytes,也就是4k。一般x86操作系统默认分页都是4k，当然现在很多架构下的页面分配方式可以自由选择，有2M、4M的都会有。既然我们是做数据库，本身用到的数据单位不会很大，而且是个轻量级的数据库，设计每页为4k也能起到在节约内存的同时减少磁盘IO次数。</p>
<p><strong>read</strong></p>
<p>read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">read</span>(<span class="keyword">int</span> fd, <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> count);</span></pre></td></tr></table></figure>

<p>同样读取数据也是按页读取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> bytes_read = <span class="built_in">read</span>(pager-&gt;file_descriptor, page, PAGE_SIZE);</span></pre></td></tr></table></figure>



<p><strong>插入数据Insert</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy</span> <span class="params">( <span class="keyword">void</span> * dest, <span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">size_t</span> num )</span></span>;</span></pre></td></tr></table></figure>

<p>memcpy函数会将缓冲区的内容复制到指定的内存中实现插入数据。</p>
<p>为了减少磁盘IO，只有在关闭数据库的时候才会将内容中的数据写入到磁盘中，其他都会在内存中操作数据，这样执行速度也会比直接操作磁盘快得多。</p>
<h3 id="BTree部分"><a href="#BTree部分" class="headerlink" title="BTree部分"></a>BTree部分</h3><p><strong>为什么数据结构部分用的是BTree？</strong></p>
<p>数据库设计这样的数据结构是为了让系统在查询数据的时候最大限度的减少磁盘的IO使用次数，因为数据库中那么多条数据，系统并不知道我们要查询的数据存在哪里，只能一页一页数据的找（系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么）。但是每找一页就是一次的IO，所以为了减少开销，必须在设计数据结构的时候能减少这方面的消耗。</p>
<p>B 树就是常说的“B 减树（B- 树）”，又名平衡多路（即不止两个子树）查找树，它和平衡二叉树的不同有这么几点：</p>
<ol>
<li>平衡二叉树节点最多有两个子树，而 B 树每个节点可以有多个子树，<strong>M 阶 B 树表示该树每个节点最多有 M 个子树</strong></li>
<li>平衡二叉树每个节点只有一个数据和两个指向孩子的指针，而 B 树每个<strong>中间节点</strong>有 k-1 个关键字（可以理解为数据）和 k 个子树（ <strong>k</strong> 介于阶数 M 和 M/2 之间，M/2 向上取整）</li>
<li>B 树的所有叶子节点都在同一层，并且叶子节点只有关键字，指向孩子的指针为 null</li>
</ol>
<p>和平衡二叉树相同的点在于：B 树的节点数据大小也是按照左小右大，子树与节点的大小比较决定了子树指针所处位置。</p>
<p><img src="https://i.loli.net/2020/10/06/X7xHiAvLq2IMulp.png" alt=""></p>
<p><code>BTree</code>中的每个节点对应一个磁盘块（页），上图是一个3阶BTree，每个节点最多有两个关键字和三个指向对应子节点的指针，关键字超过两个就会产生新的子节点。如果我们要查找<strong>28</strong>这条数据，数据库首先从磁盘中读取<strong>磁盘块1</strong>，对<strong>磁盘块1</strong>中的数据进行二分查找，如果不存在就找到目标所在的范围: 17 &lt; 28 &lt; 35 ,然后读取<strong>磁盘块3</strong>，以此类推最终在<strong>磁盘块8</strong>中找到了我们要查找的数据，磁盘IO次数为3也就是<strong>BTree</strong>的阶数。</p>
<p>下图是在网上找的一个4阶BTree的插入数据过程：</p>
<p><img src="https://i.loli.net/2020/10/10/gxtHuRP19fTrFV7.gif" alt=""></p>
<p><strong>BTree实现</strong></p>
<p>叶节点结构：</p>
<p>一个叶节点我们可以显式的定义为有<strong>键值</strong>，<strong>存储子节点地址的指针</strong>，<strong>数据</strong>。但是在内存当中它还有其他元素。</p>
<ul>
<li>键的大小</li>
<li>键的位置</li>
<li>值的大小</li>
<li>值的位置</li>
<li>数据大小</li>
<li>数据位置</li>
<li>子节点大小</li>
<li>整个节点的大小</li>
</ul>
<p>等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 叶节点主体的内存布局</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * LEAF_NODE_KEY_SIZE            键大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * LEAF_NODE_KEY_OFFSET          键的位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * LEAF_NODE_VALUE_SIZE          值的大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * LEAF_NODE_VALUE_OFFSET        值的位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * LEAF_NODE_CELL_SIZE           该字段数据大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * LEAF_NODE_SPACE_FOR_CELLS     整个叶节点的大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * LEAF_NODE_MAX_CELLS           该页/节点能存放多少数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * LEAF_NODE_RIGHT_SPLIT_COUNT   将整个节点一分为2，此为右半部分的数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * LEAF_NODE_LEFT_SPLIT_COUNT    此为左半部分的数据量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> LEAF_NODE_KEY_SIZE = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> LEAF_NODE_KEY_OFFSET = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> LEAF_NODE_VALUE_SIZE = ROW_SIZE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> LEAF_NODE_VALUE_OFFSET =</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> LEAF_NODE_MAX_CELLS =</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> LEAF_NODE_RIGHT_SPLIT_COUNT = (LEAF_NODE_MAX_CELLS + <span class="number">1</span>) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> LEAF_NODE_LEFT_SPLIT_COUNT = (LEAF_NODE_MAX_CELLS + <span class="number">1</span>) - LEAF_NODE_RIGHT_SPLIT_COUNT;</span></pre></td></tr></table></figure>



<p>这些都是我们在实现BTree部分时需要用到的<strong>常量</strong>。</p>
<p>先上一张BTree的插入数据逻辑图：</p>
<p><img src="https://i.loli.net/2020/10/18/PFnBvDeTSoGrlxX.png" alt=""></p>
<p><strong>判断是否已存在该数据</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">cursor</span>-&gt;cell_num &lt; num_cells) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">uint32_t</span> key_at_index = *leaf_node_key(node, <span class="built_in">cursor</span>-&gt;cell_num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (key_at_index == key_to_insert) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">return</span> EXECUTE_DUPLICATE_KEY;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>



<p><strong>插入数据到子节点中</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">创建一个新的节点， 插入新数据到对应的节点中然后更新父节点。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* old_node = get_page(<span class="built_in">cursor</span>-&gt;table-&gt;pager, <span class="built_in">cursor</span>-&gt;page_num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> old_max = get_node_max_key(old_node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> new_page_num = get_unused_page_num(<span class="built_in">cursor</span>-&gt;table-&gt;pager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* new_node = get_page(<span class="built_in">cursor</span>-&gt;table-&gt;pager, new_page_num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">initialize_leaf_node(new_node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">*node_parent(new_node) = *node_parent(old_node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">*leaf_node_next_leaf(new_node) = *leaf_node_next_leaf(old_node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">*leaf_node_next_leaf(old_node) = new_page_num;</span></pre></td></tr></table></figure>



<p>调整位置并存储到内存中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int32_t</span> i = LEAF_NODE_MAX_CELLS; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">void</span>* destination_node;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i &gt;= LEAF_NODE_LEFT_SPLIT_COUNT) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      destination_node = new_node;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      destination_node = old_node;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">uint32_t</span> index_within_node = i % LEAF_NODE_LEFT_SPLIT_COUNT;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">void</span>* destination = leaf_node_cell(destination_node, index_within_node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i == <span class="built_in">cursor</span>-&gt;cell_num) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      serialize_row(value, leaf_node_value(destination_node, index_within_node));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      *leaf_node_key(destination_node, index_within_node) = key;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="built_in">cursor</span>-&gt;cell_num) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">memcpy</span>(destination, leaf_node_cell(old_node, i - <span class="number">1</span>), LEAF_NODE_CELL_SIZE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">memcpy</span>(destination, leaf_node_cell(old_node, i), LEAF_NODE_CELL_SIZE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>



<p>如果需要存放到根节点而根节点将超出阈值则需要拆分根节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 创建新的根节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_new_root</span><span class="params">(Table*table, <span class="keyword">uint32_t</span> right_child_page_num)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">  * 分割旧的根节点，为旧节点创建新的page变为左子节点，剩余部分变为右子节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">  * 重新生成一个带有左右子树的新节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">  * </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">  */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span>* root = get_page(table-&gt;pager, table-&gt;root_page_num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span>* right_child = get_page(table-&gt;pager, right_child_page_num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint32_t</span> left_child_page_num = get_unused_page_num(table-&gt;pager);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span>* left_child = get_page(table-&gt;pager, left_child_page_num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*为旧节点创建新的page变为左子节点*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">memcpy</span>(left_child, root, PAGE_SIZE);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  set_node_root(left_child, <span class="literal">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">   * 初始化为内部节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">   */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  initialize_internal_node(root);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  set_node_root(root, <span class="literal">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  *internal_node_num_keys(root) = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  *internal_node_child(root, <span class="number">0</span>) = left_child_page_num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint32_t</span> left_child_max_key = get_node_max_key(left_child);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  *internal_node_key(root, <span class="number">0</span>) = left_child_max_key;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  *internal_node_right_child(root) = right_child_page_num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  *node_parent(left_child) = table-&gt;root_page_num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  *node_parent(right_child) = table-&gt;root_page_num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p>BTree的插入操作基础部分算是完成了，后序还会加入删除、更新部分。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《Inside Sqlite》</p>
<p>《sqlite database system: design and implementation》</p>
<p><a href="https://cstack.github.io/db_tutorial/" target="_blank" rel="noopener">Let’s Build a Simple Database</a></p>
<p><a href="https://nicky-chen.github.io/2018/11/17/btree-info/" target="_blank" rel="noopener">数据结构之BTree和B+Tree</a></p>
<p><a href="https://juejin.im/entry/6844903613915987975#b-%E6%A0%91-1" target="_blank" rel="noopener">重温数据结构：理解 B 树、B+ 树特点及使用场景</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37549063" target="_blank" rel="noopener">深入理解操作系统之——分页式存储管理</a></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>loannes</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/06/11/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">LRU缓存机制算法详解</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© loannes | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
