<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Python数据分析之Pandas-Series与DataFrame-</title><meta name="description"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">loannes's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Python数据分析之Pandas-Series与DataFrame-</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Series"><span class="toc-text">Series</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B4%A2%E5%BC%95"><span class="toc-text">自定义索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Series%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">Series索引的应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Series%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-text">Series的运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Series%E5%92%8CPython%E5%AD%97%E5%85%B8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">Series和Python字典的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataFrame"><span class="toc-text">DataFrame</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BADataFrame"><span class="toc-text">如何构建DataFrame</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96DataFrame%E4%B8%AD%E7%9A%84%E5%88%97"><span class="toc-text">如何获取DataFrame中的列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96DataFrame%E4%B8%AD%E7%9A%84%E6%9F%90%E8%A1%8C%E6%95%B0%E6%8D%AE"><span class="toc-text">如何获取DataFrame中的某行数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E5%88%97%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9"><span class="toc-text">对列进行修改</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DataFrame%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E6%8E%A5%E5%8F%97%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">DataFrame的构造函数能接受的所有数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Python数据分析之Pandas-Series与DataFrame-</h1><time class="has-text-grey" datetime="2019-04-22T01:51:00.000Z">2019-04-22</time><article class="mt-2 post-content"><p><img src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pandas"></p>
<blockquote>
<p>在pandas中接下来要经常用到的数据结构就是Series和DataFrame了。这两个对象为大多数数据处理提供了可靠、易于使用的功能</p>
</blockquote>
<h3 id="Series">Series</h3>
<p>Series是由一组数据以及这组数据所对应的数据标签（即索引）组成。</p>
<pre><code>In [66]: obj = Series([4, 7, -5, 3])

In [67]: obj
Out[67]:
0    4
1    7
2   -5
3    3
dtype: int64
</code></pre>
<p>其中左边的一列数字即为索引，索引默认是0到N-1的数字。</p>
<h5 id="自定义索引">自定义索引</h5>
<p>我们可以通过设置<strong>index</strong>属性来自定义索引的表现形式。</p>
<pre><code>In [68]: obj2 = Series([4, 7, -5, 3],index = ['d','b','a','c'])

In [69]: obj2
Out[69]:
d    4
b    7
a   -5
c    3
dtype: int64
</code></pre>
<h5 id="Series索引的应用">Series索引的应用</h5>
<pre><code>In [70]: obj2['a']
Out[70]: -5

In [71]: obj2['d'] = 6

In [72]: obj2
Out[72]:
d    6
b    7
a   -5
c    3
dtype: int64

In [74]: obj2[['a','b','c']]
Out[74]:
a   -5
b    7
c    3
dtype: int64

In [79]: obj2[['a','b','c']] = 1

In [80]: obj2
Out[80]:
d    6
b    1
a    1
c    1
dtype: int64
</code></pre>
<p>我们可以通过直接索引的方式来取出一个值或者一组值，也可以像NumPy一样可以对它们进行赋值。</p>
<h5 id="Series的运算">Series的运算</h5>
<pre><code>In [83]: obj2[obj2 &gt; 0]
Out[83]:
d    4
b    7
c    3
dtype: int64
</code></pre>
<pre><code>In [84]: obj2 * 2
Out[84]:
d     8
b    14
a   -10
c     6
dtype: int64
</code></pre>
<p>NumPy的运算函数也支持Series对象</p>
<pre><code>In [85]: np.exp(obj2)
Out[85]:
d      54.598150
b    1096.633158
a       0.006738
c      20.085537
dtype: float64
</code></pre>
<h5 id="Series和Python字典的关系">Series和Python字典的关系</h5>
<pre><code>In [88]: sdata = &#123;'Ohio': 35000, 'Texas':71000, 'Oregon':16000, 'Utah':5000&#125;

In [89]: obj3 = Series(sdata)

In [90]:
Out[90]:
Ohio      35000
Texas     71000
Oregon    16000
Utah       5000
dtype: int64
</code></pre>
<p>如果单单传入一个字典，那么最终得到的Series对象中的索引值就是字典的键值。</p>
<pre><code>In [91]: states = ['California', 'Ohio', 'Oregon','Texas']
In [92]: obj4 = Series(sdata, index=states)

In [93]: obj4
Out[93]:
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
</code></pre>
<p>在上面这个替换索引的例子中，sdata中的键值（索引）与states中相匹配的三个值会被找出来作了替换，但是<code>California</code>这个索引在sdata中不存在，所以它的结果为<code>NaN</code>。在pandas中，<code>NaN</code>表示缺失数据。</p>
<p>如果传入多个字典，那结果会和上面的例子截然相反</p>
<pre><code>In [94]: sdata2 = &#123;'Ohios': 35000, 'Texass':71000, 'Oregons':16000, 'Utahs':5000&#125;

In [95]: obj3 = Series([sdata,sdata2])

In [96]: obj3
Out[96]:
0    &#123;'Ohio': 35000, 'Texas': 71000, 'Oregon': 1600...
1    &#123;'Ohios': 35000, 'Texass': 71000, 'Oregons': 1...
dtype: object
</code></pre>
<p>它会得到一个以传入的字典为值，0到N-1为索引的Series对象。</p>
<h3 id="DataFrame">DataFrame</h3>
<blockquote>
<p>DataFrame是一个表格型数据，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，可以把它想象成<strong>Excel</strong>表。DataFrame中数据是以一个或者多个二维块存放的（而不是列表、字典或别的一堆数据结构）。</p>
</blockquote>
<h5 id="如何构建DataFrame">如何构建DataFrame</h5>
<p>直接传入一个等长列表或者NumPy数组组成的字典：</p>
<pre><code>In [103]: data = &#123;'state':['Ohio','Ohio','Ohio','Neveda','Neveda'],'year':[2000, 2001, 2002, 2001, 2002],
     ...: 'pop':[1.5, 1.7, 3.6, 2.4, 2.9]&#125;

In [104]: frame = DataFrame(data)

In [105]: frame
Out[105]:
    state  year  pop
0    Ohio  2000  1.5
1    Ohio  2001  1.7
2    Ohio  2002  3.6
3  Neveda  2001  2.4
4  Neveda  2002  2.9
</code></pre>
<p>同样DataFrame会自动加上索引，并且全部列会被有序排列。因为数据会打乱行索引，所以数据不会被自动排序。</p>
<p>如果不想排序列，那我们可以预先指定列的序列:</p>
<pre><code>In [106]: DataFrame(data, columns=['year','state','pop'])
Out[106]:
   year   state  pop
0  2000    Ohio  1.5
1  2001    Ohio  1.7
2  2002    Ohio  3.6
3  2001  Neveda  2.4
4  2002  Neveda  2.9
</code></pre>
<p>这样就可以按照我们指定的序列来排序所有的列。</p>
<h5 id="如何获取DataFrame中的列">如何获取DataFrame中的列</h5>
<p>可以通过属性（只读）的方式或者类似字典标记（读写）的方式获得：</p>
<pre><code>In [107]: frame = DataFrame(data, columns=['year','state','pop'])

In [108]: frame
Out[108]:
   year   state  pop
0  2000    Ohio  1.5
1  2001    Ohio  1.7
2  2002    Ohio  3.6
3  2001  Neveda  2.4
4  2002  Neveda  2.9

In [109]: frame.year
Out[109]:
0    2000
1    2001
2    2002
3    2001
4    2002
Name: year, dtype: int64
</code></pre>
<pre><code>In [110]: frame['year']
Out[110]:
0    2000
1    2001
2    2002
3    2001
4    2002
Name: year, dtype: int64
</code></pre>
<h5 id="如何获取DataFrame中的某行数据">如何获取DataFrame中的某行数据</h5>
<pre><code>frame.loc[0]
Out[111]:
year     2000
state    Ohio
pop       1.5
Name: 0, dtype: object
</code></pre>
<pre><code>In [114]: frame = DataFrame(data, columns=['year','state','pop'],index=['one','two','three','four','five'
     ...: ])

In [115]: frame.loc['two']
Out[115]:
year     2001
state    Ohio
pop       1.7
Name: two, dtype: object
</code></pre>
<p>可以通过DataFrame的<code>loc</code>函数来取出行数据。</p>
<h5 id="对列进行修改">对列进行修改</h5>
<p>上面有说到过DataFrame获取列的读写权限，属性的方法只能读，通过字典标记形式可以进行写入操作。</p>
<pre><code>In [122]: frame['num'] = 16

In [123]: frame
Out[123]:
       year   state  pop  num
one    2000    Ohio  1.5   16
two    2001    Ohio  1.7   16
three  2002    Ohio  3.6   16
four   2001  Neveda  2.4   16
five   2002  Neveda  2.9   16
</code></pre>
<pre><code>In [120]: frame.num = 16

In [121]: frame
Out[121]:
       year   state  pop
one    2000    Ohio  1.5
two    2001    Ohio  1.7
three  2002    Ohio  3.6
four   2001  Neveda  2.4
five   2002  Neveda  2.9
</code></pre>
<p>也可以将列表或者数组赋值给它，但是要注意它的长度是否相匹配。</p>
<pre><code>In [144]: frame['num'] = [5, 4, 3, 2, 1]

In [145]: frame
Out[145]:
       year   state  pop  num
one    2000    Ohio  1.5    5
two    2001    Ohio  1.7    4
three  2002    Ohio  3.6    3
four   2001  Neveda  2.4    2
five   2002  Neveda  2.9    1
</code></pre>
<p>如果将一个Series赋值给它，就会精确的匹配到DataFrame的索引。</p>
<pre><code>In [146]: val = Series([-1.2, -1.5, -1.7],index=['two','four','five'])

In [147]: frame['val'] = val

In [148]: frame
Out[148]:
       year   state  pop  num  val
one    2000    Ohio  1.5    5  NaN
two    2001    Ohio  1.7    4 -1.2
three  2002    Ohio  3.6    3  NaN
four   2001  Neveda  2.4    2 -1.5
five   2002  Neveda  2.9    1 -1.7
</code></pre>
<p>如果有空位，将会自动填上<code>NaN</code>值。在赋值过程中，如果将要赋值的列不存在，那它会自动创建一个新列。</p>
<h5 id="DataFrame的构造函数能接受的所有数据类型">DataFrame的构造函数能接受的所有数据类型</h5>
<ul>
<li><strong>二维ndarray</strong>   数据矩阵，还可以传入行标和列标</li>
<li><strong>由数组、列表或元组组成的字典</strong>  每个序列会变成DataFrame的一列。所有序列的长度必须相同。</li>
<li><strong>NumPy的结构化数组/记录数组</strong> 类似于“由数组组成的字典”</li>
<li><strong>由Series组成的字典</strong> 每个Series都会成为一列。如果没有指定行索引，则各Series的索引会被合并成结果的行索引。 每个Series的列索引就是在该字典中的键。</li>
<li><strong>由字典组成的字典</strong> 各内层字典会成为一列。键会被合并成结果的行索引，跟“由Series组成的字典”一样。</li>
<li><strong>字典或Series的列表</strong>  各项将会成为DataFrame的一行。字典键或Series索引的并集将会成为DataFrame的列标。</li>
<li><strong>由列标或元组组成的列表</strong>  类似于&quot;二维ndarray&quot;</li>
<li><strong>另一个DataFrame</strong> 该DataFrame的索引会被沿用，除非指定了其他索引。</li>
<li><strong>NumPy的MaskedArray</strong> 类似于&quot;二维ndarray&quot;的情况，只是掩码值在DataFrame会变成NA/缺失值。</li>
</ul>
<h3 id="总结">总结</h3>
<p>今天学习了Series和DataFrame的数据结构部分。了解了它们的构建方式<br>
Series的构建方式: <code>data = Series([1, 2, 3])</code> 或者通过传入一个字典来创建Series<br>
Series的常用功能：<br>
<strong>Series自定义索引名称</strong> 通过在构造函数中设置索引名称来达到自定义索引的目的<br>
<strong>Series索引的一些玩法</strong> 我们可以通过字典的形式<code>data['one']</code>来获得数据，也可以将其中的参数组成一个数组来获取多个数据<code>data[['one','two','three']]</code>。<br>
<strong>Series的运算</strong> Series可以像NumPy一样支持数学运算，并且它的运算方式也和NumPy一样数据批量运算。</p>
<p><strong>DataFrame的构建方式</strong>：直接传入一个等长列表或者NumPy数组组成的字典。<br>
<strong>如何获取DataFrame中的数据</strong>  由于<code>DataFrame</code>是个表格型数据，数据也有两种类型：<strong>行数据</strong> 和 <strong>列数据</strong>，以点属性的方式<code>frame.year</code>或者字典形式<code>frame['year']</code>都可以获得列数据。值得注意的是，点属性是获取的是带有只读属性的数据，而字典形式的则是带有读写形式的数据。如果想要修改数据还是得用字典形式来获取数据比较好。<br>
如果是想获取行数据，可以通过<code>loc</code>函数来获取。例如通过行索引名称<code>frame.loc['id']</code> 或者行索引序列号<code>frame.loc[0]</code> 来获取。<br>
<strong>DataFrame的赋值</strong>  可以通过字典形式赋值，但要注意与数据长度必须相匹配。也可以直接赋值一个Series对象过去，这样可以在赋值的同时把索引名称也一并带过去。</p>
<p>学了NumPy的基础之后发现学习pandas基础会相当轻松，除了多了一个表格型数据外，它的一些核心用法是差不多的，不管是赋值也好还是索引也罢，只要稍加注意一些如读写，区分行列数据的用法就基本掌握了这些知识点了。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/" title="Python数据分析之Pandas-Series与DataFrame基本功能（一）"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: Python数据分析之Pandas-Series与DataFrame基本功能（一）</span></a><a class="button is-default" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E6%95%B0%E7%BB%84%E8%BD%AC%E7%BD%AE%E4%B8%8E%E8%BD%B4%E5%AF%B9%E6%8D%A2%E8%AF%A6%E8%A7%A3/" title="Python数据分析之Numpy-数组转置与轴对换详解"><span class="has-text-weight-semibold">下一页: Python数据分析之Numpy-数组转置与轴对换详解</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="fuer4869/fuer4869.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fuer4869"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> loannes 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>