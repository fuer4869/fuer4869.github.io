
<!DOCTYPE html>
<html lang="zh-CN">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="loannes&#39;s blog">
    <title>Archiv: 2019 - loannes&#39;s blog</title>
    <meta name="author" content="loannes">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="loannes&#39;s blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;archives&#x2F;2019&#x2F;index.html">
<meta property="og:site_name" content="loannes&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="loannes">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/%20"
            aria-label=""
        >
            loannes&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/%20"
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Kategorien"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Kategorien</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archiv"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archiv</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Suche"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Suche</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="Über"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Über</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/" target="_blank" rel="noopener" title="Google Plus">
                    
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google Plus</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/profile/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/mailto"
                            title="E-Mail"
                        >
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">E-Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/16/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20/"
                            aria-label=": 算法图解笔记（三）\-\--快速排序"
                        >
                            算法图解笔记（三）\-\--快速排序
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-16T11:12:19+08:00">
	
		    16 11月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>===============================</p>
<h6 id="算法的核心思想—–分而治之（D-amp-C）"><a href="#算法的核心思想—–分而治之（D-amp-C）" class="headerlink" title="算法的核心思想—–分而治之（D&amp;C）"></a>算法的核心思想—–分而治之（D&amp;C）</h6><p>D&amp;C的理解过程：</p>
<ol>
<li>找出基线条件，这种条件必须尽可能简单。</li>
<li>不断将问题分解，直到符合基线条件。</li>
</ol>
<p>通过下面这道题来加深对D&amp;C的理解:<br><img src="./%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20_%20%E9%A3%9E%E5%A5%94%E7%9A%84%E8%9C%97%E7%89%9B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_files/M0JAOA.png" alt="图片"></p>
<p><strong>将这块长为1680m，宽640m的地均匀的分成方块，且分出的方块尽可能的大。</strong></p>
<p>按照D&amp;C的解题步骤：</p>
<ol>
<li>基线条件：<br>如果长是宽的整数倍，那么就可以正好将他们分割成等分的正方形。然后通过从大到小的顺序进行筛选优先找到的肯定是最大的正方形。</li>
</ol>
<p>按照题目中的理解就是：<em>只需找出1680余64之间的最大公约数即可。</em></p>
<ol start="2">
<li>递归条件：<br>通过欧几里得算法可以得知：’适用于这小块地的最大方块同样也适用于整块地的最大方块’。这句话正好符合了分而治之的核心思想。</li>
</ol>
<p><img src="./%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20_%20%E9%A3%9E%E5%A5%94%E7%9A%84%E8%9C%97%E7%89%9B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_files/M0wGgf.png" alt=""></p>
<p>先按照最大的值来分割正方形，以640作为最大正方形得出上面这张图。可以看到最右边的方块不是正方形，所以接下来对它进行相同的算法处理。</p>
<p>以此类推，最终得到了这样一张图：</p>
<p><img src="./%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20_%20%E9%A3%9E%E5%A5%94%E7%9A%84%E8%9C%97%E7%89%9B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_files/M00LlV.png" alt=""></p>
<p>所以最终的结果是80*80的方块。</p>
<h6 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h6><p>给定一个数字数组，以递归的方式计算出该数组的总和。<br>如：[2,4,6]</p>
<p>+———————————–+———————————–+<br>|     1                             |     def sum(arr):                 |<br>|     2                             |                                   |<br>|     3                             |    if len(arr) == 0:  // 基线条件 |<br>|     4                             |             return 0              |<br>|     5                             |       return                      |<br>|     6                             |  arr[0] + sum(arr[1:]) //递归条件 |<br>|                                   |                                   |<br>|                                   |     print(sum([2,3,4,5]))         |<br>+———————————–+———————————–+</p>
<h6 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h6><p>用递归的形式计算列表中包含的元素数:</p>
<p>+———————————–+———————————–+<br>|     1                             |     def count(list):              |<br>|     2                             |       if len(list) == 0:          |<br>|     3                             |             return 0              |<br>|     4                             |       return (list                |<br>|     5                             | [0] == list[0]) + count(list[1:]) |<br>|     6                             |                                   |<br>|                                   |     print(count([1,5,3,5]))       |<br>+———————————–+———————————–+</p>
<h6 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h6><p>用递归的形式找出列表中最大的数字</p>
<p>+———————————–+———————————–+<br>|     1                             |     def large(list):              |<br>|     2                             |         if list == []:return      |<br>|     3                             |       if len(list) == 1:          |<br>|     4                             |             return list[0]        |<br>|     5                             |         else:                     |<br>|     6                             |          ret                      |<br>|     7                             | urn max(list[0], large(list[1:])) |<br>|     8                             |                                   |<br>|                                   |     print(large([1,2,3,4,5]))     |<br>+———————————–+———————————–+</p>
<h6 id="例题5"><a href="#例题5" class="headerlink" title="例题5"></a>例题5</h6><p>找出二分查找算法的基线条件和递归条件<br>基线条件：数组长度等于1<br>递归条件：二分查找的核心，去掉数组一半，对另一半进行二分查找，直到满足基线条件。</p>
<hr>
<h3 id="D-amp-C算法之-—-快速排序"><a href="#D-amp-C算法之-—-快速排序" class="headerlink" title="D&amp;C算法之 — 快速排序"></a>D&amp;C算法之 — 快速排序</h3><ol>
<li>从数组中找到一个基准值（pivot），这个基准值可以是数组中的任何一个数值。</li>
<li>把小于基准值的放到一边，把大于基准值的放到另外一边。然后再对它们进行快速排序，直到满足基线条件位置。快速排序相当于是递归和二分查找的结合。</li>
<li>快速排序的递归条件其实就是二分查找，通过不停的分割最终合并n个数组从而形成一个排好序的新数组。</li>
</ol>
<p>+———————————–+———————————–+<br>|     1                             |     ## 快速排序                   |<br>|     2                             |     def quicksort(list):          |<br>|     3                             |         if len(list) &lt; 2:         |<br>|     4                             |           return list             |<br>|     5                             |        else:                      |<br>|     6                             |          pivot = list[0]          |<br>|     7                             |            less = [i              |<br>|     8                             |  for i in list[1:] if i &lt;= pivot] |<br>|     9                             |          greater = [              |<br>|     10                            | i for i in list[1:] if i &gt; pivot] |<br>|     11                            |            return quicksort(les   |<br>|     12                            | s) + [pivot] + quicksort(greater) |<br>|                                   |                                   |<br>|                                   |                                   |<br>|                                   |     prin                          |<br>|                                   | t(quicksort([1,3,2,6,5,9,0,7,4])) |<br>+———————————–+———————————–+</p>
<h4 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h4><p>二分查找：<br>$$O(log_2 n)$$</p>
<p>简单查找<br>$$O(n)$$</p>
<p>选择排序<br>$$O(n^2)$$</p>
<p>快速排序<br>$$O(nlogn)$$<br>最糟糕的情况下是<br>$$O(n^2)$$</p>
<p>旅行商问题算法<br>$$O(n!)$$</p>
<p>还有一种算法是合并排序，时间复杂度稳定在<br>$$O(nlogn)$$</p>
<h5 id="快速排序时间复杂度的由来"><a href="#快速排序时间复杂度的由来" class="headerlink" title="快速排序时间复杂度的由来"></a>快速排序时间复杂度的由来</h5><p>以数组[1,2,3,4,5,6,7,8]为例，我们取到的基数是4。这里的分割方式与二分查找相同，所以执行次数为<code>logn</code>。分割完成后对每个数组的再次遍历进行分割，也就是递归条件的时间复杂度为<code>O(n)</code>。所以快速排序的时间复杂度是<code>O(n) + logn</code>。<br>$$O(nlogn)$$</p>
<p>如果是在最糟糕的情况下，这个数组本身就是排好序的时候，那么它的时间复杂度就是<br>$$O(n^2)$$</p>
<h4 id="快速排序与合并排序的区别"><a href="#快速排序与合并排序的区别" class="headerlink" title="快速排序与合并排序的区别"></a>快速排序与合并排序的区别</h4><p>因为算法有时候会带有常量，在有常量的时候它们的运算时间就不一样了。<br>同样是时间复杂度为<code>nlogn</code><br>的快速排序和合并排序，在某些情况下它们的运行时间是不一样的。因为这中间n指的是执行次数，比如双方都执行了10000次，按照时间复杂度来看的话执行时间是差不多的，但是快速排序每次执行花了1毫秒，而合并排序花了10毫秒，那10000次下来时间差距就不是一点点了。</p>
<p>这里做个总结：快速排序在执行过程中也很快。</p>
<p>同样在有常量的时候，对快速排序和合并排序的运行时间也会有影响。如果出现快速查找的常量比合并查找的常量小，那么运行时间上也是快速查找占优。</p>
<h4 id="平均情况和最糟情况"><a href="#平均情况和最糟情况" class="headerlink" title="平均情况和最糟情况"></a>平均情况和最糟情况</h4><p>最糟情况指的是：比方说在快速排序的时候，取的基准值是第一个而且是整个数组中最小的一个，整个时候数组是不会被分成两半的。如果数组中第二是值是第二小的话，也会造成这种情况。这个时候就是最糟情况。</p>
<h5 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h5><p>用大O法表示：</p>
<ol>
<li>打印数组中每个元素的值：<br>O(n)</li>
<li>将数组中每个元素的值都乘以2：<br>O(n)</li>
<li>只将数组中第一个元素乘以2：<br>O(1)</li>
<li>根据数组包含的元素创建一个乘法表，如果数组为[2,3,7,8,10]。首先将每个元素都乘以2，再将每个元素都乘以3，然后将每个元素都乘以7以此类推。<br>$$O(n^2)$$</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>递归的核心是D&amp;C,基线条件一般都是空数组或者只包含一个元素的数组。</li>
<li>找到了基线条件后，执行递归条件让它通过递归的方式慢慢靠拢基线条件即可。</li>
<li>在使用快速排序的时候，为了避免最糟情况基准值最好随机的去找。</li>
<li>在列表数据很长的时候，简单查找和二分查找不管在任何情况下速度都没得比。</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/16/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/16/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20---%20%E9%80%92%E5%BD%92%20/"
                            aria-label=": 算法图解笔记（二） \-\-- 递归"
                        >
                            算法图解笔记（二） \-\-- 递归
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-16T11:12:19+08:00">
	
		    16 11月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=============================</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>每当调用函数时，计算机会将函数调用设计的所有变量存贮到内存中。</li>
<li>在函数内调用函数时，内部的函数在调用完成后会返回到上一次函数并且会被踢出栈堆。未完成的函数不会被踢出栈堆。</li>
<li>创建递归函数时刻要记得基线条件和递归条件</li>
</ul>
<p>一段关于栈的代码解读</p>
<p>+———————————–+———————————–+<br>|     1                             |     def fact(x):                  |<br>|     2                             |       if x==1:                    |<br>|     3                             |         return 1                  |<br>|     4                             |       else:                       |<br>|     5                             |         return x*fact(x-1)        |<br>+———————————–+———————————–+</p>
<p>代码解读：（以x=3为例）</p>
<ol>
<li>当x=3，程序进入了else条件并且执行递归，随后创建了x=2的内存块被将其放入栈堆中。</li>
<li>执行x=2的函数，因为此时x不等于1所以还是进入了else条件执行递归，随后创建了x=1的内存块并将其放入栈堆中。</li>
<li>此时x=1则进入第一个条件返回1，该轮函数执行完毕被踢出栈堆，同时上一层函数也因为该函数的结束而结束，被踢出栈堆，后面以此类推。</li>
<li>在此函数中，<code>x==1</code>为基线条件，它决定了什么时候跳出递归循环。而<code>else</code>为递归条件，它决定了递归中执行操作来慢慢接近基线条件。</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>递归有两种操作，压入和弹出</li>
<li>每个递归函数都有两个条件：基线条件和递归条件</li>
<li>所有的函数调用都将进入调用栈</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/16/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20---%20%E9%80%92%E5%BD%92%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/09/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%20/"
                            aria-label=": 大话数据结构第二章 算法"
                        >
                            大话数据结构第二章 算法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-09T11:12:19+08:00">
	
		    09 11月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=======================</p>
<h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p>算法表示决绝特定问题的求解步骤，由一个或多个操作组成。</p>
<h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><p>输入输出、有穷性、确定性、可行性。</p>
<p><strong>输入输出：</strong> 不一定有输入但必须有输出<br><strong>有穷性</strong> 造成死循环的代码不是算法<br><strong>确定性</strong> 算法的每一个步骤都有确定的含义，无需存在多余的步骤。<br><strong>可行性</strong> 算法的每一步都必须在计算机上运行</p>
<h4 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h4><p>公式:</p>
<p>+———————————–+———————————–+<br>|     1                             |     T(n) = O(f(n))                |<br>+———————————–+———————————–+</p>
<p>表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同。f（n）表示算法的工作量。</p>
<p>也就是说随着n的增大，T(n)增长最慢的算法为最优算法。</p>
<h4 id="推导大O阶"><a href="#推导大O阶" class="headerlink" title="推导大O阶"></a>推导大O阶</h4><ol>
<li>用常数1取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是1，则去除与整个项相乘的常数。</li>
</ol>
<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>+———————————–+———————————–+<br>|     1                             |     int sum = 0, n=100;           |<br>|     2                             |     sum = (1+n)*n/2;              |<br>|     3                             |     printf(“%d”,sum);             |<br>+———————————–+———————————–+</p>
<p>这里执行了3次，所以f(n)=3。<br>通过f(n)=3计算出大O阶：</p>
<ol>
<li><p>把常数项3改为1.<br>f(n) = 1。</p>
<p>由于没有最高阶项，所以时间复杂度为0(1)。</p>
<p>然后假设<code>sum=(1+n)*n/2</code>这条语句有10句：<br>那么f(n) = 12，最后推导的结果还是0(1)</p>
<p>类似这种执行时间恒定，时间复杂度为0(1)的又叫做<strong>常数阶</strong></p>
</li>
</ol>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>算法中带有循环结构部分的称为线性阶。它的时间复杂度呈线性增长。</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><p>+———————————–+———————————–+<br>|     1                             |     int count = 1;                |<br>|     2                             |     while(count &lt; n)              |<br>|     3                             |     {                             |<br>|     4                             |       count = count * 2;          |<br>|     5                             |     }                             |<br>+———————————–+———————————–+</p>
<p>它的时间复杂度与上例中的2有关，也与n有关。<br>此例中常数为2，我们可以得到</p>
<p>$$2^x = n$$</p>
<p>或者</p>
<p>$$x=log_2 n$$<br>所以对数阶的时间复杂度为O(logn)</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><p>+———————————–+———————————–+<br>|     1                             |     int i,j;                      |<br>|     2                             |     for (i = 0; i&lt;n; i++){        |<br>|     3                             |       for(j=0; j&lt;n;j++){          |<br>|     4                             |                                   |<br>|     5                             |      }}                           |<br>+———————————–+———————————–+</p>
<p>这是一个线性阶内嵌在另外一个线性阶中。<br>当i=0时，它执行了n此，当i=1时，执行了n-1次 ……<br>当i=n-1时，执行了1次。<br>总的执行次数为:<br>n + (n-1) + (n-2) … +1 =</p>
<p>$$\frac{n(n+1)}{2}$$</p>
<p>=</p>
<p>$$\frac {n^2} 2 + \frac n 2$$</p>
<p>以最终推导的公式：</p>
<p>$$\frac {n^2} 2 + \frac n 2$$</p>
<p>来计算<br>按照第二步 去除加号中的常数：</p>
<p>$$\frac n 2$$</p>
<p>保留最高阶：</p>
<p>$$\frac {n^2} 2$$</p>
<p>然后按照第三步去除相乘的常数，也就是去除1/2。最终得到的时间复杂度为：<br>$$O(n^2)$$</p>
<p>常用的时间复杂度<br>|执行次数函数|阶|非正式术语|<br>|—|—|—|<br>|12|O(1)|常数阶|<br>|2n+3|O(n)|线性阶|<br>|3n^2+2n+1|O(n^2)|平方阶|<br>|5log2n+20|O(logn)|对数阶|<br>|2n+3nlog2n+19|O(nlogn)|nlogn阶|<br>|6n^3+2n^2+3n+4|O(n^3)|立方阶|<br>|2^n|O(2^n)|指数阶|</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/09/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/09/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0(%E4%B8%80)---%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"
                            aria-label=": 算法图解笔记(一) \-\-- 选择排序、二分查找"
                        >
                            算法图解笔记(一) \-\-- 选择排序、二分查找
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-09T11:12:19+08:00">
	
		    09 11月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=========================================</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>是一个在有序元素列表中的查找的算法<br>原理：如这个列表长度是10000，通过算法排除不满足条件的另一半来查找。</p>
<p>比如从100个数字中找到某个数字的索引，可以先找到50进行比较来缩小范围。如果大于50就再拿75做比较，以此类推，直到找到该数字。</p>
<p>这样的二分算法能从原先的暴力查找（最坏情况下）100次减少到7次。</p>
<p>记做公式：<br>$$log_2 n$$</p>
<h3 id="算法运行时间"><a href="#算法运行时间" class="headerlink" title="算法运行时间"></a>算法运行时间</h3><p>运行时间的增速:随着数据量的增加，运行时间会出现递增的情况。优秀的算法增速越少，比如二分查找和简单查找在10亿个算法的情况下，简单查找需要11天才能查找玩，而二分查找只需要32毫秒。</p>
<p>算法的速度指的的操作数的增速。也就是时间复杂度</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>缺点：添加新元素如果遇到内存空间被占用，需要额外申请空间，效率会降低。频繁插入和删除操作不适合数组。</p>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>优点：每个元素都存储着下一个元素的地址，如果是有序的读取那读取速度将快于数组。适合大批量列表</p>
<p>如果是有序读取，插入操作频繁的话是链表占优<br>如果是无序读取，插入操作比较少的话是数组占优</p>
<p>数组：<br>读取：O(1)<br>插入：O(n)<br>删除：O(n)</p>
<p>链表：<br>读取：O(n)<br>插入：O(1)<br>删除：O(1)</p>
<h4 id="选择排序例题"><a href="#选择排序例题" class="headerlink" title="选择排序例题"></a>选择排序例题</h4><p>对一个数组进行从小到大排列<br>思路就是遍历整个数组，将每个数字与其他数字进行比较。选择排序的优化在于第一轮被拿出来做比较确定为最小的数字将会被踢出数组，不会参与到下一轮的比较。</p>
<p>+———————————–+———————————–+<br>|     1                             |     def smallest(list):           |<br>|     2                             |       small_value = list[0]       |<br>|     3                             |      small_index = 0              |<br>|     4                             |                                   |<br>|     5                             |      for i in range(1,len(list)): |<br>|     6                             |                                   |<br>|     7                             |         if list[i] &lt; small_value: |<br>|     8                             |                                   |<br>|     9                             |             small_value = list[i] |<br>|     10                            |              small_index = i      |<br>|     11                            |        return small_index         |<br>|     12                            |                                   |<br>|     13                            |     # 选择排序                    |<br>|     14                            |     def select_sort(list):        |<br>|     15                            |       newlist = []                |<br>|     16                            |       for i in range(len(list)):  |<br>|                                   |                                   |<br>|                                   |            small = smallest(list) |<br>|                                   |                                   |<br>|                                   |   newlist.append(list.pop(small)) |<br>|                                   |        return newlist             |<br>+———————————–+———————————–+</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>需要存储多个元素时可以考虑使用数组或者链表，时刻记得他们之间的优缺点。</li>
<li>数组的读取速度很快</li>
<li>链表的插入和删除速度很快</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/09/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0(%E4%B8%80)---%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/08/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20/"
                            aria-label=": 大话数据结构第一章 数据结构"
                        >
                            大话数据结构第一章 数据结构
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-08T11:12:19+08:00">
	
		    08 11月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>===========================</p>
<p>所有能够被计算机程序处理和可以输入到计算机中的都可以作为数据。不单单只有数值、数值类型，MP3,图片等都是数据。</p>
<h4 id="数据元素与数据项的区别"><a href="#数据元素与数据项的区别" class="headerlink" title="数据元素与数据项的区别"></a>数据元素与数据项的区别</h4><p>数据元素是由数据项组成的单位，如某公司中的一名程序员就是数据元素。<br>而数据项则是由数据元素拆分而成的最小单位，这名程序员的姓名，年龄就是数据项了。</p>
<h4 id="数据对象-简称为数据"><a href="#数据对象-简称为数据" class="headerlink" title="数据对象(简称为数据)"></a>数据对象(简称为数据)</h4><p>数据对象就是性质相同的数据元素的集合。某个数据元素是程序员A，程序员A、程序员B、程序员C统称为程序员，这个程序员就是数据对象。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>是相互之间存在一种或多种特定关系的数据元素的集合。<br>比方说：N名iOS程序员 + N名Android程序员 +<br>N名后端程序员可以组成移动开发小组。<br>N名Unity程序员 + N名后端开发可以组成游戏开发小组。</p>
<h3 id="数据结构有哪些？"><a href="#数据结构有哪些？" class="headerlink" title="数据结构有哪些？"></a>数据结构有哪些？</h3><p>逻辑结构<br>集合结构、线性结构、树形结构、图形结构。<br>线性结构——是一个有序数据元素的集合。如1、2、3、4、5、6、7、8、9<br>树型结构——<br>顾名思义，数据呈现成树形结构。像公司成员结构就是树形结构。<br>图形结构—— 最乱的一种结构，呈现为多对多的结构形式。</p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>数据的逻辑结构在计算机中的存储形式。相当于是把私房钱是叠起来放在花瓶里还是揉成一团放在花瓶里。</p>
<ul>
<li>顺序存储结构 类似于数组，而且是个不可变的数组。适用于查询</li>
<li>链式存储结构：把数据元素存放在任意位置。如银行，医院等排队系统，频繁插入，更新的需要链式结构。</li>
</ul>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>原子类型：整型、字符型等不可再分解的都是原子类型<br>结构类型：如字典、数组</p>
<p>抽象数据类型<br>它可能是一个数据模型、可以是一个viewmodel。针对不同的业务或者功能所创造的数据类型。也可以称之为自定义数据类型</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/08/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/10/22/leetcode%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"
                            aria-label=": leetcode第一周刷题总结"
                        >
                            leetcode第一周刷题总结
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-10-22T11:12:19+08:00">
	
		    22 10月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>======================</p>
<h3 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h3><p>=========================================================================================================================</p>
<p>在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。</p>
<p>「黑皇后」在棋盘上的位置分布用整数坐标数组 queens<br>表示，「白国王」的坐标用数组 king 表示。</p>
<p>「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。</p>
<p>请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。</p>
<p><img src="./leetcode%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%20_%20%E9%A3%9E%E5%A5%94%E7%9A%84%E8%9C%97%E7%89%9B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_files/untitled-diagram.jpg" alt=""></p>
<ul>
<li><p>输入：queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]],<br>king = [0,0]</p>
</li>
<li><p>输出：[[0,1],[1,0],[3,3]]</p>
</li>
</ul>
<p><strong>解释：</strong></p>
<ul>
<li>[0,1] 的皇后可以攻击到国王，因为他们在同一行上。</li>
<li>[1,0] 的皇后可以攻击到国王，因为他们在同一列上。</li>
<li>[3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。</li>
<li>[0,4] 的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。</li>
<li>[4,0] 的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。</li>
<li>[2,4] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。</li>
</ul>
<p><strong>提示</strong></p>
<ul>
<li>1 &lt;= queens.length &lt;= 63</li>
<li>queens[0].length == 2</li>
<li>0 &lt;= queens[i][j] &lt; 8</li>
<li>king.length == 2</li>
<li>0 &lt;= king[0], king[1] &lt; 8</li>
<li>一个棋盘格上最多只能放置一枚棋子。</li>
</ul>
<h4 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h4><p>从解释和提示中我们可以得到两条重要的线索：</p>
<ul>
<li>king的取值范围：0 &lt;= x &lt; 8</li>
<li>皇后只能走一个方向，不能绕路走。要么走横线，要么走竖线，要么走对角线。</li>
<li>只需找到离king最近的能攻击到king的皇后</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>无需考虑king在棋盘的什么位置，直接以king为中心进行八方向探索，直到找到最近的皇后。我们可以创建一个含有八个不同方向的坐标，如（1，0）就是往右一格一格进行搜索。</p>
<p>(一开始浪费时间在考虑king的位置上了，后来一想直接限定king的探索范围就好了)</p>
<p>+———————————–+———————————–+<br>|     1                             |     class Solution:               |<br>|     2                             |         def queensAttacktheKing(s |<br>|     3                             | elf, queens: List[List[int]], kin |<br>|     4                             | g: List[int]) -&gt; List[List[int]]: |<br>|     5                             |                                   |<br>|     6                             |           # 上    右上   右    右 |<br>|     7                             | 下    下    左下    左     左上   |<br>|     8                             |             d                     |<br>|     9                             | irection = [[-1,0],[-1,1],[0,1],[ |<br>|     10                            | 1,1],[1,0],[1,-1],[0,-1],[-1,-1]] |<br>|     11                            |             q                     |<br>|     12                            | ueens = {(x,y) for x,y in queens} |<br>|     13                            |             res = []              |<br>|     14                            |             # 八方向查找          |<br>|     15                            |             for a,b in direction: |<br>|     16                            |                 # 找到皇后后，x,  |<br>|     17                            | y回到初始位置继续往另外个方向探索 |<br>|     18                            |                 x = king[0]       |<br>|     19                            |                 y = king[1]       |<br>|                                   |                                   |<br>|                                   |  while 0 &lt;= x &lt; 8 and 0 &lt;= y &lt; 8: |<br>|                                   |                     x += a        |<br>|                                   |                     y += b        |<br>|                                   |                     # 这里本      |<br>|                                   | 身是想对queens做for循环遍历来做比 |<br>|                                   | 对的，因为这里本身已经在for循环中 |<br>|                                   | 了，会造成多余的操作。后来借鉴了  |<br>|                                   | 别人的代码，把queens改为字典了。  |<br>|                                   |                                   |<br>|                                   |                if(x,y) in queens: |<br>|                                   |                                   |<br>|                                   |                 res.append([x,y]) |<br>|                                   |                         break     |<br>|                                   |             return res            |<br>+———————————–+———————————–+</p>
<p>+———————————–+———————————–+<br>|     1                             |     执行用时 :                    |<br>|     2                             |     48 ms                         |<br>|     3                             |     内存消耗 :                    |<br>|     4                             |     14 MB                         |<br>+———————————–+———————————–+</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>解题思路基本上有了，但是花了很多时间在处理for循环上始终找不到最优的方式去匹配坐标。学到了可以通过字典的形式来做匹配，既方便还不用再创建个循环。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/10/22/leetcode%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/02/03/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%20/"
                            aria-label=": iOS内存管理那些事"
                        >
                            iOS内存管理那些事
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-02-03T11:12:19+08:00">
	
		    03 2月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=================</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>今天在网上看到一道蛮有趣的问题，内容是”对于已经会使用ARC的iOS开发者来说还有必要学习手动内存管理吗？”<br>。换做一年前的我可能会觉得那必须不用学啊，手动管理内存管理太麻烦了而且很容易出错。ARC现在用下来完全能够解决我日常开发中的所有内存管理的问题，而且苹果在WWDC2011上已经强烈推荐开发者使用ARC，为什么不用ARC呢?</p>
<p>直到我有一次使用了第三方组件，当时这个组件是不支持ARC的。有一天在我做新功能的时候突然出现了一个没有任何踪迹的崩溃，经过了1个通宵的排查和网友的帮助最后才得知原来是非ARC和ARC的代码混用出现的问题，后来还是自己重新写了个非ARC的功能才解决了这个问题。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><hr>
<p>每当一个对象被创建的时候它的引用计数为1，为保证对象的存在不造成悬挂指针的情况出现，每当创建引用到对象需要为其的引用计数加1。否则如果其中一个引用被释放的时候因为对象的引用计数被清零，但是对象没有被彻底释放而造成崩溃。</p>
<blockquote>
<p>管理引用计数的目的就是在确保程序运行正常的情况下，能够合理的管理引用计数的递增或者递减。</p>
</blockquote>
<p>管理引用计数有一下3个消息：</p>
<ul>
<li>retain 对象的引用计数加1</li>
<li>release 对象的引用计数减1</li>
<li>autorelease 将对象放入自动释放池中</li>
</ul>
<h4 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h4><p>retain一般用在对象被创建或者引用被赋值的情况下</p>
<pre><code>NSArray * array = [[NSArray array] retain];</code></pre><p>这里创建了一个<code>array</code>的数组，它的引用计数为1。</p>
<pre><code>self.data = array;</code></pre><p><code>array</code> 的引用被赋值给了<code>self.data</code>。</p>
<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>当某个对象不再使用的时候，可以给对象发送<code>release</code>消息。这个时候该对象的引用计数就会减1,如果引用计数为0的时候，在dealloc函数被调用的之后会释放内存。</p>
<p>也就是说如果给对象发送release消息不一定会马上销毁该对象，有可能它还有其他对象引用着。</p>
<h4 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h4><p>有时候可能会遇到一些release不能解决的问题，如在一个函数中返回一个对象，这个时候必须给该对象发送autorelease消息,把对象放入<code>autoreleasepool</code>（自动释放池）中，当runloop执行自动释放池的时候，会从池中的对象列表中一一释放。</p>
<h3 id="assign-copy-retain之间的区别"><a href="#assign-copy-retain之间的区别" class="headerlink" title="assign,copy,retain之间的区别"></a>assign,copy,retain之间的区别</h3><p>在使用成员变量时，会给property传入上面三种参数，不同情况不同用法。</p>
<h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><p>assign<br>相当于是unsafe_unretained,它不会为变量做引用计数。所以一般都是用在基础数据类型上，如int<br>float等。这种类型的变量会由系统自动释放，程序员不用管理。</p>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>copy 会对旧对象另外分配内存给新对象，新对象引用计数加1，就对象不变。</p>
<pre><code>self.data = [array copy];</code></pre><p>这种情况下，<code>self.data</code> 和 <code>array</code><br>虽然是相同的，引用计数也都是1，但是它们不存在同一块内存中，也就是说即使<code>array</code>被释放了，<code>self.data</code>也不会受到任何影响。</p>
<h4 id="retain-1"><a href="#retain-1" class="headerlink" title="retain"></a>retain</h4><p>retain则是会对对象做引用计数，只有在引用计数为0的时候，执行dealloc才会释放对象。</p>
<h3 id="强变量"><a href="#强变量" class="headerlink" title="强变量"></a>强变量</h3><p>首先我们得知道所有的对象的指针都是强变量，也就是说当你把一个对象赋值给一个强变量的时候，强变量会引用到这个对象，旧对象则在赋值前会被释放，强变量会自动保持。不管是实例变量还是全局变量都是这么回事。<br>有一点需要注意，成员变量默认不是strong，其默认是assign。也就是说他默认不会被自动保持。</p>
<h3 id="弱变量"><a href="#弱变量" class="headerlink" title="弱变量"></a>弱变量</h3><p>弱变量的存在主要是为了解决循环保持（retain<br>cycle）的问题。也就是说当两个对象互相存在彼此的强引用时，比如说对象A中有一个强变量B，对象B有个强变量A，这样就会造成循环保持。当其中一个对象需要销毁的时候因为另外一个对象引用着它而造成无法销毁。解决这个问题可以通过在2个对象之间建立一个弱引用的方法。可以在父对象中声明一个强变量子对象，在子对象中声明一个弱变量父对象，这样就不会造成循环保持，因为弱变量不能阻止引用的对象被销毁，在这里就是子对象无法阻止父对象被销毁。而且这个时候子对象会被设置为nil，所以即使无意中给它发送了消息也不会造成奔溃现象。</p>
<h3 id="内存管理的规则总结"><a href="#内存管理的规则总结" class="headerlink" title="内存管理的规则总结"></a>内存管理的规则总结</h3><ul>
<li>一个对象执行了retain消息之后，它的引用计数会加1，这样它就不会被销毁，直到执行release消息之后。也就是说当对象的引用计数为0的时候，对象才会被销毁，然后系统会发送dealloc消息来释放内存。</li>
<li>如果想让一个对象在release之后不被销毁，只要让它的引用计数不为0就行了或者多执行一次retain。</li>
<li>所有发送过autorelease的对象都会被放入自动释放池中，当自动释放池执行至末尾时，会对池中的所有对象发送release消息。</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/02/03/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">Seite 1 von 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 loannes. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">loannes</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
