<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>loannes's blog</title><meta name="description"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/widget-post-list.css"><meta name="generator" content="Hexo 5.3.0"></head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">loannes's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><span>归档 · 2019</span></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><article class="post-container is-flex is-justify-content-center section container is-max-widescreen pt-4 px-2"><div class="columns is-variable is-1-tablet is-3-desktop-only is-2-widescreen is-full-width"><section class="column"><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://lc-gold-cdn.xitu.io/7f95b14ea69db63d2a0c.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"><img class="post-cover-img js-img-fadeIn" src="https://lc-gold-cdn.xitu.io/7f95b14ea69db63d2a0c.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">算法图解之广度优先搜索</a></h2><time class="has-text-grey" datetime="2019-12-25T15:58:35.000Z">2019-12-25</time><p class="is-flex-grow-2 mt-2">
简介
广度优先搜索算法（Breathed First Search）是一种搜索算法。原理就是从树的根节点开始去遍历所有节点，从而找出最短路径。
使用范围

可以用来走迷宫，在游戏领域中可以用来做自动寻路功能
可以用来编写跳棋AI，计算多少步能获胜
也可以用来根据自己的人际关系网络查找到关系最近的医生

图
图由节点和边组成。一个节点可能与众多节点直接相连
图用于模拟不同的东西是如何相连的。

类似这样模拟了欠债关系的就是图
在遇到能用广度优先搜索算法解决问题时，我们可以先借助图来建立问题模型，然后再通过算法去解决问题。
图只是用来模拟问题模型，并不是最终答案
树形结构也是一种图，与其他图不同的是它不会往后指。

也就是说遇到问题后，我们可以通过图把问题的关键点放在节点上。用散列表把这些点按照图的结构存储起..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://upload-images.jianshu.io/upload_images/1515206-fb17f181361f40ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/%E3%80%90MySQL%E3%80%91%E6%B5%85%E8%B0%88MySQL%E7%9A%84LOAD-DATA/"><img class="post-cover-img js-img-fadeIn" src="https://upload-images.jianshu.io/upload_images/1515206-fb17f181361f40ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/%E3%80%90MySQL%E3%80%91%E6%B5%85%E8%B0%88MySQL%E7%9A%84LOAD-DATA/">【MySQL】浅谈MySQL的LOAD DATA</a></h2><time class="has-text-grey" datetime="2019-12-25T04:51:20.000Z">2019-12-25</time><p class="is-flex-grow-2 mt-2">
前言好久没碰MySQL了，这次碰巧在研究superset的时候需要将一份csv格式的数据文件导入到数据库中。正好借此机会可以重温下MySQL。
数据来源 网盘密码 : g5xa
开发环境

Mac OS 10.13
MySQL 8.0

准备工作在开始之前需要对源数据做一次清洗：

去除”，“等影响数据导入的符号
去除第一行索引值，因为它不是数据
如果需要咋数据库中加上id，那么为了对应在源数据中也要加上，excel中加上id还是很方便的。
把数据转为utf-8格式的csv文件


在这之前先简单阅读下官方文档：MySQL Documentation
可以很方便的找到LOAD DATA的表达式：
LOAD DATA
    [LOW_PRIORITY | CONCURRENT] [LOCAL]
    I..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/%E3%80%90MySQL%E3%80%91%E6%B5%85%E8%B0%88MySQL%E7%9A%84LOAD-DATA/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8"><i class="tag post-item-tag">触发器</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/">【MySQL必知必会】使用触发器</a></h2><time class="has-text-grey" datetime="2019-12-20T03:01:53.000Z">2019-12-20</time><p class="is-flex-grow-2 mt-2">
触发器
当某个表发生更改时需要MySQL自动处理事件就是触发器。MySQL只会响应以下语句从而自动执行一条MySQL语句:

DELETE
INSERT
UPDATE

创建触发器
创建触发器时，需要注意一些细节：

唯一的触发器名
触发器关联的表
触发器应该响应的活动(DELETE,INSERT,UPDATE)
触发器何时执行(处理之前或之后)


在MySQL5中同一数据库中的两个表可以用同一个名字，但是同一个表中的触发器名字必须唯一。但是在DBMS数据库中触发器名只能唯一。

可以用CREATE TRIGGER语句创建触发器。
CREATE TRIGGER test_tt AFTER DELETE ON `test`  FOR EACH ROW
BEGIN
DECLARE s VARCHAR(20)..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E6%B8%B8%E6%A0%87"><i class="tag post-item-tag">游标</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/">【MySQL必知必会】使用游标</a></h2><time class="has-text-grey" datetime="2019-12-19T12:42:25.000Z">2019-12-19</time><p class="is-flex-grow-2 mt-2">
游标
由于MySQL检索返回的是一组成为结果集的行，可能是零行也可能是多行，但是之前学到的并没有能一行一行处理的方式。而有时候需要需要在检索出来的行中前进、后退一行或多行，这个时候需要使用游标。
游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览过更改。

游标在MySQL中只能用于存储过程或者函数

使用游标的流程

在能够使用游标前，必须声明它。为了定义要使用的SELECT语句。
声明游标后需要打开游标。这个过程用SELECT语句把数据实际检索出来。
对于填有数据的游标，根据需要检索出各行。
结束游标需要关闭它

打开和关闭游标
打开：OPEN CURSOR
关闭: CLOSE CURSOR
CURSOR指的是先前定义的游标名
如一个完整的打开关闭过程：
CREATE PROCED..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><i class="tag post-item-tag">存储过程</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">【MySQL必知必会】使用存储过程</a></h2><time class="has-text-grey" datetime="2019-12-18T09:28:28.000Z">2019-12-18</time><p class="is-flex-grow-2 mt-2">
存储过程
存储过程简单来说就是为以后的使用而保存的一条或多条MySQL语句集合。这里可以理解为在实际项目中，可能会遇到不同逻辑的MySQL，这个时候需要把这些语句集合起来，相当于是一个文件。
为什么使用存储过程

通过把处理封装在容易使用的单元中，简化复杂的操作。
由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。
简化对变动的管理。如果表名、列名或业务逻辑有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。
提高性能。因为使用存储过程比使用比使用单独的SQL语句要快。
存在一些只能用在单个请求中的MySQL元素和特性..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E8%A7%86%E5%9B%BE"><i class="tag post-item-tag">视图</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/">【MySQL必知必会】使用视图</a></h2><time class="has-text-grey" datetime="2019-12-15T10:13:47.000Z">2019-12-15</time><p class="is-flex-grow-2 mt-2">
视图
以例子来说明：
SELECT salaries.emp_no, dept_emp.dept_no, salary, dept_name FROM salaries, dept_emp, departments WHERE salaries.emp_no = dept_emp.emp_no AND dept_emp.dept_no = departments.dept_no AND salary = 158220;

从三张表中获取薪水为158220的员工的id，部门id，薪水和部门名称。
如果使用视图，这段语句就会变成：
SELECT salaries.emp_no, dept_emp.dept_no, salary, dept_name FROM salary_for_department WHE..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://upload.wikimedia.org/wikipedia/en/thumb/6/62/MySQL.svg/1200px-MySQL.svg.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"><img class="post-cover-img js-img-fadeIn" src="https://upload.wikimedia.org/wikipedia/en/thumb/6/62/MySQL.svg/1200px-MySQL.svg.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL,%E7%AC%94%E8%AE%B0"><i class="tag post-item-tag">MySQL,笔记</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/">【MySQL必知必会】插入数据</a></h2><time class="has-text-grey" datetime="2019-12-13T15:28:00.000Z">2019-12-13</time><p class="is-flex-grow-2 mt-2">
</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2"><i class="tag post-item-tag">全文本搜索</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/">【MySQL必知必会】全文本搜索</a></h2><time class="has-text-grey" datetime="2019-12-12T11:26:44.000Z">2019-12-12</time><p class="is-flex-grow-2 mt-2">
理解全文本搜索
之前学习到了用LIKE关键字，利用通配符来匹配文本，还有通过正则表达式来匹配文本。不过这些匹配都有些缺点：

性能：通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行。如果搜索行越长匹配就越耗时。
明确控制：通配符和正则表达式很难做到精细的控制，控制在匹配过程中哪些需要匹配哪些需要不匹配，这样会影响性能无法做到优化。
智能化结果：基于通配符和正则表达式的匹配得到的结果你无法控制匹配数量，比方说匹配的关键词是#，在匹配的全文中有多个#,但是我无法控制结果中只返回一个或者n个。
而这些限制都能通过全文本搜索来解决。

使用全文本搜索
一般在建表时启用全文本搜索。
MySQL最常用的两个引擎为MyISAM和InnoDB
MyISAM：支持全文索引
InnoDB：不支持全文索引
CREAT..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><i class="tag post-item-tag">组合查询</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/">【MySQL必知必会】组合查询</a></h2><time class="has-text-grey" datetime="2019-12-11T08:01:55.000Z">2019-12-11</time><p class="is-flex-grow-2 mt-2">
组合查询的使用场景

在单个查询中从不同的表返回类似结构的数据
对单个表执行多个查询，按单个查询返回数据

创建组合查询
可以通过UNION操作符来组合多条SQL查询
查询emp_no为10010以及薪水大于150000的员工
SELECT emp_no,salary FROM salaries WHERE salary &amp;gt; 150000 UNION SELECT emp_no, salary FROM salaries WHERE emp_no = 10010;

输出：
+--------+--------+
| emp_no | salary |
+--------+--------+
|  43624 | 151115 |
|  43624 | 153166 |
|  43624 | 153..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93"><i class="tag post-item-tag">高级联结</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/">【MySQL必知必会】创建高级联结</a></h2><time class="has-text-grey" datetime="2019-12-10T09:06:45.000Z">2019-12-10</time><p class="is-flex-grow-2 mt-2">
使用不同类型的联结上次学到的是等值联结，也是最简单的联结。这次要学习其它三种联结：自联结，自然联结和外部联结。
自联结id为10031的员工薪水漏发了，需要确认下这个部门的所有员工，利用自联结的方法找出该部门所有员工的emp_no。
方案一： 子查询
SELECT emp_no FROM dept_emp WHERE dept_no = (SELECT dept_no FROM dept_emp WHERE emp_no = &amp;#39;10031&amp;#39;) LIMIT 10

输出:
+--------+
| emp_no |
+--------+
|  10001 |
|  10006 |
|  10008 |
|  10012 |
|  10014 |
|  10018 |
|  10021 |
|..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E5%AD%90%E6%9F%A5%E8%AF%A2"><i class="tag post-item-tag">子查询</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/">【MySQL必知必会】使用子查询</a></h2><time class="has-text-grey" datetime="2019-12-09T12:58:07.000Z">2019-12-09</time><p class="is-flex-grow-2 mt-2">
利用子查询进行过滤
简单来说将就是利用一条SELECT语句的返回结果用于另一条WHERE语句的WHERE子句
比方说查询薪水高于150000的员工全名。这里需要查询2张表，先分开写看下
SELECT emp_no,salary FROM salaries WHERE salary &amp;gt; 150000;

输出：
+--------+--------+
| emp_no | salary |
+--------+--------+
|  43624 | 151115 |
|  43624 | 153166 |
|  43624 | 153458 |
|  43624 | 157821 |
|  43624 | 158220 |
|  46439 | 150345 |
|  47978 | 151929 ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E8%81%94%E7%BB%93%E8%A1%A8/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E8%81%94%E7%BB%93"><i class="tag post-item-tag">联结</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E8%81%94%E7%BB%93%E8%A1%A8/">【MySQL必知必会】联结表</a></h2><time class="has-text-grey" datetime="2019-12-09T04:14:03.000Z">2019-12-09</time><p class="is-flex-grow-2 mt-2">
关系表
什么是关系表，假设有一个学生表，其中包含了学生姓名，出生年月，主键id, 班级id（外键)。
同时还有另外一个表，是一个班级表，其中包含主键id，班级名称。
这样的两个表就形成了关系表，学生表可以通过外键（班级id）查询到该学员的班级名称。这样的关系表也可称为一对多关系表。
外键
外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。
这样做的好处：

班级信息不重复，从而不浪费查询的时间和空间。
如果班级信息有变动，直接更新班级表即可，学生表的数据不用改动
因为数据无重复，处理起来也会更加方便

为什么要使用联结
分解数据为多个表能更有效的存储，更方便的处理，并且具有更大的可伸缩性。
但是由于数据存储在多个表中，又不想使用多重子查询这种不易阅读的写法，那可以用联结。
简单来说：
..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E8%81%94%E7%BB%93%E8%A1%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/">【MySQL必知必会】分组数据</a></h2><time class="has-text-grey" datetime="2019-12-08T08:08:17.000Z">2019-12-08</time><p class="is-flex-grow-2 mt-2">
创建分组
SELECT emp_no, COUNT(*) FROM salaries GROUP BY emp_no HAVING emp_no &amp;lt; 10020;

输出:
+--------+----------+
| emp_no | COUNT(*) |
+--------+----------+
|  10001 |       17 |
|  10002 |        6 |
|  10003 |        7 |
|  10004 |       16 |
|  10005 |       13 |
|  10006 |       12 |
|  10007 |       14 |
|  10008 |        3 |
|  10009 |       18 |
|  ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E6%B1%87%E6%80%BB"><i class="tag post-item-tag">汇总</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/">【MySQL必知必会】汇总数据</a></h2><time class="has-text-grey" datetime="2019-12-07T01:47:26.000Z">2019-12-07</time><p class="is-flex-grow-2 mt-2">
汇总数据
简单来说就是对数据表的检索。观察它的最大值，最小值等
SQL聚集函数



函数
说明




AVG()
返回某列的平均值


COUNT()
返回某列的行数


MAX( )
返回某列的最大值


MIN()
返回某列的最小值


SUM()
返回某列之和



AVG函数
AVG()函数可用来返回所有列的平均值，也可返回单个列的平均值。
SELECT AVG(salary) AS avg_salary FROM salaries;

输出：
+------------+
| avg_salary |
+------------+
| 63810.7448 |
+------------+
1 row in set (0.75 sec)

COUNT函数
两种使用方式：

使用COUNT(*..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/">【MySQL必知必会】创建计算字段</a></h2><time class="has-text-grey" datetime="2019-12-06T09:27:33.000Z">2019-12-06</time><p class="is-flex-grow-2 mt-2">
计算字段
某些数据需要通过数据库中的其他字段结合，计算，转换等才能使用。这个时候就需要用到计算字段功能了。
其实这种处理客户端和服务端都能完成，但是服务端处理这种事情更快，一般都是由服务端来解决这种事情。
拼接字段
使用Concat()函数来拼接
mysql&amp;gt; SELECT Concat(last_name, first_name)
    -&amp;gt; FROM employees
    -&amp;gt; ORDER BY last_name;

输出：

发现打印结果末尾有很多空格，可以使用MySQL的RTrim()函数来删除值右侧多余的空格。
mysql&amp;gt; SELECT Concat(RTrim(last_name), RTrim(emp_no)) AS name_no FROM employ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><i class="tag post-item-tag">正则表达式</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">【MySQL必知必会】正则表达式</a></h2><time class="has-text-grey" datetime="2019-12-05T14:09:10.000Z">2019-12-05</time><p class="is-flex-grow-2 mt-2">
正则表达式介绍
正则表达式可用于查找文件，可以在文本块中找到重复的单词。解析URL,处理复杂文本等。
正则表达式与MySQL的关系
通过正则对文本串进行比较来替换LIKE。
见下面例子
基本字符匹配
从first_name这个列中找出所有包含’oo’的行
SELECT first_name FROM employees WHERE first_name REGEXP 'oo';


该代码等同于
SELECT first_name FROM employees WHERE first_name LIKE '%oo%';


目前看下来正则在字符长度比较短的情况下，执行效率比通配符来得低。
看下面的例子：
在salaries表中，查找salary列里匹配.0000。这个.表示匹配任意一个字符，这个是通配符%..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/EwftXpN7Skn12dT.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/">【MySQL必知必会】使用数据处理函数</a></h2><time class="has-text-grey" datetime="2019-12-05T11:05:59.000Z">2019-12-05</time><p class="is-flex-grow-2 mt-2">
函数
函数提供了对数据转换和处理的功能
上篇文章中的RTrim() 以及处理时间的TIMESTAMPDIFF()都是函数。
因为函数是当前数据库使用的引擎特有，所以如果遇到移植到其他数据库就可能会出现不支持这些函数的情况。
PS:在开发中要注意这种情况，避免在移植后出现不必要的麻烦。如果必须使用函数，写好相关注释
使用函数
大多数SQL支持以下几种类型的函数：

用于处理文本串（如删除，填充，转换大小写）
对数值进行算数操作（如返回绝对值，进行代数运算）
用于处理日期
返回DMBS使用的特殊信息（如用户登录信息，版本细节）

文本处理函数
上篇了解了RTrim是去除右边空格，LTrim是去除左边空格
接下来学习个新函数-Upper()，将文本转换成大写
mysql&amp;gt; SELECT first_nam..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%91%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://image.fundebug.com/2019-03-27-data_structure.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%93%88%E5%B8%8C%E8%A1%A8/"><img class="post-cover-img js-img-fadeIn" src="https://image.fundebug.com/2019-03-27-data_structure.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/hashmap"><i class="tag post-item-tag">hashmap</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%93%88%E5%B8%8C%E8%A1%A8/">算法图解笔记（四）---哈希表</a></h2><time class="has-text-grey" datetime="2019-11-16T06:56:26.000Z">2019-11-16</time><p class="is-flex-grow-2 mt-2">
哈希表
哈希表又称为散列表，是一种key-value表结构。由哈希函数和数组组成，它的原理是通过哈希函数将传入的key值计算出索引，最后从数组中通过索引快速获取数据。
哈希表结构图

一般情况下它的时间复杂度为O(1)，相比较于有序列表，它的时间复杂度为O(logn)。
哈希表与列表最大的区别在于哈希表需要通过哈希函数中的算法来将key值换算成列表的索引，并且同一个key只能指向与同一个索引，也就是说一旦某个key换算成了一个索引后任何其他key都无法换算成该索引。如果出现重复的索引就称之为哈希碰撞。

在常用的语言中，哈希表通常以字典（dict）的形式表现。
哈希函数
构造哈希函数有多种方式，比如直接寻址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法。
由于哈希函数有可能会出现不同的输入值会输..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%93%88%E5%B8%8C%E8%A1%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://image.fundebug.com/2019-03-27-data_structure.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20/"><img class="post-cover-img js-img-fadeIn" src="https://image.fundebug.com/2019-03-27-data_structure.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%8E%92%E5%BA%8F"><i class="tag post-item-tag">排序</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20/">算法图解笔记（三）\-\--快速排序</a></h2><time class="has-text-grey" datetime="2019-11-16T03:12:19.000Z">2019-11-16</time><p class="is-flex-grow-2 mt-2">===============================

算法的核心思想-----分而治之（D&amp;amp;C）
D&amp;amp;C的理解过程：

找出基线条件，这种条件必须尽可能简单。
不断将问题分解，直到符合基线条件。

通过下面这道题来加深对D&amp;amp;C的理解:

将这块长为1680m，宽640m的地均匀的分成方块，且分出的方块尽可能的大。
按照D&amp;amp;C的解题步骤：

基线条件：
如果长是宽的整数倍，那么就可以正好将他们分割成等分的正方形。然后通过从大到小的顺序进行筛选优先找到的肯定是最大的正方形。

按照题目中的理解就是：只需找出1680余64之间的最大公约数即可。

递归条件：
通过欧几里得算法可以得知：‘适用于这小块地的最大方块同样也适用于整块地的最大方块’。这句话正好符合了分而治之的核..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://image.fundebug.com/2019-03-27-data_structure.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20---%20%E9%80%92%E5%BD%92%20/"><img class="post-cover-img js-img-fadeIn" src="https://image.fundebug.com/2019-03-27-data_structure.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E9%80%92%E5%BD%92"><i class="tag post-item-tag">递归</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20---%20%E9%80%92%E5%BD%92%20/">算法图解笔记（二） \-\-- 递归</a></h2><time class="has-text-grey" datetime="2019-11-16T03:12:19.000Z">2019-11-16</time><p class="is-flex-grow-2 mt-2">=============================

栈

每当调用函数时，计算机会将函数调用设计的所有变量存贮到内存中。
在函数内调用函数时，内部的函数在调用完成后会返回到上一次函数并且会被踢出栈堆。未完成的函数不会被踢出栈堆。
创建递归函数时刻要记得基线条件和递归条件

一段关于栈的代码解读
def fact(x):
  if x==1: return 1
  else: return x*fact(x-1)     

代码解读：（以x=3为例）

当x=3，程序进入了else条件并且执行递归，随后创建了x=2的内存块被将其放入栈堆中。
执行x=2的函数，因为此时x不等于1所以还是进入了else条件执行递归，随后创建了x=1的内存块并将其放入栈堆中。
此时x=1则进入第一个条件返回1，该轮函数..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20---%20%E9%80%92%E5%BD%92%20/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><i class="tag post-item-tag">数据结构</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%20/">大话数据结构第二章 算法</a></h2><time class="has-text-grey" datetime="2019-11-09T03:12:19.000Z">2019-11-09</time><p class="is-flex-grow-2 mt-2">=======================
什么是算法
算法表示决绝特定问题的求解步骤，由一个或多个操作组成。
算法的特性
输入输出、有穷性、确定性、可行性。
输入输出： 不一定有输入但必须有输出
有穷性 造成死循环的代码不是算法
确定性 算法的每一个步骤都有确定的含义，无需存在多余的步骤。
可行性 算法的每一步都必须在计算机上运行
算法的时间复杂度
公式:
±----------------------------------±----------------------------------+
|     1                             |     T(n) = O(f(n))                |
±----------------------------..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%20/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://image.fundebug.com/2019-03-27-data_structure.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0(%E4%B8%80)---%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><img class="post-cover-img js-img-fadeIn" src="https://image.fundebug.com/2019-03-27-data_structure.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%8E%92%E5%BA%8F"><i class="tag post-item-tag">排序</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0(%E4%B8%80)---%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">算法图解笔记(一) \-\-- 选择排序、二分查找</a></h2><time class="has-text-grey" datetime="2019-11-09T03:12:19.000Z">2019-11-09</time><p class="is-flex-grow-2 mt-2">=========================================

二分查找是一个在有序元素列表中的查找的算法原理：如这个列表长度是10000，通过算法排除不满足条件的另一半来查找。
比如从100个数字中找到某个数字的索引，可以先找到50进行比较来缩小范围。如果大于50就再拿75做比较，以此类推，直到找到该数字。
这样的二分算法能从原先的暴力查找（最坏情况下）100次减少到7次。
记做公式：$$log_2 n$$
算法运行时间运行时间的增速:随着数据量的增加，运行时间会出现递增的情况。优秀的算法增速越少，比如二分查找和简单查找在10亿个算法的情况下，简单查找需要11天才能查找玩，而二分查找只需要32毫秒。
算法的速度指的的操作数的增速。也就是时间复杂度
数组缺点：添加新元素如果遇到内存空间..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0(%E4%B8%80)---%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><i class="tag post-item-tag">数据结构</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20/">大话数据结构第一章 数据结构</a></h2><time class="has-text-grey" datetime="2019-11-08T03:12:19.000Z">2019-11-08</time><p class="is-flex-grow-2 mt-2">===========================
所有能够被计算机程序处理和可以输入到计算机中的都可以作为数据。不单单只有数值、数值类型，MP3,图片等都是数据。
数据元素与数据项的区别
数据元素是由数据项组成的单位，如某公司中的一名程序员就是数据元素。
而数据项则是由数据元素拆分而成的最小单位，这名程序员的姓名，年龄就是数据项了。
数据对象(简称为数据)
数据对象就是性质相同的数据元素的集合。某个数据元素是程序员A，程序员A、程序员B、程序员C统称为程序员，这个程序员就是数据对象。
数据结构
是相互之间存在一种或多种特定关系的数据元素的集合。
比方说：N名iOS程序员 + N名Android程序员 +
N名后端程序员可以组成移动开发小组。
N名Unity程序员 + N名后端开发可以组成游戏开发小组。..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%8E%92%E5%BA%8F"><i class="tag post-item-tag">排序</i></a><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E6%95%B0%E7%BB%84"><i class="tag post-item-tag">数组</i></a><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88"><i class="tag post-item-tag">双指针</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/">leetcode刷题笔记（三）</a></h2><time class="has-text-grey" datetime="2019-10-24T05:22:19.000Z">2019-10-24</time><p class="is-flex-grow-2 mt-2"></p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E6%95%B0%E7%BB%84"><i class="tag post-item-tag">数组</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">leetcode刷题笔记（二）</a></h2><time class="has-text-grey" datetime="2019-10-23T10:50:29.000Z">2019-10-23</time><p class="is-flex-grow-2 mt-2"></p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">leetcode刷题笔记(一)</a></h2><time class="has-text-grey" datetime="2019-10-22T03:12:19.000Z">2019-10-22</time><p class="is-flex-grow-2 mt-2">======================
</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://s2.ax1x.com/2020/02/10/14mGCR.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91TCP-IP-%E9%93%BE%E8%B7%AF%E5%B1%82/"><img class="post-cover-img js-img-fadeIn" src="https://s2.ax1x.com/2020/02/10/14mGCR.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/TCP/IP"><i class="tag post-item-tag">TCP/IP</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91TCP-IP-%E9%93%BE%E8%B7%AF%E5%B1%82/">【笔记】TCP/IP---链路层</a></h2><time class="has-text-grey" datetime="2019-08-05T15:37:49.000Z">2019-08-05</time><p class="is-flex-grow-2 mt-2">以太网是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD（载波监听多路访问及冲突检测）技术，并以10M/S的速率（仅指标准以太网的速率而已）运行在多种类型的电缆上。以太网与IEEE802.3系列标准相类似
数据封装上一篇笔记有讲到过封装，数据封装过程是由应用程序开始发送数据,经过传输层和网络层并被封装最后到数据链路层封装后转换成比特流。
封装格式最常用的封装格式为RFC 894（以太网的封装格式）。下图是RFC 894与另外一种封装格式RFC 1042（IEEE802.2/802.3)的区别
目的地址：也就是网卡的硬件地址，6个字节，指明帧的接受者
源M地址：网卡的硬件地址，6个字节，指明帧的发送者
长度：2个字节，指明该帧数据字段的长度，但不代表数据字段长度能够达到（2^16）字节
类..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91TCP-IP-%E9%93%BE%E8%B7%AF%E5%B1%82/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://s2.ax1x.com/2020/02/08/1WpWsx.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91TCP-IP-IP%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE/"><img class="post-cover-img js-img-fadeIn" src="https://s2.ax1x.com/2020/02/08/1WpWsx.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/TCP/IP"><i class="tag post-item-tag">TCP/IP</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91TCP-IP-IP%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE/">【笔记】TCP/IP---IP:网际协议</a></h2><time class="has-text-grey" datetime="2019-08-03T08:55:46.000Z">2019-08-03</time><p class="is-flex-grow-2 mt-2">简介IP是TCP/IP协议族中最核心的协议。所有的TCP、UDP、ICMP和IGMP数据都以IP数据报格式传输。IP也决定了接收到的数据将被分发到哪个网络进程。
IP地址IP地址（Internet Protocol Address），缩写为IP Adress，是一种在Internet上的给主机统一编址的地址格式，也称为网络协议（IP协议）地址。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，常见的IP地址，分为IPv4与IPv6两大类，当前广泛应用的是IPv4，目前IPv4几乎耗尽IPv6号称可以为世界上每一粒沙子都编上地址；如无特别注明，一般讲的的IP地址所指的是IPv4。
MAC地址MAC（Media Access Control，介质访问控制）地址，或称为物理地址，也叫硬件地址，用来定义网络设备..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91TCP-IP-IP%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://s2.ax1x.com/2020/01/21/1FTA7d.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91TCP-IP-%E7%AE%80%E4%BB%8B/"><img class="post-cover-img js-img-fadeIn" src="https://s2.ax1x.com/2020/01/21/1FTA7d.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/TCP/IP"><i class="tag post-item-tag">TCP/IP</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91TCP-IP-%E7%AE%80%E4%BB%8B/">【笔记】TCP/IP---简介 </a></h2><time class="has-text-grey" datetime="2019-08-01T05:56:40.000Z">2019-08-01</time><p class="is-flex-grow-2 mt-2">分层网络协议通常分为不同的层次进行开发，每一层分别负责不同分通信功能。
TCP/IP协议族分为四层

链路层：与硬件相关，通常用来处理计算机中的网卡，设备驱动等。
####运输层：有两个不同的传输协议— TCP(传输控制协议) 和 UDP（用户数据报协议）。平时开发中与数据库交互的接口用到的就是运输层
####网络层：处理分组在网络中的活动。IP协议，ICMP协议都是网络层。IP协议不可靠，传输不稳定，不一定能接收到而且可能是无序的。
####应用层：任何TCP/IP都会实现这些应用程序，相当于是捆绑在TCP/IP上的程序

Telnet远程登录
FTP文件传输协议
SMTP简单邮件传输协议
SNMP简单网络管理协议

一个局域网内有两台主机，都运行ftp协议。其中涉及到哪些网络层？
图中是一个FTP客户端..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/notes/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91TCP-IP-%E7%AE%80%E4%BB%8B/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://upload-images.jianshu.io/upload_images/1515206-2c1987b74ec20905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E7%88%AC%E8%99%AB%E4%B9%8BScrapy-%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"><img class="post-cover-img js-img-fadeIn" src="https://upload-images.jianshu.io/upload_images/1515206-2c1987b74ec20905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Scrapy"><i class="tag post-item-tag">Python, Scrapy</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E7%88%AC%E8%99%AB%E4%B9%8BScrapy-%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/">Python爬虫之Scrapy-框架原理</a></h2><time class="has-text-grey" datetime="2019-06-08T08:39:12.000Z">2019-06-08</time><p class="is-flex-grow-2 mt-2">
Scrapy介绍scrapy框架包含以下几个部分

Scrapy Engine 引擎
Spiders 爬虫
Scheduler 调度器
Downloader 下载器
Item Pipeline 项目管道
Downloader Middlewares 下载器中间件
Spider Middlewares 爬虫中间件

框架中有那么多部分组成，那每个部件都是用来做什么的？查阅官方文档后我有了以下结论
Scrapy Engine引擎
它是负责整个框架中信号，数据等传递功能。相当于是军队中的主公，任何事情必须经过它的手由它来决定这件事情由谁来负责。
Spiders爬虫
是这个框架中的军师，负责处理所有的Response，返回封装在Item中的数据包。如果有更深层的URL，它将返回给Scrapy Engine，再次调..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E7%88%AC%E8%99%AB%E4%B9%8BScrapy-%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://upload-images.jianshu.io/upload_images/1515206-2c1987b74ec20905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E7%88%AC%E8%99%AB%E4%B9%8BScrapy-%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/"><img class="post-cover-img js-img-fadeIn" src="https://upload-images.jianshu.io/upload_images/1515206-2c1987b74ec20905.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Scrapy"><i class="tag post-item-tag">Python, Scrapy</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E7%88%AC%E8%99%AB%E4%B9%8BScrapy-%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/">Python爬虫之Scrapy-安装及入门</a></h2><time class="has-text-grey" datetime="2019-06-05T08:04:56.000Z">2019-06-05</time><p class="is-flex-grow-2 mt-2">
简介Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。
###环境需求Python2.7 或者Python3.5以上
安装在安装前需要确定当前的Python是什么版本，否则会出现环境变量与当前版本不匹配的情况导致找不到文件：command not found
pip install scrapy
如果安装太慢，就把镜像源改为国内：pip install -i  https://pypi.douban.com/simple scrapy 
安装过程中你会发现，scrapy有大量的依赖库：

twisted  基于事件驱动和异步的网络框架
lxml python的一个解析库，支持HTML和XML的解析，支持XPath解析方式，..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E7%88%AC%E8%99%AB%E4%B9%8BScrapy-%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-a1494e91afa95562.vZulrZXNvoKvLfOgbqka3AHaE8&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-matplotlib%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-a1494e91afa95562.vZulrZXNvoKvLfOgbqka3AHaE8&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-matplotlib%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/">Python数据分析之Pandas-matplotlib基础功能（二）</a></h2><time class="has-text-grey" datetime="2019-05-27T10:53:30.000Z">2019-05-27</time><p class="is-flex-grow-2 mt-2">
使用pandas和seaborn绘图Series和DataFrame自带的生成图表方法：
import pandas as pd
s = pd.Series(np.random.randn(10).cumsum(), index=np.arange(0, 100, 10))
s.plot()


使用pandas做一张堆积柱状图展示每天各种聚会规模的数据点的百分比
tips = pd.read_csv(&amp;#39;examples/tips.csv&amp;#39;)
party_counts = pd.crosstab(tips[&amp;#39;day&amp;#39;], tips[&amp;#39;size&amp;#39;])
print(party_counts)

size  1   2   3   4  5  6
day     ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-matplotlib%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-a1494e91afa95562.vZulrZXNvoKvLfOgbqka3AHaE8&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-matplotlib%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-a1494e91afa95562.vZulrZXNvoKvLfOgbqka3AHaE8&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-matplotlib%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/">Python数据分析之Pandas-matplotlib基础功能（一）</a></h2><time class="has-text-grey" datetime="2019-05-23T12:27:00.000Z">2019-05-23</time><p class="is-flex-grow-2 mt-2">
matplot API入门如何引入：
import matplotlib.pyplot as plt

一个简单的例子：
import numpy as np

data = np.arange(10)
plt.plot(data)

print(data)
[0 1 2 3 4 5 6 7 8 9]

效果如下：
Figure和Subplotmatplot的图像都位于Fugure对象中，相当于一个画板，如何创建Figure对象。
fig = plt.figure()
ax1 = fig.add_subplot(2, 2, 1)
ax2 = fig.add_subplot(2, 2, 2)
ax3 = fig.add_subplot(2, 2, 3)

想要实现绘图，必须先使用add_subplot方法来..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-matplotlib%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-214ebdbf1561743b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0-%E3%80%902018%E4%B8%96%E7%95%8C%E6%9D%AF%E3%80%91%E7%94%A8Python%E5%88%86%E6%9E%90%E5%A4%BA%E5%86%A0%E7%90%83%E9%98%9F/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-214ebdbf1561743b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0-%E3%80%902018%E4%B8%96%E7%95%8C%E6%9D%AF%E3%80%91%E7%94%A8Python%E5%88%86%E6%9E%90%E5%A4%BA%E5%86%A0%E7%90%83%E9%98%9F/">实战项目练习-【2018世界杯】用Python分析夺冠球队</a></h2><time class="has-text-grey" datetime="2019-05-20T11:22:24.000Z">2019-05-20</time><p class="is-flex-grow-2 mt-2">
前言在网上找到了个用Python分析2018世界杯夺冠热门的项目，感觉很有意思准备拿来练练手。因为目前还没有学到图形可视化部分，所以这部分内容会完全借鉴网上的教程。
分析目的通过数据分析找出哪些队伍是这次世界杯的夺冠热门球队
开发环境
Python 3.7
SublimeText2

初步分析数据情况import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pandas import DataFrame,Series


df = pd.read_csv(&amp;#39;results.csv&amp;#39;)
print(df.head())

由于sublimetext上打印数据显示不全，所以打印数据放在ipython中..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0-%E3%80%902018%E4%B8%96%E7%95%8C%E6%9D%AF%E3%80%91%E7%94%A8Python%E5%88%86%E6%9E%90%E5%A4%BA%E5%86%A0%E7%90%83%E9%98%9F/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0-%E9%93%BE%E5%AE%B6%E4%BA%8C%E6%89%8B%E6%88%BF%E6%95%B0%E6%8D%AE%EF%BC%88%E6%B8%85%E6%B4%97%E4%B8%8E%E5%90%88%E5%B9%B6%EF%BC%89/">实战项目练习-链家二手房数据（清洗与合并）</a></h2><time class="has-text-grey" datetime="2019-05-11T08:09:00.000Z">2019-05-11</time><p class="is-flex-grow-2 mt-2">前言
现在已经学到了数据规整与合并这一章，为了加深对数据分析的理解接下来需要做个小项目练习一下。
目的

通过项目能够真实的了解到数据分析是做什么的
加深对pandas的熟悉程度
重新梳理一下目前学到的那些基础知识，查缺补漏

前期准备
此次项目准备对2018年北京链家网的二手房数据做一次分析
数据来源：Python数据科学的公众号
工具：暂时还是使用iTerm2，还未找到更合适的开发工具。Sublime Text2目前也在用，这次项目小不打算用这个。
导入数据文件并进行初步观察
这些观察包括了解数据特征的缺失值，异常值，以及大概的描述性统计。
In [10]: lianjia_df = pd.read_csv('lianjia/lianjia.csv')

# 先查看前5行数据
In [11]: lian..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0-%E9%93%BE%E5%AE%B6%E4%BA%8C%E6%89%8B%E6%88%BF%E6%95%B0%E6%8D%AE%EF%BC%88%E6%B8%85%E6%B4%97%E4%B8%8E%E5%90%88%E5%B9%B6%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-83f7589908b21260.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%B8%85%E7%90%86/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-83f7589908b21260.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%B8%85%E7%90%86/">Python数据分析之Pandas-过滤与清理</a></h2><time class="has-text-grey" datetime="2019-05-10T08:06:27.000Z">2019-05-10</time><p class="is-flex-grow-2 mt-2">
移除重复数据DataFrame中常常会出现重复行。如下面这个例子：
In [295]: data = DataFrame(&amp;#123;&amp;#39;k1&amp;#39;:[&amp;#39;one&amp;#39;]*3 + [&amp;#39;two&amp;#39;] * 4, &amp;#39;k2&amp;#39;:[1,1,2,3,3,4,4]&amp;#125;)
In [296]: data
Out[296]:
    k1  k2
0  one   1
1  one   1
2  one   2
3  two   3
4  two   3
5  two   4
6  two   4

DataFrame的duplicated方法返回一个布尔型Series，表示各行是否是重复行：
In [297]: data.duplicated()
Out[297]:
..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E8%BF%87%E6%BB%A4%E4%B8%8E%E6%B8%85%E7%90%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-83f7589908b21260.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E9%87%8D%E5%A1%91/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-83f7589908b21260.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E9%87%8D%E5%A1%91/">Python数据分析之Pandas-重塑</a></h2><time class="has-text-grey" datetime="2019-05-08T07:04:53.000Z">2019-05-08</time><p class="is-flex-grow-2 mt-2">
重塑层次化索引层次化索引为DataFrame数据的重排任务提供了一种良好一致性的方式。主要功能：

stack: 将数据的列”旋转“为行
unstack：将数据的行“旋转”为列

接下来看一个行列索引均为字符串的例子：
In [169]: data = DataFrame(np.arange(6).reshape((2,3)),index=pd.Index([&amp;#39;Ohio&amp;#39;,&amp;#39;Colorado&amp;#39;],name=&amp;#39;sta
     ...: te&amp;#39;),columns=pd.Index([&amp;#39;one&amp;#39;,&amp;#39;two&amp;#39;,&amp;#39;three&amp;#39;],name=&amp;#39;number&amp;#39;))

In [170]: data
Out[1..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E9%87%8D%E5%A1%91/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-fb41334e461576fa.wEY-WvPTUqSoBowdG85S5gHaEH&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E8%81%9A%E5%90%88%E4%B8%8E%E5%90%88%E5%B9%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-fb41334e461576fa.wEY-WvPTUqSoBowdG85S5gHaEH&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E8%81%9A%E5%90%88%E4%B8%8E%E5%90%88%E5%B9%B6%EF%BC%88%E4%BA%8C%EF%BC%89/">Python数据分析之Pandas-聚合与合并（二）</a></h2><time class="has-text-grey" datetime="2019-05-07T08:02:57.000Z">2019-05-07</time><p class="is-flex-grow-2 mt-2">
索引上的合并**比如DataFrame中连接键位于其索引中的情况，传入left_index=True或right_index=True以说明索引应该被用作连接键：
In [62]: left1 = DataFrame(&amp;#123;&amp;#39;key&amp;#39;:[&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;],&amp;#39;value&amp;#39;:range(6)&amp;#125;)

In [63]: right1 = DataFrame(&amp;#123;&amp;#39;group_val&amp;#39;:[3.5, 7]&amp;#125;, index=[&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;])

In [64]: left1
Ou..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E8%81%9A%E5%90%88%E4%B8%8E%E5%90%88%E5%B9%B6%EF%BC%88%E4%BA%8C%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-fb41334e461576fa.wEY-WvPTUqSoBowdG85S5gHaEH&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E8%81%9A%E5%90%88%E4%B8%8E%E5%90%88%E5%B9%B6%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-fb41334e461576fa.wEY-WvPTUqSoBowdG85S5gHaEH&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E8%81%9A%E5%90%88%E4%B8%8E%E5%90%88%E5%B9%B6%EF%BC%88%E4%B8%80%EF%BC%89/">Python数据分析之Pandas-聚合与合并（一）</a></h2><time class="has-text-grey" datetime="2019-05-06T11:54:37.000Z">2019-05-06</time><p class="is-flex-grow-2 mt-2">
层次化索引层次化索引让你能在一个轴上拥有多个索引级别。层次化索引我个人理解是对索引进行了分组，比方说一部分数据是今年的，一部分数据是明年的，可通过层次化索引进行切块以方便后续选取数据
In [263]: data = Series(np.random.randn(10), index=[[&amp;#39;2010&amp;#39;,&amp;#39;2010&amp;#39;,&amp;#39;2010&amp;#39;,&amp;#39;2011&amp;#39;,&amp;#39;2011&amp;#39;,&amp;#39;2011&amp;#39;,&amp;#39;2012&amp;#39;,&amp;#39;2012&amp;#39;,&amp;#39;2013&amp;#39;,&amp;#39;2013&amp;#39;],[
     ...: 1, 2, 3, 1, 2, 3, 1, 2, 2, 3]])  # 这种形式叫做带有```Mul..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E8%81%9A%E5%90%88%E4%B8%8E%E5%90%88%E5%B9%B6%EF%BC%88%E4%B8%80%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-f73f163bba63465c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-f73f163bba63465c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86/">Python数据分析之Pandas-数据清理</a></h2><time class="has-text-grey" datetime="2019-05-05T07:33:19.000Z">2019-05-05</time><p class="is-flex-grow-2 mt-2">
合并数据集离散化和面元划分为了方便分析，连续数据常常被离散化或拆分为“面元”，可以看下面的例子：
ages = [20,22,25,27,21,23,37,31,61,55,29]

可以看到上面这组表示年龄的数据非常的杂乱无序，接下来需要用到cat函数来对它们进行分割
In [90]: bins = [18, 25, 35, 60, 100]

In [91]: cats  = pd.cut(ages, bins)
ca
In [92]: cats
Out[92]:
[(18, 25], (18, 25], (18, 25], (25, 35], (18, 25], ..., (35, 60], (25, 35], (60, 100], (35, 60], (25, 35]]
Length: 11
Ca..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-0a0bffaaf9ee20fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-0a0bffaaf9ee20fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">Python数据分析之Pandas-数据文件加载与存储（二）</a></h2><time class="has-text-grey" datetime="2019-04-30T10:30:25.000Z">2019-04-30</time><p class="is-flex-grow-2 mt-2">
读取Microsoft  Excel文件Excel作为最典型的表格型数据，我们需要用到ExcelFile对象，首先需要下载安装xlrd和openpyxl包
In [11]: xls_file = pd.ExcelFile(&amp;#39;ex1.xlsx&amp;#39;)

In [12]: table = xls_file.parse(&amp;#39;Sheet1&amp;#39;)

In [13]: table
Out[13]:
   Unnamed: 0  a   b   c   d message
0           0  1   2   3   4   hello
1           1  5   6   7   8   world
2           2  9  10  11  12     foo

用..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-0a0bffaaf9ee20fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-0a0bffaaf9ee20fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas,%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><i class="tag post-item-tag">Python, Pandas, 数据存储</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%EF%BC%88%E4%B8%80%EF%BC%89/">Python数据分析之Pandas-数据文件加载与存储（一）</a></h2><time class="has-text-grey" datetime="2019-04-29T10:30:13.000Z">2019-04-29</time><p class="is-flex-grow-2 mt-2">
读写文本格式的数据通过cat 输出文件内容：
In [20]: cat ex1.csv
a,b,c,d,message
1,2,3,4,hello
5,6,7,8,world
9,10,11,12,foo

由于文件是csv格式，可以使用read_csv读取文件并返回DataFrame：
In [23]: df = pd.read_csv(&amp;#39;ex1.csv&amp;#39;)

In [24]: df
Out[24]:
   a   b   c   d message
0  1   2   3   4   hello
1  5   6   7   8   world
2  9  10  11  12     foo

如果想读取没有标题行的文件:
In [26]: cat ex2.csv
1,2,3,4,..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%EF%BC%88%E4%B8%80%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%94%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%94%EF%BC%89/">Python数据分析之Pandas-Series与DataFrame基本功能（五）</a></h2><time class="has-text-grey" datetime="2019-04-26T09:52:17.000Z">2019-04-26</time><p class="is-flex-grow-2 mt-2">
层次化索引层次化索引让你能在一个轴上拥有多个索引级别。层次化索引我个人理解是对索引进行了分组，比方说一部分数据是今年的，一部分数据是明年的，可通过层次化索引进行切块以方便后续选取数据
In [263]: data = Series(np.random.randn(10), index=[[&amp;#39;2010&amp;#39;,&amp;#39;2010&amp;#39;,&amp;#39;2010&amp;#39;,&amp;#39;2011&amp;#39;,&amp;#39;2011&amp;#39;,&amp;#39;2011&amp;#39;,&amp;#39;2012&amp;#39;,&amp;#39;2012&amp;#39;,&amp;#39;2013&amp;#39;,&amp;#39;2013&amp;#39;],[
     ...: 1, 2, 3, 1, 2, 3, 1, 2, 2, 3]])  # 这种形式叫做带有```Mul..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%94%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%89%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%89%EF%BC%89/">Python数据分析之Pandas-Series与DataFrame基本功能（三）</a></h2><time class="has-text-grey" datetime="2019-04-25T08:54:30.000Z">2019-04-25</time><p class="is-flex-grow-2 mt-2">
汇总和计算描述统计pandas中有一些常用的统计方法，主要功能是做约简和汇总统计。
In [188]: df = DataFrame([[1.4, np.nan], [7.1, -4.5], [np.nan, np.nan], [0.74, -1.3]], index=[&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;], columns=[&amp;#39;one&amp;#39;,&amp;#39;two&amp;#39;])

In [190]: df
Out[190]:
    one  two
a  1.40  NaN
b  7.10 -4.5
c   NaN  NaN
d  0.74 -1.3

In [189]: df.sum()
Out[189]:
one    9.24
t..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%89%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E5%9B%9B%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E5%9B%9B%EF%BC%89/">Python数据分析之Pandas-Series与DataFrame基本功能（四）</a></h2><time class="has-text-grey" datetime="2019-04-25T07:51:09.000Z">2019-04-25</time><p class="is-flex-grow-2 mt-2">
如何处理缺失数据在练习中经常遇到pandas使用浮点值NaN来表示数组中的缺失数据。那我们该如何处理这些缺失数据？
In [228]: string_data = Series([&amp;#39;aardvark&amp;#39;, &amp;#39;artichoke&amp;#39;, np.nan, &amp;#39;avocado&amp;#39;])

In [229]: string_data
Out[229]:
0     aardvark
1    artichoke
2          NaN
3      avocado
dtype: object

In [230]: string_data.isnull()
Out[230]:
0    False
1    False
2     True
3    False
dtype..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E5%9B%9B%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/">Python数据分析之Pandas-Series与DataFrame基本功能（二）</a></h2><time class="has-text-grey" datetime="2019-04-24T10:47:20.000Z">2019-04-24</time><p class="is-flex-grow-2 mt-2">
算数运算和数据对齐pandas中的一个功能是对不同索引的对象进行算数运算。在运算时，如果存在不同的索引对，那么结果就是它们的并集。
In [122]: s1 = Series([7.3, -2.5, 3.4, 1.5], index=[&amp;#39;a&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;d&amp;#39;,&amp;#39;e&amp;#39;])

In [123]: s2 = Series([-2.1, 3.6, -1.5, 4, 3.1], index=[&amp;#39;a&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;e&amp;#39;,&amp;#39;f&amp;#39;,&amp;#39;g&amp;#39;])

In [124]: s1
Out[124]:
a    7.3
c   -2.5
d    3.4
e    1.5
dtype: flo..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20pandas"><i class="tag post-item-tag">Python, pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/">Python数据分析之Pandas-Series与DataFrame基本功能（一）</a></h2><time class="has-text-grey" datetime="2019-04-23T06:37:53.000Z">2019-04-23</time><p class="is-flex-grow-2 mt-2">
重新索引pandas对象的一个重要方法，其作用是创建一个适应新索引的新对象。
reindex在Series上的应用In [3]: obj = Series([4.5, 7.2, -5.3, 3.6], index=[&amp;#39;d&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;c&amp;#39;])

In [4]: obj
Out[4]:
d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64

In [5]: obj2 = reindex([&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;])

In [6]: obj2 = obj.reindex([&amp;#39;a&amp;..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-21199b69100c1a6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20Pandas"><i class="tag post-item-tag">Python, Pandas</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame/">Python数据分析之Pandas-Series与DataFrame-</a></h2><time class="has-text-grey" datetime="2019-04-22T01:51:00.000Z">2019-04-22</time><p class="is-flex-grow-2 mt-2">

在pandas中接下来要经常用到的数据结构就是Series和DataFrame了。这两个对象为大多数数据处理提供了可靠、易于使用的功能

SeriesSeries是由一组数据以及这组数据所对应的数据标签（即索引）组成。
In [66]: obj = Series([4, 7, -5, 3])

In [67]: obj
Out[67]:
0    4
1    7
2   -5
3    3
dtype: int64

其中左边的一列数字即为索引，索引默认是0到N-1的数字。
自定义索引我们可以通过设置index属性来自定义索引的表现形式。
In [68]: obj2 = Series([4, 7, -5, 3],index = [&amp;#39;d&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;a&amp;#39;,..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BPandas-Series%E4%B8%8EDataFrame/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-52378f7408b16ff6.b7GJ6Crjo8S1cCY_ii1ETQHaEJ&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E6%95%B0%E7%BB%84%E8%BD%AC%E7%BD%AE%E4%B8%8E%E8%BD%B4%E5%AF%B9%E6%8D%A2%E8%AF%A6%E8%A7%A3/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-52378f7408b16ff6.b7GJ6Crjo8S1cCY_ii1ETQHaEJ&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E5%9F%BA%E7%A1%80,%20NumPY"><i class="tag post-item-tag">基础, NumPY</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E6%95%B0%E7%BB%84%E8%BD%AC%E7%BD%AE%E4%B8%8E%E8%BD%B4%E5%AF%B9%E6%8D%A2%E8%AF%A6%E8%A7%A3/">Python数据分析之Numpy-数组转置与轴对换详解</a></h2><time class="has-text-grey" datetime="2019-04-16T07:14:39.000Z">2019-04-16</time><p class="is-flex-grow-2 mt-2">

在数学中，将矩阵的行列互换就称之为转置。那在NumPy数组中也是如此。NumPy共有三种转置方式**T属性、transpose方法、swapaxes方法**。

T属性T属性 它比较常用于二维数组，通过行列互换得到一个新的数组，和数学中的转置是一模一样的。

通过转置后得到一个行列互换的新的矩阵：

In [170]: arr = np.arange(12).reshape(4,3)

In [171]: arr
Out[171]:
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])

In [172]: arr.T
Out[172]:
array([[ 0,  3,  6,  9],
..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E6%95%B0%E7%BB%84%E8%BD%AC%E7%BD%AE%E4%B8%8E%E8%BD%B4%E5%AF%B9%E6%8D%A2%E8%AF%A6%E8%A7%A3/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-52378f7408b16ff6.b7GJ6Crjo8S1cCY_ii1ETQHaEJ&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%88%87%E7%89%87/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-52378f7408b16ff6.b7GJ6Crjo8S1cCY_ii1ETQHaEJ&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20NumPy"><i class="tag post-item-tag">Python, NumPy</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%88%87%E7%89%87/">Python数据分析之Numpy-基本的索引与切片</a></h2><time class="has-text-grey" datetime="2019-04-15T09:52:17.000Z">2019-04-15</time><p class="is-flex-grow-2 mt-2">

NumPy数组的切片与Python中列表的区别在于它的切片是直接对原始数据进行操作，也就是说你做的任何修改都会直接影响到源数据，因为它修改的是内存中的数据。

NumPy数组切片与列表切片的区别In [36]: arr = np.arange(10)

In [37]: arr
Out[37]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [38]: arr[3:6]
Out[38]: array([3, 4, 5])

In [39]: arr[3:6] = 10

In [40]: arr
Out[40]: array([ 0,  1,  2, 10, 10, 10,  6,  7,  8,  9])

In [43]: arr2 = arr  #将arr赋值..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%88%87%E7%89%87/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-52378f7408b16ff6.b7GJ6Crjo8S1cCY_ii1ETQHaEJ&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-ndarray%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-52378f7408b16ff6.b7GJ6Crjo8S1cCY_ii1ETQHaEJ&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python,%20NumPy"><i class="tag post-item-tag">Python, NumPy</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-ndarray%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Python数据分析之Numpy-ndarray及数据类型</a></h2><time class="has-text-grey" datetime="2019-04-12T03:39:50.000Z">2019-04-12</time><p class="is-flex-grow-2 mt-2">
NumPy的ndarrayndarray作为NumPy中最重要的特点，你可以利用这个对数组进行数学运算。下面来看一个简单的例子
In [1]: import numpy as np

In [2]: data  = [1, 2, 3, 4, 5]  # 创建一个普通的数组

In [3]: data2  = np.array(data) # 通过np.array函数把data转为ndarray对象
In [4]: data2
Out[4]: array([1, 2, 3, 4, 5])

In [5]: data
Out[5]: [1, 2, 3, 4, 5]  # 粗略一看发现没什么特别大的区别

继续往下看
In [6]: data2 * 10
Out[6]: array([10, 20, 30, 4..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-ndarray%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="http://upload-images.jianshu.io/upload_images/1515206-52378f7408b16ff6.b7GJ6Crjo8S1cCY_ii1ETQHaEJ&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D/"><img class="post-cover-img js-img-fadeIn" src="http://upload-images.jianshu.io/upload_images/1515206-52378f7408b16ff6.b7GJ6Crjo8S1cCY_ii1ETQHaEJ&amp;pid=Api&amp;rs=1&amp;p=0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Python%EF%BC%8CNumPy"><i class="tag post-item-tag">Python，NumPy</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D/">Python数据分析之Numpy---入门安装介绍</a></h2><time class="has-text-grey" datetime="2019-04-11T04:08:25.000Z">2019-04-11</time><p class="is-flex-grow-2 mt-2">

NumPy(Numerical Python)是高性能科学计算和数据分析的基础包，主要功能是对N维数组的操作和计算，其计算效率是Python原生包的N倍，在使用Python做数据分析过程中NumPy是我们必不可少的一个工具。

作为一个基础包，功能上远不及pandas来的那么高级（下面会出pandas系列的笔记），但是作为新手入门NumPy还是很值得我们学习一下，为接下来学习pandas打好基础。
准备工作
安装Python环境如果没有pip环境请参考这篇文章 pip 的简单安装与基本使用

windows下载NumPy安装包，注意安装包的Python版本和系统版本。例如numpy-1.16.2-cp27-cp27m-manylinux1_x86_64.whl中cp27指的是python2.7版本。
需..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/data-analyst/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BNumpy-%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://upload-images.jianshu.io/upload_images/1515206-a692f25fea72b9da.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/850/format/webp" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/python/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90Python%E5%88%87%E7%89%87/"><img class="post-cover-img js-img-fadeIn" src="https://upload-images.jianshu.io/upload_images/1515206-a692f25fea72b9da.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/850/format/webp" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/python"><i class="tag post-item-tag">python</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/python/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90Python%E5%88%87%E7%89%87/">深度解析Python切片</a></h2><time class="has-text-grey" datetime="2019-03-13T12:57:57.000Z">2019-03-13</time><p class="is-flex-grow-2 mt-2">
前言在平时是否会遇到这样的场景，需要分离出 列表（List）中的部分数据。很多初学者都会想到用while循环去取，很显然这么做肯定是不可取的而且违背了Python之禅中的最重要的一条:

Beautiful is better than ugly. 设计高效且漂亮的解决方案是每个程序员的必备素质

那这个时候Python切片就是我们的不二之选，Python切片的表达式十分简单，但是如果不彻底理解它的话很容易出错，这也是为什么本人特地专门为此写一篇文章的原因。
Python切片语法表达式List[start_index : end_index : step]

先简单解释下这个表达式：

start_index : 起始索引值，一般默认为0，表示从列表的初始点开始取值。另外，如果step为负数的话则默认为列..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/python/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90Python%E5%88%87%E7%89%87/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/iOS"><i class="tag post-item-tag">iOS</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/ios/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%20/">iOS内存管理那些事</a></h2><time class="has-text-grey" datetime="2019-02-03T03:12:19.000Z">2019-02-03</time><p class="is-flex-grow-2 mt-2">=================
前言
今天在网上看到一道蛮有趣的问题，内容是”对于已经会使用ARC的iOS开发者来说还有必要学习手动内存管理吗？”。换做一年前的我可能会觉得那必须不用学啊，手动管理内存管理太麻烦了而且很容易出错。ARC现在用下来完全能够解决我日常开发中的所有内存管理的问题，而且苹果在WWDC2011上已经强烈推荐开发者使用ARC，为什么不用ARC呢?
直到我有一次使用了第三方组件，当时这个组件是不支持ARC的。有一天在我做新功能的时候突然出现了一个没有任何踪迹的崩溃，经过了1个通宵的排查和网友的帮助最后才得知原来是非ARC和ARC的代码混用出现的问题，后来还是自己重新写了个非ARC的功能才解决了这个问题。
引用计数
每当一个对象被创建的时候它的引用计数为1，为保证对象的存在不造成悬挂指针..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/ios/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%20/">更多</a></section></article></section><aside class="column is-hidden-mobile is-4-tablet is-3-widescreen"><div style="position: sticky; top: 50px;"><main class="aside-card-container archives-widget is-in-archive-page"><h3>归档</h3><section><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a><span class="archive-list-count">1</span></li></ul></section></main></div></aside></div></article><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fuer4869"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> loannes 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></body></html>