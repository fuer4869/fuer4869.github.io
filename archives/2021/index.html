<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>loannes's blog</title><meta name="description"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/widget-post-list.css"><meta name="generator" content="Hexo 5.3.0"></head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">loannes's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><span>归档 · 2021</span></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><article class="post-container is-flex is-justify-content-center section container is-max-widescreen pt-4 px-2"><div class="columns is-variable is-1-tablet is-3-desktop-only is-2-widescreen is-full-width"><section class="column"><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/">剑指 Offer 35. 复杂链表的复制</a></h2><time class="has-text-grey" datetime="2021-02-28T13:46:07.000Z">2021-02-28</time><p class="is-flex-grow-2 mt-2">

前往此题

哈希表法
利用哈希表将链表将节点与节点组成键值对关系储存起来，最后在构建新链表的时候遍历原始链表，将原始链表中各节点的next与random从哈希表中获取。
算法流程

新建哈希表dic
遍历原始链表，新建节点并存入到dic中，键值对关系为(原始节点，新节点)
构建新链表中各节点的next与random的指向

class Solution:
    def copyRandomList(self, head: 'Node') -&amp;gt; 'Node':
      if not head: return None
      cur = head
      dic = &amp;#123;&amp;#125;
      while cur:
        dic[cur] = Node(cur.va..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E5%89%91%E6%8C%87-Offer-57-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E6%95%B0%E5%AD%A6"><i class="tag post-item-tag">数学</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E5%89%91%E6%8C%87-Offer-57-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h2><time class="has-text-grey" datetime="2021-02-26T11:32:06.000Z">2021-02-26</time><p class="is-flex-grow-2 mt-2">

前往此题

求和公式解法
根据等差数列求和公式，依据已知的target我们可以计算出数列的范围(i,j)。
根据求和公式：
$$
Sn=(a1+an)n/2
$$
代入我们求的范围(i,j):
$$
target = \frac{(i + j) \times (j - i + 1)}{2}
$$
现在我们已知target需要求j, 公式可以这样推导：
$$
target = \frac{ij - i^2 + i + j^2 - ij + j}{2}
$$
$$
target = \frac{j^2 + j - i^2 + i}{2}
$$
$$
2 \times target - (j^2 + j - i^2 + i) = 0
$$
整理一下：
$$
j^2 + j - (2 \times target..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E5%89%91%E6%8C%87-Offer-57-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E6%95%B0%E7%BB%84"><i class="tag post-item-tag">数组</i></a><a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8"><i class="tag post-item-tag">哈希表</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">剑指 Offer 03. 数组中重复的数字</a></h2><time class="has-text-grey" datetime="2021-02-25T19:37:20.000Z">2021-02-26</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路哈希表法遍历nums，将每个值存入到哈希表中同时检查当前遍历的值是否已经存在，如果存在说明nums中有重复元素，直接返回即可。
class Solution:
    def findRepeatNumber(self, nums: List[int]) -&amp;gt; int:
        maps = &amp;#123;&amp;#125;
        for n in nums:
            if n in maps: return n
            else: maps.add(n)

复杂度分析

时间复杂度：O(N)
空间复杂度：O(N)

原地置换上面的解法空间复杂度是O(N)的，可以使用原地置换法来达到O(1)。
题目中给出了在一个长度为 n 的数组 nu..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-16-%E6%8C%89%E6%91%A9%E5%B8%88/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><i class="tag post-item-tag">动态规划</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-16-%E6%8C%89%E6%91%A9%E5%B8%88/">面试题 17.16. 按摩师</a></h2><time class="has-text-grey" datetime="2021-02-23T11:15:01.000Z">2021-02-23</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路像这种不同阶段之间都有联系的题一般都能用动态规划来解
状态设计题目中按摩师存在不接预约和接预约两种情况，我们在做动态规划的时候需要将两种情况都计算进去。

dp[i][0] 代表当天不接受预约的累积最大时长
dp[i][1] 代表当天接受预约所累积的最大时长

状态转移方程上面我们也分析了，此题中只有两种状态，接下来对这两种状态分析出转移方程

今天接受预约：代表昨天肯定没有接受预约，所以只需要将昨天的时长加上今天的时长
dp[i][1] = dp[i-1][0] + nums[i] 

今天不接受预约：代表昨天接受了预约或者没接受预约，我们取这两者的最大值即可
dp[i][0] = max(dp[i-1][0], dp[i-1][1])


边界确定了状态转移方程，我们知道了元素之..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-16-%E6%8C%89%E6%91%A9%E5%B8%88/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><i class="tag post-item-tag">广度优先搜索</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">剑指-Offer-32-I-从上到下打印二叉树</a></h2><time class="has-text-grey" datetime="2021-02-20T23:39:24.000Z">2021-02-21</time><p class="is-flex-grow-2 mt-2">

前往此题  

广度优先搜索这题比较简单，使用迭代法很轻松就能解出来。本题实际上求的是逐层遍历整个二叉树，按照从左至右的顺序依次打印。这里我们只需要借助队列queue将每层的节点放入其中，按照先进先出的规则依次访问节点值并放入最终答案res中即可。
代码# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -&amp;gt; Lis..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a><a href="/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><i class="tag post-item-tag">分治算法</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/">剑指-Offer-25-合并两个排序的链表</a></h2><time class="has-text-grey" datetime="2021-02-09T09:43:16.000Z">2021-02-09</time><p class="is-flex-grow-2 mt-2">

前往此题  

辅助节点法借助辅助节点cur,dum。cur负责将遍历l1、l2，根据l1、l2的大小关系来确定添加到cur节点的顺序。dum指向cur因为l1,l2都是有序的，如果出现其中一个节点走到底了，另外一个直接拼接上去即可。
算法流程：初始化cur、dum, 将dum指向cur循环l1或者l2, 终止条件:l1或者l2为null当l1.val &amp;lt; l2.val时， cur.next = l1将cur的下一个节点指向l1，l1向后走一步否则 cur.next = l2 cur的下一个节点指向l2并且l2向后走一步最后cur向后走一步cur=cur.next最后合并尾部： 如果出现有剩余未合并的直接拼接到cur后即可。cur.next = l1 if l1 else l2最终返回结果为dum..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E6%A0%88"><i class="tag post-item-tag">栈</i></a><a href="/tags/%E8%AE%BE%E8%AE%A1"><i class="tag post-item-tag">设计</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/">剑指-Offer-09-用两个栈实现队列</a></h2><time class="has-text-grey" datetime="2021-02-09T08:20:24.000Z">2021-02-09</time><p class="is-flex-grow-2 mt-2">

前往此题  

解题思路
栈与队列的区别在于： 前者是先进后出，后者是先进先出。
如果用单个栈无法实现队列的功能，队首元素无法被栈直接删除，需要将所有上方元素出栈。
也就是说在出队（出栈）功能上，栈与队列中的元素是相反的。比如栈 A = [1, 2, 3] ， 队列 B = [3, 2, 1] 。A出栈意味着将**[3]出栈， **B 出队也就是将**[3]出队，加下来的出队（出栈）对象是[2]**。
通过双栈A, B ， 对其中一个栈执行倒序来实现队列的出队功能，另外一个栈负责存储数据。


函数逻辑
设计两个栈A, B
A负责存储入队的数据， B负责依序出队
入队：直接将数据如栈A
出队有三种情况：
当栈A, B为空的时候代表队列为空，返回**-1**
当栈A为空， 栈B不为空的时候，栈B出栈并返回..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-03-04-%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E6%A0%88"><i class="tag post-item-tag">栈</i></a><a href="/tags/%E8%AE%BE%E8%AE%A1"><i class="tag post-item-tag">设计</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-03-04-%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/">面试题 03.04. 化栈为队</a></h2><time class="has-text-grey" datetime="2021-02-09T07:58:56.000Z">2021-02-09</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路两个辅助栈cur,tmp，一个负责入队，一个负责出队。因为栈是先进后出，队是先进先出的规则，所以我们在用栈来模拟队的pop函数的时候需要把栈倒叙后再执行pop。
代码class MyQueue:

    def __init__(self):
        &amp;quot;&amp;quot;&amp;quot;
        Initialize your data structure here.
        &amp;quot;&amp;quot;&amp;quot;
        self.tmp, self.cur = [], []

    def push(self, x: int) -&amp;gt; None:
        &amp;quot;&amp;quot;&amp;quot;
        Push element ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-03-04-%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/559-N-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><i class="tag post-item-tag">深度优先搜索</i></a><a href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><i class="tag post-item-tag">广度优先搜索</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/559-N-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">559-N-叉树的最大深度</a></h2><time class="has-text-grey" datetime="2021-02-09T04:28:01.000Z">2021-02-09</time><p class="is-flex-grow-2 mt-2">

前往此题)  

解题思路这道题是二叉树的最大深度的变种题，它们的区别仅仅在于2和N的区别。解题办法也和二叉树的相同，深度优先和广度优先都可以解这道题。
深度优先搜索（递归法）算法流程过滤极端情况，root为None或者 root.children为空则返回0或1因为我们不知道有几个分支，所以我们在遍历的时候需要将每条分支的高度放入数组中，然后取其最大值。
代码&amp;quot;&amp;quot;&amp;quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&amp;quot;&amp;quot;&amp;..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/559-N-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/">剑指 Offer 06. 从尾到头打印链表</a></h2><time class="has-text-grey" datetime="2021-02-07T07:19:37.000Z">2021-02-07</time><p class="is-flex-grow-2 mt-2">

前往此题

辅助栈法思路很简单，通过辅助栈temp将所有节点放入其中。然后遍历整个栈从末尾开始放入最终答案res中即可。
代码
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reversePrint(self, head: ListNode) -&amp;gt; List[int]:
        if not head: return []
        temp = []
        res = []
        while h..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><i class="tag post-item-tag">深度优先搜索</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/">129. 求根到叶子节点数字之和</a></h2><time class="has-text-grey" datetime="2021-02-06T10:54:44.000Z">2021-02-06</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路这是一道很典型的深度优先搜索题。题目很明确的告诉我们需要从根节点出发按照节点路径走到底来遍历整个二叉树。我们可以通过total这个变量来记录每条路径上的值。total * 10 + root.val，total记录数值的终止条件为走到节点的末尾，也就是找不到它的左右子节点。total记录的终止条件 :root.left == null &amp;amp;&amp;amp; root.right == null

代码
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#        ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%95%B0%E7%BB%84"><i class="tag post-item-tag">数组</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><i class="tag post-item-tag">二分查找</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/">81. 搜索旋转排序数组 II</a></h2><time class="has-text-grey" datetime="2021-02-06T07:24:27.000Z">2021-02-06</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路按照例题可以把该数组拆为2个区间。
第一种情况：
[2,5,6,0,0,1,2]拆解为[2,5,6]和[0,0,1,2]。

这种情况这两个区间都是升序的，在查找过程中只要确定target在哪个区间内就能通过二分查找直接锁定
第二种情况
[3,2,0,1,2] 拆解为 [3,2] 和 [0,1,2]
这种前者肯定是无序的，后者是有序的情况下（包括重复元素）。所以后者的判断条件如果写成nums[left] &amp;lt; nums[mid]的时候需要考虑到重复元素的情况，否则如[0,0,1]会出错。

第三种情况最后一种情况[1,1,1,0,1]拆解为[1,1,1,1]和[0] 以及 [3,1]都无法确定是否有序。这里特殊情况也要考虑进去, 通过left = left + 1来过滤掉重复项。..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://i.loli.net/2021/02/05/8lWv7eXDJ4RtYsj.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/Redis%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/"><img class="post-cover-img js-img-fadeIn" src="https://i.loli.net/2021/02/05/8lWv7eXDJ4RtYsj.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/Redis%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/">Redis基础理论知识详解</a></h2><time class="has-text-grey" datetime="2021-02-05T06:34:12.000Z">2021-02-05</time><p class="is-flex-grow-2 mt-2">

学了一段时间的redis，觉得以前对Redis的了解太过浅薄了, 现在内心有种强烈的冲动想要把最近学到的知识和我对Redis的理解给写出来。

Redis是什么
Redis是一个基于键值对的NoSQL数据库，与很多键值对数据库不同，Redis 提供了丰富的 值数据存储结构，包括 string、hash、list、set、zset(有序集合)等。
为什么要使用Redis
![image-20210205174819181](/Users/weijiezhu/Library/Application Support/typora-user-images/image-20210205174819181.png)
随着互联网用户的不断增加，早在90年代单靠一个MySQL就能支撑起整个网站的数据服务已经不复存在了，..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/Redis%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-02-02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88"><i class="tag post-item-tag">双指针</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-02-02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/">面试题 02.02. 返回倒数第 k 个节点</a></h2><time class="has-text-grey" datetime="2021-02-04T07:44:40.000Z">2021-02-04</time><p class="is-flex-grow-2 mt-2">

前往此题

双指针法在不知道链表长度的情况下，需要知道倒数第k个节点可以借助一个临时节点p,让他先走k步。然后head和p一起往后移，当p走到末尾的时候，head指向的节点就是我们要求的节点。

代码
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def kthToLast(self, head: ListNode, k: int) -&amp;gt; int:
        p = head
        for i in range(0, k)..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-02-02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E6%95%B0%E7%BB%84"><i class="tag post-item-tag">数组</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h2><time class="has-text-grey" datetime="2021-02-04T06:54:32.000Z">2021-02-04</time><p class="is-flex-grow-2 mt-2">

前往此题

抵消法这题简单来讲就是按照正负抵消的方式来解。众所周知数组中的众数的数量必定大于其他数，那么一一抵消下来最后剩下来的就是最终答案了
算法思路假设我们要求的众数为x。通过辅助变量votes来记录正负关系，遇到数字n记作1，将n存储到变量res中代表众数x。如果再次遇到x，votes+1,遇到其他数字votes-1。
代码
class Solution:
    def majorityElement(self, nums: List[int]) -&amp;gt; int:
        votes = 0
        for n in nums:
            if votes == 0: res = n
            if n == res: votes += 1
   ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2"><i class="tag post-item-tag">字符串</i></a><a href="/tags/%E6%A0%88"><i class="tag post-item-tag">栈</i></a><a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8"><i class="tag post-item-tag">哈希表</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/">20. 有效的括号</a></h2><time class="has-text-grey" datetime="2021-02-04T04:26:02.000Z">2021-02-04</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路看到这种题首先应该想到的是通过哈希表来检查符号的对应关系。
哈希表可以在**O(1)**的时间复杂度下准确快速的找到对应字符, 为了方便确认字符串对应关系是否合理需要用到栈的出栈入栈功能
通过遍历整个字符与哈希表做对应检查, 如果存在对应关系则会入栈，如果找不到对应关系就提前返回false。因为栈一开始为空，所以需要临时加入？元素作为辅助作用
代码
class Solution:
    def isValid(self, s: str) -&amp;gt; bool:
        sets = &amp;#123;&amp;quot;(&amp;quot;:&amp;quot;)&amp;quot;,&amp;quot;&amp;#123;&amp;quot;:&amp;quot;&amp;#125;&amp;quot;,&amp;quot;[&amp;quot;:&amp;quot;]&amp;quo..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">104. 二叉树的最大深度</a></h2><time class="has-text-grey" datetime="2021-02-04T04:12:18.000Z">2021-02-04</time><p class="is-flex-grow-2 mt-2">

前往此题

深度优先用递归的话比较好解, 借助这套公式max(l + r) + 1。l与r代表当前递归左右子树的深度。也就是说在每次递归都会返回深度+1，最终比较深的那一边就是最终答案。
代码

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -&amp;gt; int:
        if not root: return 0..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2"><i class="tag post-item-tag">字符串</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/">面试题 01.06. 字符串压缩</a></h2><time class="has-text-grey" datetime="2021-02-03T11:10:52.000Z">2021-02-03</time><p class="is-flex-grow-2 mt-2">

前往此题

计数法借助两个变量作为辅助，ant表示当前扫描的字符，count表示当前扫描字符的重复数。当扫描到的字符与ant不相等的时候，res变量记作res += ant + str(count)，为了节约内存没用使用res = res + ant + str(count)。如果相等则计数count + 1,继续扫描。最后再根据res与S的长度决定返回值。
代码
class Solution:
    def compressString(self, S: str) -&amp;gt; str:
        if not S: return &amp;quot;&amp;quot;
        count = 0
        res = &amp;quot;&amp;quot;
        ch = S[0]

      ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88"><i class="tag post-item-tag">双指针</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/">19. 删除链表的倒数第 N 个结点</a></h2><time class="has-text-grey" datetime="2021-02-02T11:30:46.000Z">2021-02-02</time><p class="is-flex-grow-2 mt-2">

前往此题

双指针解法通过两个指针slow,fast可以很方便的解决这个问题。我们记录一个快指针，一个慢指针，slow指针起始点是链表头部，fast指针起始点为n。随即两个指针同时开始往下走，当fast走到链表末尾的时候，slow指针的下一个指针就是l-n，也就是倒数第n个节点。slow.next = slow.next.next删除即可。

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, h..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E6%95%B0%E7%BB%84"><i class="tag post-item-tag">数组</i></a><a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><i class="tag post-item-tag">二分查找</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/">349. 两个数组的交集</a></h2><time class="has-text-grey" datetime="2021-02-02T11:25:12.000Z">2021-02-02</time><p class="is-flex-grow-2 mt-2">

前往此题

两个set法最直观最简单的解法，set一般用于检查某元素是否存在于某个集合中。并且它能提供O(1)的时间复杂度
算法过程

利用set对数组去重
遍历查找长度较短的set去对比另外个set，检查是否有重合元素
将重合元素存入数组result中

代码
class Solution:
    def set_intersection(self, set1, set2):
        return [x for x in set1 if x in set2]


    def intersection(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]:
        s1 = set(nums1)
        s2 =..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/">160. 相交链表</a></h2><time class="has-text-grey" datetime="2021-02-02T09:20:08.000Z">2021-02-02</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路题目中的相交指的是同时走到同一个节点上，可以通过拼接链表的方式来解决这个问题。
设链表A的前半部分为a，链表B的前半部分为b, 后半的相交部分为c。也就是说当链表A走在相交处的时候链表B也必定同时走在相交处。

算法过程

同时遍历链表A，链表B
链表A走完后就走链表B，链表B走完后就走链表A
由于链表A走到a + c ， 链表B走到b + c的时候，链表B比链表A多走了一步，再把链表A指向链表B，链表B指向链表A，a + c + b = b + c + a，链表A与链表B必然会在某一点相交ha==hb
一旦ha==hb，遍历结束返回相交点，这个点必然是它们相交的起始点。
如果这两个链表不想交，那ha最终会指向null，hb也将指向null。 返回ha即可

代码


# Defin..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%8E%92%E5%BA%8F"><i class="tag post-item-tag">排序</i></a><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8"><i class="tag post-item-tag">哈希表</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/">268. 丢失的数字</a></h2><time class="has-text-grey" datetime="2021-02-02T09:01:36.000Z">2021-02-02</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路预备知识
- 哈希表基础
解题思路 — 排序题目给定的条件是一个**0-n的序列，也就是说排序后我们优先能检查0和n**是否不在该序列中，随后再通过遍历去检查其他数。
class Solution:
    def missingNumber(self, nums: List[int]) -&amp;gt; int:
        nums.sort()
        if(nums[-1] != len(nums)): return len(nums)
        elif(nums[0] != 0): return 0

        for i in range(1, len(nums)):
            expect_num = nums[i-1] + 1
   ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">141. 环形链表</a></h2><time class="has-text-grey" datetime="2021-02-02T07:44:19.000Z">2021-02-02</time><p class="is-flex-grow-2 mt-2">

前往此题

预备知识链表基础知识
题解双指针法
slow代表慢指针，它是一步一步走的fast代表快指针，它是二步二步走的
终止条件
如果slow和 fast最终撞在一起了，说明是环形链表。这个应该很好理解吧，相当于是两个人跑步，一个跑的快一个跑的慢，如果是跑直线那么他们两个绝对不会碰撞。如果是跑圈，那迟早会相遇的。如果快指针跑完全程了则说明不是环形链表fast==null或者fast.next==null
代码
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solutio..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><i class="tag post-item-tag">二分查找</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">704. 二分查找</a></h2><time class="has-text-grey" datetime="2021-02-01T11:13:43.000Z">2021-02-01</time><p class="is-flex-grow-2 mt-2">
解题思路二分查找模板题，没什么好细讲的。这题的目的是从列表中找元素，所以while循环条件必须是left &amp;lt;= right需要包含right部分。
代码
class Solution:
    def search(self, nums: List[int], target: int) -&amp;gt; int:
        left = 0;
        right = len(nums) - 1
        while left &amp;lt;= right:
            mid = left + (right-left) // 2
            if target == nums[mid]: return mid
            if target &amp;lt; nu..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/1436-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2"><i class="tag post-item-tag">字符串</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/1436-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/">1436. 旅行终点站</a></h2><time class="has-text-grey" datetime="2021-02-01T11:04:48.000Z">2021-02-01</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路题目的意思是要我们找出线路的终点没有被作为起点的那个站。所以我们只需要2步就能解决这道题
将所有起点放入数组中lines, 查找所有线路，不存在于lines中的站点就是最后的终点站
代码
class Solution:
    def destCity(self, paths: List[List[str]]) -&amp;gt; str:
        if not paths: return &amp;quot;&amp;quot;
        start = [path[0] for path in paths]

        for path in paths:
            if path[1] not in start:
                return path..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/1436-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88"><i class="tag post-item-tag">双指针</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/">234. 回文链表</a></h2><time class="has-text-grey" datetime="2021-02-01T10:39:40.000Z">2021-02-01</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路回文链表有一个标志的特性就是以首尾相应的形式往中间靠拢的。比如1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;2-&amp;gt;1，1对应末尾的1, 2对应倒数第二的2以此类推。所以我们可以借助双指针来完美解决这个问题。一个指针指向头，一个指针指向末尾同步往中间靠拢，如果全程都是相等的那就是回文链表否则就不是。
代码
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListN..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">237. 删除链表中的节点</a></h2><time class="has-text-grey" datetime="2021-02-01T07:38:57.000Z">2021-02-01</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路因为这里不知道node的上一个节点，所以无法通过node.prev.next = node.prev.next.next来更改指针。拿例题来说：[4,5,1,9]**中我们要删除5**，我们需要找到一个能知道目标节点的上一个节点是哪个节点的方式来解决这个问题。
我们知道5的下一个节点1的上一个节点是5。将1赋值到5,变成了**[4,1,1,9]**也就是说我们把本来要删除的5改成要删除第二个1。node.next = node.next.next
代码
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/925-%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2"><i class="tag post-item-tag">字符串</i></a><a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88"><i class="tag post-item-tag">双指针</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/925-%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/">925. 长按键入</a></h2><time class="has-text-grey" datetime="2021-02-01T07:24:30.000Z">2021-02-01</time><p class="is-flex-grow-2 mt-2">

前往此题

双指针解法我们假设有两个指针i、j, 一个指向name的元素，另外一个指向typed的元素。接下来只要考虑到两个条件：
i,j两个指针同步往后移，如果i, j相等则继续，如果出现不相等就说明有长按情况出现了。如果出现长按情况，j指针单独往后移直到i,j相等为止。
代码
class Solution:
    def isLongPressedName(self, name: str, typed: str) -&amp;gt; bool:
        i, j = 0, 0
        while j &amp;lt; len(typed):
            if i &amp;lt; len(name) and name[i] == typed[j]:
                i+=1
 ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/925-%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E9%80%92%E5%BD%92"><i class="tag post-item-tag">递归</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E8%BF%AD%E4%BB%A3"><i class="tag post-item-tag">迭代</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/">145. 二叉树的后序遍历</a></h2><time class="has-text-grey" datetime="2021-01-30T10:21:11.000Z">2021-01-30</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路按照后序遍历左子节点-&amp;gt;右子节点-&amp;gt;根节点的顺序来，下图的最终结果就是4 5 2 6 7 3 1

递归法递归法十分简单，直接套模板即可
class Solution:
    def postorderTraversal(self, root: TreeNode) -&amp;gt; List[int]:
        res = []
        self.dfs(root, res)
        return res


    def dfs(self, root, res):
        if not root: return

        self.dfs(root.left, res)
        self.dfs(root.right, re..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E9%80%92%E5%BD%92"><i class="tag post-item-tag">递归</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E8%BF%AD%E4%BB%A3"><i class="tag post-item-tag">迭代</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/">144. 二叉树的前序遍历</a></h2><time class="has-text-grey" datetime="2021-01-30T08:46:54.000Z">2021-01-30</time><p class="is-flex-grow-2 mt-2">

前往此题

基本概念要解决这道题首先得了解二叉树前序遍历
前序遍历
以下面这个二叉树为例，前序遍历的遍历顺序为根节点-&amp;gt;左子节点-&amp;gt;右子节点:

前序遍历一切都以左子节点为优先，即遍历结果为1 2 4 5 3 6 7
递归解法递归解法十分简单，直接上代码了
代码class Solution:
    def preorderTraversal(self, root: TreeNode) -&amp;gt; List[int]:
        def preorder(root:TreeNode):
            if not root: return
            res.append(root.val)
            root.left = preorder(roo..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/1614-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2"><i class="tag post-item-tag">字符串</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/1614-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/">1614. 括号的最大嵌套深度</a></h2><time class="has-text-grey" datetime="2021-01-30T07:29:28.000Z">2021-01-30</time><p class="is-flex-grow-2 mt-2">

前往此题

统计法借助变量cur来统计括号的出现次数做互相抵消。res则记录抵消次数，最终结果返回res
class Solution:
    def maxDepth(self, s: str) -&amp;gt; int:
        res = 0
        cur = 0
        for char in s:
            if char == &amp;quot;(&amp;quot;: res += 1
            if char == &amp;quot;)&amp;quot;: 
                res -= 1
            cur = max(res, cur)
        
        return cur

复杂度分析

时间复杂度:  O(N..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/1614-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E6%A0%88"><i class="tag post-item-tag">栈</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/">94. 二叉树的中序遍历</a></h2><time class="has-text-grey" datetime="2021-01-30T05:46:39.000Z">2021-01-30</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路预备知识：

二叉树结构基础
中序遍历是什么

什么是中序遍历
有个口诀叫：左根右意思就是在遍历过程中，先找到根节点然后会去找左子节点，如果有左子节点就继续在往下找，直到找到最地下一层的左子节点。如果没有左子节点就返回根节点，最后才返回右子节点。

如图：中序遍历最终返回的顺序为：BDCAEHGKF
递归法
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inor..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/%E9%93%BE%E8%A1%A8"><i class="tag post-item-tag">链表</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">206. 反转链表</a></h2><time class="has-text-grey" datetime="2021-01-30T05:31:00.000Z">2021-01-30</time><p class="is-flex-grow-2 mt-2">

前往此题

解题思路迭代法思路其实很简单就是把链表指向全都倒过来,我们将通过双指针来辅助实现。把 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 变成 1&amp;lt;-2&amp;lt;-3&amp;lt;-4&amp;lt;-5。千万不要理解成把它变成 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1prev、tmp做辅助
cur(当前)指向prev(前一个)prev(前一个)变成cur(当前)cur(当前)变成下一个重复上面步骤
代码实现
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class So..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E4%B8%AD%E7%AD%89%EF%BC%8C%20BFS"><i class="tag post-item-tag">中等， BFS</i></a><a href="/tags/BFS"><i class="tag post-item-tag">BFS</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">102. 二叉树的层序遍历</a></h2><time class="has-text-grey" datetime="2021-01-30T05:02:18.000Z">2021-01-30</time><p class="is-flex-grow-2 mt-2">

前往leetcode刷此题

解题思路这道题其实还是蛮简单的，dfs 和 bfs都能解决。题目的大致意思是遍历一个二叉树，将其每层节点放入到一个二元数组中。而且还要求是逐层遍历，从左至右访问所有节点。那在遍历的时候我们只需要考虑左右顺序以及层级就行了。
BFS因为需要逐层遍历，所以我们需要将每一层的数据按序放入到队列中，然后将每层的节点按照从左至右的顺序放入到一个临时数组level中。

首先套用最基本的模板, 初始化队列并将根节点放入到队列中

queue = collections.deque()
        queue.append(root)
        res = []


遍历队列并创建一个临时数组level，将找到的节点放入到level中，然后继续往下层遍历，将节点的左右子节点放入..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a><a href="/tags/DFS"><i class="tag post-item-tag">DFS</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h2><time class="has-text-grey" datetime="2021-01-29T09:01:49.000Z">2021-01-29</time><p class="is-flex-grow-2 mt-2">
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

解题思路
首先在解这道题之前我们必须得理解什么是最近的公共祖先。
用图来解释比较好理解，有以下几种情况：


节点p、q中，其中一个为另外一个的子节点



如果节点p、q为某一个节点root的左右子树，那么它们的最近公共祖先就是root



如果root的左右子树中都不包含p、q，返回null


根据这三种情况我们可以得到递归的基本条件


终止条件
如果..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E4%B8%AD%E7%AD%89%EF%BC%8C%E6%95%B0%E7%BB%84"><i class="tag post-item-tag">中等，数组</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/">189. 旋转数组</a></h2><time class="has-text-grey" datetime="2021-01-29T05:48:44.000Z">2021-01-29</time><p class="is-flex-grow-2 mt-2">
题目描述给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
解题思路一：切片第一步求出了k与nums长度的余数是为了避免出现k&amp;gt;len(nums)的情况出现, 然后在进行切片，把切下来的倒数k个元素放到列表最前面即可。值得注意的是，在python中以nums = nums[-k:]+….的形式不能顺利赋值，需要以全切的方式nums[:]才可以。

class Solution:
def rotate(self, nums: List[int], k: int) -&amp;gt; None:
    if k == 0: return
    k = k%len(nums)
    nums[:] = nums[-k:] + nums[:-k]

复杂度分析：时间复杂度：O(N)  此算..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E7%AE%80%E5%8D%95%EF%BC%8C%E6%95%B0%E7%BB%84%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88"><i class="tag post-item-tag">简单，数组，双指针</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">26. 删除排序数组中的重复项</a></h2><time class="has-text-grey" datetime="2021-01-29T04:40:20.000Z">2021-01-29</time><p class="is-flex-grow-2 mt-2">

前往leetcode做此题

解题思路因为nums是一个排序数组，所以重复项只会出现在相邻的位置。可以通过双指针的方式来指定其中的元素，然后逐步往后移动进行比对，直到找到相邻且相等的元素删除即可。有一点要注意的是，如果连续出现三个重复的元素，用两两比对会漏掉一个，这个时候需以第一个重复元素为参照物进行比对，直到删除了所有的重复项后再往后移动。


代码实现class Solution:
    def removeDuplicates(self, nums: List[int]) -&amp;gt; int:
        left, right = 0, 1
        while right &amp;lt; len(nums):
            if nums[left] == nums[right..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E7%AE%80%E5%8D%95"><i class="tag post-item-tag">简单</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h2><time class="has-text-grey" datetime="2021-01-27T14:52:40.000Z">2021-01-27</time><p class="is-flex-grow-2 mt-2">

前往此题

递归法
二叉搜索树祖先的定义：
若节点p在节点root的左或者右子树中，或者p=root，则称root是p的祖先。
根据祖先的定义，可以分析出以下几种情况：

q和p在root左右两边，此时它们的祖先就是root
当root.val &amp;lt; p.val, 则p在root 的右子树中
当root.val &amp;gt; p.val，则p在root的左子树中


代码
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&amp;gt; 'TreeNode':
        if root.val &amp;lt; p.val and root.val &amp;lt; q...</p><a class="button is-default mt-2 has-text-weight-semibold" href="/%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-04-03-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/fuer4869/imgbed/master/LeetCode_Sharing.png?token=AA76PU6A6YEIQZ4I3A6FHDDAD6GBA" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/%E6%A0%91"><i class="tag post-item-tag">树</i></a><a href="/tags/%E4%B8%AD%E7%AD%89"><i class="tag post-item-tag">中等</i></a><a href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><i class="tag post-item-tag">广度优先搜索</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-04-03-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/">面试题-04-03-特定深度节点链表</a></h2><time class="has-text-grey" datetime="2021-01-20T23:36:19.000Z">2021-01-21</time><p class="is-flex-grow-2 mt-2">

前往此题  

广度优先搜索法用层序遍历能很方便的解这道题。将每层的节点放入队列queue，为每层生成一个链表将节点的值赋值到链表cur中。因为cur在遍历二叉树结束时，它指向的是链表的末尾，所以我们需要在初始化的时候将cur指向链表dummy， 最后将链表dummy放入结果res中
算法思路初始化队列queue, 结果列表res, 初始链表dummy。队列作为遍历的条件，它始终存储着二叉树每层的节点。由于链表最后会走到末尾，所以需要初始化一个dummy来指向它的头节点。层序遍历二叉树，将每层的值赋值到链表中，将链表放入res
代码# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#  ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98-04-03-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/">更多</a></section></article></section><aside class="column is-hidden-mobile is-4-tablet is-3-widescreen"><div style="position: sticky; top: 50px;"><main class="aside-card-container archives-widget is-in-archive-page"><h3>归档</h3><section><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a><span class="archive-list-count">1</span></li></ul></section></main></div></aside></div></article><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fuer4869"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> loannes 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></body></html>