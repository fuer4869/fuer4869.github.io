
<!DOCTYPE html>
<html lang="zh-CN">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="loannes&#39;s blog">
    <title>Archiv: 2015 - loannes&#39;s blog</title>
    <meta name="author" content="loannes">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="loannes&#39;s blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;archives&#x2F;2015&#x2F;index.html">
<meta property="og:site_name" content="loannes&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="loannes">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/%20"
            aria-label=""
        >
            loannes&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/%20"
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Kategorien"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Kategorien</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archiv"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archiv</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Suche"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Suche</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="Über"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Über</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/" target="_blank" rel="noopener" title="Google Plus">
                    
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google Plus</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/profile/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/mailto"
                            title="E-Mail"
                        >
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">E-Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/12/29/%E7%BB%86%E8%B0%88iOS8%E7%9A%84Self-Sizing%20Cells%20/"
                            aria-label=": 细谈iOS8的Self-Sizing Cells"
                        >
                            细谈iOS8的Self-Sizing Cells
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-12-29T11:12:19+08:00">
	
		    29 12月 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>===========================</p>
<p>之前有篇文章介绍了<br>FDTemplateLayoutCell，对于UITableViewCell自动计算高度没有做详细的解释，最近用下来感觉自己不能老是依靠第三方控件，这次返回来讲解下iOS8的Working<br>with Self-Sizing Tableview cells 。</p>
<p>对，我要使用Self-Sizing<br>Cells。虽然有点打脸，但身为一个合格的程序员你必须得学会靠自己来解决这些问题，最起码得理解。如果频繁依靠第三方控件我觉得并不是一个优秀程序员该做的事情。</p>
<h1 id="我要使用Self-Sizing-Cells"><a href="#我要使用Self-Sizing-Cells" class="headerlink" title="我要使用Self-Sizing Cells"></a>我要使用Self-Sizing Cells</h1><hr>
<p>首先有句话要说，这篇文章仅是个人观点，有不同意见的欢迎讨论。<br>都知道Self-Sizing是iOS8才更新的，最近又做了些调查，发现使用iOS8以前的用户占了8%左右。比我去年写的那篇文章iOS8一下的用户少了%2。这里先不详细分析这剩余的8%是什么样的用户，为什么不升级，对公司业务走向有什么影响。</p>
<p>其实个人觉得还是得考虑这么几方面，8%的人中有多少是使用app的，为什么不升级系统。可能这之中有一些不会使用app的中老年人，有只是用来当做电话用的老年人，或者因为手机内存不够而不愿更新的，这是一点。第二点，如果是小公司，在人手不是很足的情况下最好还是不要去支持iOS8以下，不光是这一点，还有其他功能上面都会给开发团队造成大量的维护更新工作。</p>
<h1 id="Self-Sizing-Cells"><a href="#Self-Sizing-Cells" class="headerlink" title="Self-Sizing Cells"></a>Self-Sizing Cells</h1><hr>
<p>在iOS8以前，决定tableviewcell<br>的高度的接口都是<code>tableView:heightForRowAtIndexPath:</code>。也就是说你需要在这个接口中手动计算高度。当你把cell和self-sizing<br>绑定在一起的时候你就可以不必去管这个接口了，不用再去考虑计算这个高度了。我们只需要给<code>estimatedRowHeight</code>一个估算值，然后设置tableview的<code>rowHeight</code>属性为<br><code>UITableViewAutomaticDimension</code>就可以了，接下来就是设置约束了。</p>
<p>只要设置标签与cell的高度保持一定的距离，那么这个约束就会完成cell的self-sizing。值得注意的是估高尽量设置的稍微贴切点，设置的越精确效率就更高。</p>
<p>相关文章:</p>
<p><a href="https://developer.apple.com/videos/" target="_blank" rel="noopener">WWDC 2014 Session 226 What’s New in Table and Collection<br>Views</a></p>
<p><a href="http://useyourloaf.com/blog/self-sizing-table-view-cells/" target="_blank" rel="noopener">Self Sizing Table View<br>Cells</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/12/29/%E7%BB%86%E8%B0%88iOS8%E7%9A%84Self-Sizing%20Cells%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/07/14/iOS8%E6%96%B0%E7%89%B9%E6%80%A7%20UIPresentationController%20/"
                            aria-label=": iOS8新特性 UIPresentationController"
                        >
                            iOS8新特性 UIPresentationController
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-07-14T11:12:19+08:00">
	
		    14 7月 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>================================</p>
<p>先推荐几篇关于UIPresentationController的好文章</p>
<ul>
<li><a href="http://nonomori.farbox.com/post/ios-8-presentation-controller" target="_blank" rel="noopener">iOS8 Presentation<br>Controller</a></li>
<li><a href="http://zappdesigntemplates.com/custom-presentations-using-uipresentationcontroller-swift/" target="_blank" rel="noopener">Custom presentations using UIPresentationController in<br>Swift</a><br>自从iOS8更新之后，swift成为了各个程序员平时议论的焦点，包括我。这几天回顾了下去年的WWDC发现了这次Apple更新了很多好玩的东西，其中我就发现了一个叫<code>UIPresentationController</code><br>以前一直都很想做一个比较酷炫的界面过渡效果，但一直没有花时间去研究，这次正好被我机缘巧合的碰到了就顺手拿来研究了一下。</li>
</ul>
<h3 id="什么是UIPresentationController"><a href="#什么是UIPresentationController" class="headerlink" title="什么是UIPresentationController"></a>什么是UIPresentationController</h3><p>其实从我上面说的话就可以知道<code>UIPresentationController</code>就是专门控制界面之间的过渡效果的类。<br>这是官方文档的原话</p>
<blockquote>
<p>A UIPresentationController object provides advanced view and<br>transition management for presented view controllers.</p>
</blockquote>
<p>意思就是<code>UIPresentationController</code>提供了对view<br>controllers的呈现和移动的管理，<br>你可以通过这个类来对<code>被跳转</code>和<br><code>将要呈现的</code>界面进行管理。你可以让他们缩小变大，翻转可以加上一些其他的动画效果。</p>
<p>早在iOS7的时候其实苹果已经开放了类似的功能<code>UIViewControllerTransitioning</code>，而此次更新主要解决了自适应的问题，以前在<br>Compact<br>的宽度条件下如果要使用<code>popoverPresentationController</code>的话必须先判断iPhone和iPad设备，入下面的代码：</p>
<pre><code>if UIDevice.currentDevice().userInterfaceIdiom == .Pad {
    let popOverController = UIPopoverController(contentViewController: nextVC)
popOverController.presentPopoverFromRect(aRect, inView: self.view,         permittedArrowDirections: .Any, animated: true)
} else {
    presentViewController(nextVC, animated: true, completion: nil)
}</code></pre><p>现在有了<code>UIPresentationController</code>就不需要这样做了。从Size<br>Classes改革了.m文件中全是判断设备的代码之后，这次把这仅存的需要判断设备的代码也清除了，同时你也可以看到相关的判断设备的方法已经被弃用了。</p>
<p>下面就用个实例来说明UIPensentationController是如何使用和工作的吧，就做一个模仿twitter分享效果的例子吧</p>
<h3 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a>UIViewControllerTransitioningDelegate</h3><p>先来看一下<code>UIViewControllerTransitioningDelegate</code><br>我们现在将要呈现的页面中实现<code>UIViewControllerTransitioningDelegate</code>的接口</p>
<pre><code>func presentationControllerForPresentedViewController(presented: UIViewController, presentingViewController presenting: UIViewController, sourceViewController source: UIViewController) -&gt; UIPresentationController? {
    return CustomPresentationController(presentedViewController:presented,presentingViewController:presenting)
}

func animationControllerForDismissedController(dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
    return NormalDismissAnimation()
}
func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? {
   return PresentationAnimation()
}</code></pre><p>其中我对第二第三个接口返回了自定义的动画效果,对第一个接口返回了继承<code>UIPresentationController</code>的类并初始化。</p>
<blockquote>
<p>Initializes and returns a presentation controller for transitioning<br>between the specified view controllers</p>
</blockquote>
<h3 id="UIPresentationController"><a href="#UIPresentationController" class="headerlink" title="UIPresentationController"></a>UIPresentationController</h3><p>先看下<code>UIPresentationController</code>的4个接口</p>
<ul>
<li>presentationTransitionWillBegin</li>
<li>presentationTransitionDidEnd</li>
<li>dismissalTransitionWillBegin</li>
<li>dismissalTransitionDidEnd</li>
</ul>
<p>顾名思义，想要创建一些效果的话就必须在<code>presentationTransitionWillBegin</code>实现,如果在init函数中实现的话会获取不到<code>containerView</code>。</p>
<pre><code>import UIKit

class CustomPresentationController: UIPresentationController {
   lazy var dimmingView:UIView = {
    let view = UIView(frame: self.containerView!.bounds)
    view.backgroundColor = UIColor(red: 0.0, green: 0.0, blue:         0.0, alpha: 0.5)
return view
    }()
override init(presentedViewController: UIViewController,     presentingViewController: UIViewController) {
super.init(presentedViewController: presentedViewController,             presentingViewController: presentingViewController)
}</code></pre><p>这里必须重写init方法，否则上面的四个接口不会执行。</p>
<pre><code> override func presentationTransitionWillBegin() {

        let containerView = self.containerView!
        let presentedView = self.presentedView()!

    //在containerView中加载dimmingView，dimmingView就是在界面过渡中的一个效果
    dimmingView.frame = containerView.bounds
    containerView.addSubview(dimmingView)
    containerView.addSubview(presentedView)
    self.dimmingView.alpha = 0

    //对dimmingView做一个渐变效果
    if let transitionCoordinator = self.presentingViewController.transitionCoordinator() {
        transitionCoordinator.animateAlongsideTransition({(context: UIViewControllerTransitionCoordinatorContext!) -&gt; Void in
            self.dimmingView.alpha = 0.7
            }, completion:nil)
    }
}

override func presentationTransitionDidEnd(completed: Bool) {

}

override func dismissalTransitionWillBegin() {
    if let transitionCoordinator = self.presentingViewController.transitionCoordinator() {
        transitionCoordinator.animateAlongsideTransition({(context: UIViewControllerTransitionCoordinatorContext!) -&gt; Void in
            self.dimmingView.alpha = 0.0
            }, completion:nil)
    }
}

override func dismissalTransitionDidEnd(completed: Bool) {
    if completed {
        self.dimmingView.removeFromSuperview()
    }
}</code></pre><p>对这4个接口分别写上处理dimmingView的逻辑，动画效果基本就做好了。</p>
<h3 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a>UIViewControllerAnimatedTransitioning</h3><p>接下来是2个自定义的动画，其实如果像方便点的话直接把这2个动画写在<code>UIPresentationController</code>里也是可以的。不过为了重用性，我选择把这2个动画拿出来</p>
<pre><code>class PresentationAnimation: NSObject ,UIViewControllerAnimatedTransitioning{

let duration = 0.7

func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -&gt; NSTimeInterval {
    return self.duration
}

func animateTransition(transitionContext: UIViewControllerContextTransitioning) {
    //将呈现的视图
    let presentedView = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!
    let presentingView = transitionContext.viewForKey(UITransitionContextToViewKey)!
    let contrainerView = transitionContext.containerView()!
    //被过渡的视图
    let fromView = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)
    let center = fromView!.view.center


    let pSize = CGSizeMake(presentingView.frame.size.width*0.95, presentingView.frame.size.height*0.95)
    presentingView.frame = transitionContext.finalFrameForViewController(presentedView)
    presentingView.center.y += contrainerView.bounds.size.height
    contrainerView.addSubview(presentingView)



    UIView.animateWithDuration(self.duration, delay: 0.0, usingSpringWithDamping: 1.0, initialSpringVelocity: 0.0, options: .AllowUserInteraction, animations: {
        fromView!.view.frame.size = pSize
        fromView!.view.center = center
        presentingView.center.y -= contrainerView.bounds.size.height
        }, completion: {(completed: Bool) -&gt; Void in
            transitionContext.completeTransition(completed)
            contrainerView.insertSubview(fromView!.view, atIndex: 0)
    })
}</code></pre><p>我对fromView也就是被过渡的视图的宽高缩小到95%的动画效果，在dismiss动画就反过来。</p>
<p>有一点要注意的是当dismiss动画结束之后，fromview会莫名其妙的被移除掉。这个问题很奇怪我也没找到很好的解释，解决方案可以参考stackoverflow上的一篇问答</p>
<p><a href="http://stackoverflow.com/questions/24338700/from-view-controller-disappears-using-uiviewcontrollercontexttransitioning" target="_blank" rel="noopener">“From View Controller” disappears using<br>UIViewControllerContextTransitioning</a></p>
<p>在动画结束后重新加载fromview就可以了。</p>
<pre><code>UIApplication.sharedApplication().keyWindow!.addSubview(fromView.view)</code></pre><p>下面看下效果：</p>
<p>附上源码</p>
<p><a href="https://github.com/fuer4869/UIPresentationController.git" target="_blank" rel="noopener">UIPresentationControllerDemo</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/07/14/iOS8%E6%96%B0%E7%89%B9%E6%80%A7%20UIPresentationController%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/04/14/%E7%94%A8xctool%E6%89%93%E5%8C%85ipa%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0fir%20/"
                            aria-label=": 用xctool打包ipa文件自动上传到fir"
                        >
                            用xctool打包ipa文件自动上传到fir
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-04-14T11:12:19+08:00">
	
		    14 4月 2015
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>================================</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>HomeBrew 环境<br>在这里就不多介绍了，可以看我写的另外一篇<a href="http://fuer4869.github.io/2015/04/14/%E7%94%A8xctool%E6%89%93%E5%8C%85ipa%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0fir/" target="_blank" rel="noopener">Mac安装记录</a>的文章</li>
<li>安装xctool <a href="https://github.com/facebook/xctool" target="_blank" rel="noopener">xctool</a></li>
<li>如何使用xctool</li>
<li>安装fir<br><a href="https://github.com/FIRHQ/fir-cli/blob/master/README.md" target="_blank" rel="noopener">fir.im-cli</a></li>
<li>创建.sh文件（本例用的是sh脚本）,如果想用php语言的就创建.php文件。</li>
<li>自动上传fir</li>
</ol>
<hr>
<h3 id="xctool"><a href="#xctool" class="headerlink" title="xctool"></a>xctool</h3><hr>
<p>xctool<br>是facebook专门对xcode开发的构建工具，在苹果的xcodebuild限制条件种种的环境下很多人都选择了这款工具，并且它是开源的。</p>
<h4 id="如何安装xctool"><a href="#如何安装xctool" class="headerlink" title="如何安装xctool"></a>如何安装xctool</h4><hr>
<pre><code>brew update

brew install xctool</code></pre><p>很方便，这就是为什么要装Homebrew的原因。</p>
<hr>
<p>下面简单介绍下xctool的命令：<br>先输入下面的命令</p>
<ul>
<li>xctool -help</li>
<li>xctool [BASE OPTIONS] clean <code>清理工程,功能等同于Xcode中的clean</code></li>
<li>xctool [BASE OPTIONS] build <code>Xcode中的build</code></li>
<li>xctool [BASE OPTIONS] build-tests [-only TARGET] [-omit<br>TARGET] [-skip-deps]</li>
<li>xctool [BASE OPTIONS] run-tests [-test-sdk SDK] [-only SPEC]<br>[-omit SPEC] [-freshSimulator] [-resetSimulator]<br>[-noResetSimulatorOnFailure] [-freshInstall] [-parallelize]<br>[-logicTestBucketSize N] [-appTestBucketSize N] [-bucketBy<br>BUCKETBY] [-failOnEmptyTestBundles] [-listTestsOnly]<br>[-targetedDeviceFamily FAMILY] [-testTimeout N] [-logicTest<br>BUNDLE] [-appTest BUNDLE:HOST_APP]</li>
<li>xctool [BASE OPTIONS] test [-test-sdk SDK] [-only SPEC]<br>[-omit SPEC] [-skip-deps] [-freshSimulator]<br>[-resetSimulator] [-noResetSimulatorOnFailure] [-freshInstall]<br>[-parallelize] [-failOnEmptyTestBundles] [-logicTestBucketSize<br>N] [-appTestBucketSize N] [-bucketBy BUCKETBY]<br>[-listTestsOnly] [-testTimeout N]</li>
<li>xctool [BASE OPTIONS] archive [-archivePath PATH]<br><code>生成编译文件,也是打包ipa核心命令</code></li>
<li>xctool [BASE OPTIONS] analyze [-only TARGET] [-skip-deps]<br>[-failOnWarnings]<ul>
<li>xctool [BASE OPTIONS] install</li>
</ul>
</li>
</ul>
<p>另外3个测试的暂时不讲。</p>
<h3 id="如何使用xctool"><a href="#如何使用xctool" class="headerlink" title="如何使用xctool"></a>如何使用xctool</h3><h4 id="Base-Options"><a href="#Base-Options" class="headerlink" title="Base Options"></a>Base Options</h4><p>这个参数其实就是选择工程，为什么说是工程而不是项目，xctool很做的十分全面，它不但能帮你编译和清理项目更方便的是它能够帮你测试项目。所以这里需要明确的告诉xctool你要编译哪个工程或者测试哪个工程。具体看下面的命令：</p>
<pre><code>-help                    show help

-workspace PATH          path to workspace---针对workspace项目的命令，如果你的项目集成了cocoapods，那么用这个命令就行了。

-project PATH            path to project----反之这个命令就是对没有集成cocoapods的

-scheme NAME             scheme to use for building or testing ----- scheme用来告诉xctool test 和 build的对象工程名称

-find-target TARGET      Search for the workspace/project/scheme to build the target                      ------也可以根据target名称来找到workspace或者project，但是这个太慢了不建议用来做这次测试，不过可以当做一个搜索工具来用。

-find-target-path PATH   Path to search for -find-target. 同上

-find-target-exclude-pathColon-separated list of paths to exclude for -find-target.

-sdk VERSION             sdk to use for building (e.g. 6.0, 6.1)

-configuration NAME      configuration to use (e.g. Debug, Release)

-jobs NUMBER             number of concurrent build operations to run

-arch ARCH               arch to build for (e.g. i386, armv7)

-toolchain PATH          path to toolchain

-xcconfig PATH           path to an xcconfig

-reporter TYPE[:FILE]    add reporter

-showBuildSettings       display a list of build settings and values

-version                 print version and exit

SETTING=VALUE            Set the build &apos;setting&apos; to &apos;value&apos;</code></pre><p>其他都是些很简单的命令就不做解释了。<br>这里给大家一个小技巧，在编译工程的时候项目中的证书必须使用正确才能编译通过，但是我们的项目证书有时候一直在换的不可能为了编译一次项目再去换证书，这样很麻烦。所以可以在项目中增加个自定义的Configuration,如下图我添加了一个名为DailyBuild的Configuration</p>
<p>![](./用xctool打包ipa文件自动上传到fir _<br>飞奔的蜗牛的博客_files/3344ggg.png)</p>
<p>添加好后会在项目的Target-&gt;Build Setting-&gt;Code<br>Signing中多出一个DailyBuild选项，你可以在这里配置你需要打包的证书，这样就不用一直把证书换来换去了。<br>![](./用xctool打包ipa文件自动上传到fir _<br>飞奔的蜗牛的博客_files/2015-12-22-02.png)</p>
<hr>
<h3 id="编写-sh脚本并且上传到fir"><a href="#编写-sh脚本并且上传到fir" class="headerlink" title="编写.sh脚本并且上传到fir"></a>编写.sh脚本并且上传到fir</h3><p>安装完fir命令行工具后就可以开始编写脚本了</p>
<pre><code><figure class="highlight plain"><figcaption><span>shtest.sh```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">最后在终端中输入命令：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#96;&#96;&#96;.&#x2F;shtest.sh</span></pre></td></tr></table></figure></code></pre><p>然后你就可以去做其他事情了，让它帮你解决接下来的事情吧！</p>
<p>上传成功</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个懒人程序猿繁多的时代中，这种能够帮我们解决很多繁琐工作的工具真是业界良心啊。有句话真没说错，facebook出品必属精品。后面我还稍微研究了下xctool，发现它的测试功能也很强大，比苹果自带的强大不少，log界面也十分清晰。</p>
<p>本来想上传成功之后邮件通知的，查阅资料后本地发送邮件不是很靠谱。之后会尝试看看能不能通过服务器帮我们构建ipa上传和发送邮件。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/04/14/%E7%94%A8xctool%E6%89%93%E5%8C%85ipa%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0fir%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/04/05/%E9%85%8D%E5%90%88Autolayou+SizeClasses%E4%BB%BF%E6%94%AF%E4%BB%98%E5%AE%9D%E9%A6%96%E9%A1%B5%20/"
                            aria-label=": 配合Autolayou+SizeClasses仿支付宝首页"
                        >
                            配合Autolayou+SizeClasses仿支付宝首页
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-04-05T11:12:19+08:00">
	
		    05 4月 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=============================</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><hr>
<p>在开始之前先简单分析下界面。</p>
<p>首页这个界面总共分为四大部分，最上面是扫一扫和付款码两个按钮，接下来一组按钮，再下面是一个轮播视图，最后是另外一组按钮。</p>
<p>其中有2个难点<br>1.配合Autolayout实现四等分按钮<br>2.Scrollview动态修改内部尺寸</p>
<p>这次主要讲的是Autolayout+SizeClasses，能够通过这次练习基本掌握Autolayout配合基本常用控件的特性，所以其他的地方不会讲的很细，而且素材是直接从支付宝8.6.3的ipa中拿的，所以和支付宝还是有些区别的。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><hr>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>第一部分其实很简单，其实就是各自的横向坐标位于界面的左半边和右半边的中心,纵向坐标则是与背景底部呈固定距离。</p>
<p>我选择的是把第一部分的背景分割成2个部分，左半边和右半边，这样方便2个按钮的居中。\</p>
<p>在Storyboad强大的辅助线的帮助下，这个部分没有任何难处。</p>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>在做第二部分之前，可以先看一下<a href="http://fuer4869.github.io/2015/09/27/%E4%BD%BF%E7%94%A8Autolayout%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6%E7%9A%84ScrollView/" target="_blank" rel="noopener">这篇文章</a>,因为这里要涉及到ScrollView的内部自适应问题，这里就不再赘述了。</p>
<p>这里先来讲下四等分大致实现思路，要实现四等分首先要满足以下几个条件，</p>
<ol>
<li>四个按钮顶部对齐</li>
<li>四个按钮之间的间距相等</li>
<li>四个按钮相互之间必须宽和高相等</li>
</ol>
<p>稍微讲一下这个按钮中的一些细节，因为这个本身是可点击的，一般情况是一个view里面放一个和view同样大小的透明button，这里因为还没涉及到点击，所以我没把按钮放进去，主要看一下icon和小标题是如何约束的。其实UIImageView和UILabel的约束都有一些特性，因为它本身是有内容的，UIImageView本身有图片在内，UILabel也有文字填充进去了，所以它的高度和宽度已经计算好了不用我们再另外进行约束，我们只要确定它的位置就可以了。所以我指给了这个icon添加了2条约束，横向居中对齐和底部与下面的”余额宝”之间保持8px的间距，”余额宝”的约束同上，底部与view的底部的间距为8。因为考虑到适配其他设备，所以我为view加了个比例，这样view的高度就不用做固定值了。</p>
<p>这里我为了方便复制，为第一排单独做了个大view，然后把4个刚刚制作好的view放在这个大view中。链接好其他约束之后大致的效果就出来了。大view的宽度跟设备宽度一致，撑满整个屏幕就行。但是它的高度不能做成固定高度，否则适配到小尺寸屏幕上会变的很丑，所以我们要把view做成自适应内部高度。做法很简单，只要让内部的按钮顶部和底部与view的距离保持固定就可以了。</p>
<p>view的约束</p>
<p>第二部分完成效果图：</p>
<h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><p>第三部分是一个滚动轮播视图，这个部分光靠Storyboard无法实现，还得需要代码，不在本文讨论范围内，就先不做了。其实要做的话也很简单，只要在Storyboard中放一个ScrollView，然后在实现文件当中去创建图片放入scrollview中，做好约束就可以了。轮播效果只要加个定时器，让ScrollView自动滚动。</p>
<h3 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h3><p>第四部分UI效果和第二部分一样，值得注意的是这里因为是本页面的最后一个元素，也就是能确定整个ScrollView内容大小的关键。所以在做约束的时候要让ScrollView中的view和这个部分的底部保持距离，这样才能确定ScrollView的内容。</p>
<p>###总结<br>对于初学Autolayout的同学来说，刚开始做四等分的时候可能会有点乱，看似简单其实里面的逻辑关系还是有点复杂的，既要让4个按钮保持等宽高，并且还要考虑到其他设备。所以个人建议可以如果觉得到后面约束会被自己弄乱的话可以按照这里的方法，把这些空间分组一组一组来做约束，这样会轻松很多。在这次练习当中我又再一次体会到了自适应ScrollView在Autolayout中的强大之处。</p>
<p>PS:在设计界面的时候会遇到整个画板高度不够的情况，我这里用了很笨的方法，直接硬塞然后调整右边的坐标来做约束的，如果有更好的建议欢迎指出！</p>
<p><a href="https://github.com/fuer4869/AutoLayoutZFB" target="_blank" rel="noopener">项目下载地址</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/04/05/%E9%85%8D%E5%90%88Autolayou+SizeClasses%E4%BB%BF%E6%94%AF%E4%BB%98%E5%AE%9D%E9%A6%96%E9%A1%B5%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/03/25/%E8%AE%B2%E8%AE%B2iOS%E7%9A%84URL%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F%20/"
                            aria-label=": 讲讲iOS的URL加载系统"
                        >
                            讲讲iOS的URL加载系统
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-03-25T11:12:19+08:00">
	
		    25 3月 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <hr>
<p>=============</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>最近打算开始做一些进阶训练，所以避免不了要去触碰这些以前想都没想过的东西。现在要做的第一步就是能够比以往更深入的去学习一些知识，这两天花功夫研究了下iOS的URL加载系统，听起来好像很陌生，但是这个东西是我平常用的最多比如SDWebImage，AFNetworking都用到这些知识。</p>
<h3 id="URL加载系统"><a href="#URL加载系统" class="headerlink" title="URL加载系统"></a>URL加载系统</h3><hr>
<p>URL加载系统就是由一套类和协议组成的，这个加载系统的作用就是从URL中加载内容，给服务器上传数据，管理cookies的存储，控制响应数据的缓存以及处理证书的存储和验证等，还可以定制协议扩展。看到这里应该对URL加载系统有一定的了解了吧，知道它到底是干嘛的，在我们平时使用那些涉及到整个系统的控件的时候也知道了它到底做了些什么事情。</p>
<p>接下来再继续深入研究下去，关于上面提到的URL加载系统的功能，有下面几个辅助类是专门负责这些事情的：</p>
<h3 id="URL-Loading"><a href="#URL-Loading" class="headerlink" title="URL Loading"></a>URL Loading</h3><p>在URL加载系统中大部分使用过的类都允许你的app去从网络资源中检索URL的内容，这也是你使用URL加载系统的第一步操作，拿到数据后你就可以把它存储到本地。</p>
<p>在iOS7之后，如果你想执行URL请求的话那么NSURLSession肯定是首选的API，它与NSURLConnection相比较下有一个很明显的优势，详情可以看这几篇文章：</p>
<ul>
<li><a href="http://objccn.io/issue-5-4/" target="_blank" rel="noopener">从 NSURLConnection 到 NSURLSession</a></li>
</ul>
<p>如果是iOS7以前的版本，那还是乖乖用NSURLConnection吧。</p>
<p>PS:目前AFNetworking中的网络加载部分已经换成NSURLSession这套API了，而SDWebImage还是使用NSURLConnection。</p>
<h3 id="Fetching-Content-as-Data-In-Memory"><a href="#Fetching-Content-as-Data-In-Memory" class="headerlink" title="Fetching Content as Data (In Memory)"></a>Fetching Content as Data (In Memory)</h3><p>请求完URL之后接下来就是从URL中获取数据，这就是第二步。</p>
<ul>
<li>如果是简单的请求，只需要使用NSURLSession<br>API就能从NSURL对象或者NSData对象或者硬盘上的文件中获取内容。</li>
<li>如果是复杂的请求，比如请求上传数据，这个时候需要提供一个NSURLRequest对象来当做NSURLSession或者NSURLConneciton的媒介。</li>
</ul>
<p>关于如何使用NSURLSession可以查看官方文档：<a href="http://fuer4869.github.io/2016/03/25/%E8%AE%B2%E8%AE%B2iOS%E7%9A%84URL%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">Using<br>NSURLSession</a></p>
<h4 id="Downloading-Content-as-a-File"><a href="#Downloading-Content-as-a-File" class="headerlink" title="Downloading Content as a File"></a>Downloading Content as a File</h4><p>除了从URL中获取数据之外还有下载文件：</p>
<ul>
<li>如果是简单的请求，你可以使用NSURLSession<br>API来从NSURL对象或者NSData对象或者硬盘上的文件中获取数据。</li>
<li>如果是复杂的请求，类似请求上传数据，就需要提供一个NSURLRequest对象来给NSURLSession或者NSURLDownload来当媒介。</li>
</ul>
<p><strong>直接用NSURLDownload或者NSURLSession创建的实例它是不会做缓存的，这个时候你必须在使用完NSURLConnection<br>或者 NSURLSession之后把数据存储到本地。</strong></p>
<p>但是光是有上面2个功能是完全不够的，可能在我们的业务拓展之后还需要增加更多的特性。</p>
<h3 id="Helper-Classes"><a href="#Helper-Classes" class="headerlink" title="Helper Classes"></a>Helper Classes</h3><p>URL加载类会使用两种辅助类来提供额外的元数据—一个是数据请求本身(NSURLRequest)另外个是服务器的响应(NSURLResponse)。比方说如果你要做一个复杂的请求，你就需要用NSURLRequest来对元数据进行封装，同样如果是复杂的服务器响应的话也就需要NSURLResponse来封装。</p>
<h3 id="URL-Requests"><a href="#URL-Requests" class="headerlink" title="URL Requests"></a>URL Requests</h3><p>一个NSURLRequest对象封装了一个URL和一些协议属性。还指定了关于使用本地缓存数据的策略，何时使用NSURLConnection或者NSURLDownload,并且提供了一个设置连接超时的接口。</p>
<p>有些协议提供协议属性。比方说，Http协议向NSURLRequest添加了返回HTTP请求体，请求头和转换接口的接口。当然它也对NSMutableURLRequest添加了修改值的接口。</p>
<h4 id="Response-Metadata"><a href="#Response-Metadata" class="headerlink" title="Response Metadata"></a>Response Metadata</h4><p>向服务器请求所返回的响应主要被视为2个部分：元数据描述的内容和内容数据本身。它的超类NSURLResponse能够提供额外的元数据，比如，NSHTTPURLResponse能够存储从web<br>server返回的headers和status<br>code。那些通用的协议会被NSURLResponse类封装然后构成MiME类型。</p>
<p>比较重要的一点是：只有响应的元数据会被存在一个NSURLResponse对象中。各种URL<br>Loading类都通过block或者这个对象的delegate对你的app提供响应的数据。</p>
<p>一个NSCacheURLResponse实例封装了一个NSURLResponse对象，URL内容数据和一些额外的信息提供给你的app。</p>
<h4 id="Redirection-and-Other-Request-Changes"><a href="#Redirection-and-Other-Request-Changes" class="headerlink" title="Redirection and Other Request Changes"></a>Redirection and Other Request Changes</h4><p>当然URL重定向功能也是不可少的，这里先不详细解释什么是URL重定向。你在浏览器中输入<a href="http://www.google.xn--comhttp-oo5kl3uj8aq9hgv6poy6a2ke//www.google.com.hk" target="_blank" rel="noopener">http://www.google.com后会自动跳转到http://www.google.com.hk</a><br>这个就是URL重定向。</p>
<p>某些协议，类似HTTP,会给服务器提供一个方法来告诉你的app内容已经转移到其他URL中了。这个时候URL<br>loading classes<br>能够修改委托。如果你的app提供一个合适的委托接口，那么你的app将会立即决定接下来该怎么做，是返回新的响应体还是返回一个error。</p>
<h4 id="Authentication-and-Credentials"><a href="#Authentication-and-Credentials" class="headerlink" title="Authentication and Credentials"></a>Authentication and Credentials</h4><p>有些服务器会对部分内容限时权限，需要用户通过某些证书来进行认证-一份客户证书，用户名密码等都是为了获得授权。<br>证书也被用来获得其他方向（其他URL）的信任。<br>URL<br>加载系统会提供证书mode类并且在证书安全的情况下保护这块区域。你的app能够制定这些证书所持有的请求，持续时间为app的启动或者永久存储在用户的钥匙串中。<br>证书会保持存储在用户的钥匙串中并且分享给其他app。</p>
<p>NSURLCredentialStorage<br>类管理证书的存储和提供一个为提供证明与NSURLCredential对象对应的NSURLProtectionSpace对象的绘图。</p>
<p>NSURLAuthenticationChallenge 类<br>封装了NSURLProtocol去验证请求的必要信息：一份计划证书，涉及的保护区域，有必要的协议验证所产生的错误或者响应，和尝试证明的操作次数。NSURLAuthenticationChallenge实例也可以指定对象去初始化验证。而最初的对象，和sender的提交一样，必须遵从NSURLAuthenticationChallengeSender协议。</p>
<p>NSURLAuthenticationChallenge实例可以被NSURLProtocol的子类使用来告诉URL<br>loading system<br>证明是有必要的。他们也提供了NSURLConnection和NSURLDownload的delegate来减轻定制授权操作的难度。</p>
<p>####Cache Management<br>URL loading<br>system提供了一个在app里结合硬盘和内存的方案来减少依赖网络连接来获取数据的方法，并且提供了更快的读写响应。cache会去询问NSURLConnection按照缓存策略所实例化的NSULRequest对象。</p>
<p><strong><em>缓存策略有很多种，具体情况具体选择，这里简单介绍下：</em></strong></p>
<ul>
<li><p>NSURLRequestUseProtocolCachePolicy — NSURLRequest默认的cache<br>policy，使用Protocol协议定义。</p>
</li>
<li><p>NSURLRequestReloadIgnoringCacheData — 忽略缓存直接从原始地址下载。</p>
</li>
<li><p>NSURLRequestReturnCacheDataElseLoad —<br>只有在cache中不存在data时才从原始地址下载。</p>
</li>
<li><p>NSURLRequestReturnCacheDataDontLoad —<br>只使用cache数据，如果不存在cache，请求失败;用于没有建立网络连接离线模式;</p>
</li>
<li><p>NSURLRequestReloadIgnoringLocalAndRemoteCacheData —<br>忽略本地和远程的缓存数据，直接从原始地址下载，与NSURLRequestReloadIgnoringCacheData类似。</p>
</li>
<li><p>NSURLRequestReloadRevalidatingCacheData —<br>验证本地数据与远程数据是否相同，如果不同则下载远程数据，否则使用本地数据。</p>
</li>
</ul>
<p>然后这个NSURLCache类主要是提供了配置缓存大小和在磁盘中的位置的接口。也就是说它是对缓存进行配置的对象。它也提供了接口来管理一大堆的NSCachedURLReponse对象。</p>
<p>一个NSCachedURLReponse对象对NSURLResponse对象和URL的数据进行了封装。而且NSCachedURLReponse也提供了一个用户信息的字典，这样可以使app能自由的缓存任何数据。</p>
<h4 id="Cookie-Storage"><a href="#Cookie-Storage" class="headerlink" title="Cookie Storage"></a>Cookie Storage</h4><p>由于HTTP协议的特性，客户端通常使用cookies来为URL请求返回的数据提供长时间的存储。<br>URL loading<br>system提供接口来管理和创建cookies，发送cookies相当于HTTP请求的一部分，还有当服务器产生响应之后的接收cookies工作。</p>
<p>OSX和iOS<br>提供了NSHTTPCookieStorage类，依次为一系列NSHTTPCookie对象提供管理接口。</p>
<h4 id="Protocol-Support"><a href="#Protocol-Support" class="headerlink" title="Protocol Support"></a>Protocol Support</h4><p>URL loading system 天生支持http,https,file,ftp和data协议。但是，URL<br>loading<br>system也允许你的app去注册你自己的类来支持额外的应用层网络协议。你也能对URL请求和URL响应对象添加协议特性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在还没深入了解URL Loading System前一直以为URL<br>loading就是iOS的整个URL加载系统，没想到里面还有那么多我不知道的内容。</p>
<ol>
<li><p>先来说说它的NSURL<br>loading部分，NSURLSession,NSURLConnection,NSURLDownload它们都具备了从NSURL中获取数据和内容的功能，NSURLRequest和NSURLResponse分别是请求和响应的对象形式，如果涉及到复杂的请求或者响应的时候就需要用到这2个对象。<br>在iOS7以前一直都是NSURLConnection的天下，iOS7之后苹果推出了更为优秀的NSURLSession。详情可参考：<br><a href="http://objccn.io/issue-5-4/" target="_blank" rel="noopener">从 NSURLConnection 到 NSURLSession</a></p>
</li>
<li><p>在协议方面，URL loading<br>system支持我们可以写自定义网络协议，NSURLProtocol就是为这个而存在的。</p>
</li>
<li><p>我们不可能一直都依赖网络来获取数据，而URL loading<br>system能够在请求数据的时候根据缓存策略采取不同的行动来解决这个问题。</p>
</li>
<li><p>NSHTTPURLResponse存储了从web server返回的headers和status code。</p>
</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/03/25/%E8%AE%B2%E8%AE%B2iOS%E7%9A%84URL%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/03/22/%E4%BD%BF%E7%94%A8Autolayout%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6%E7%9A%84ScrollView%20/"
                            aria-label=": 使用Autolayout实现动态高度的ScrollView"
                        >
                            使用Autolayout实现动态高度的ScrollView
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-03-22T11:12:19+08:00">
	
		    22 3月 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=============================</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>自从改用Autolayout作为界面布局的主要核心技术之后一直都没有做这方面的技术总结，最近打算写一系列关于Autolayout的文章，从比较基础的界面到复杂的界面都会去写，就当做是Autolayout的教程吧。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><hr>
<ol>
<li>首先你必须得先了解基本的Autolayout的使用方法和特性。</li>
<li>理解ScrollView在Autolayout中的特别之处。</li>
</ol>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><hr>
<ol>
<li>通过Autolayout实现ScrollView的动态布局。</li>
<li>实现简单的动态界面，并且能够让ScrollView在各种设备上正常运行。</li>
<li>步骤简单明确，不需要大量的布局代码。</li>
</ol>
<p>知道了自己要做什么之后就开始接下来的Autolayout实践过程吧。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><hr>
<p>首先创建一个支持Size Classes的界面,一般都选择Compact/Regular。</p>
<p>添加一个Scrollview到ViewController的Container<br>View(也就是图中的View)中并且填满整个界面，然后添加上，下，左，右的约束。现在在添加一个UIView到Scrollview中同样撑满整个ScrollView，然后以Scrollview为父容器添加上下左右的约束，添加完成后会发现还是会有警告</p>
<p>它提示我们ScrollView还未确定它的contentwidth和contentheight，这个问题就是在之前讲到的一个点，scrollview有一个特性就是当你使用autolayout确定了它的坐标的宽高是不够的，必须还要确定它的contentsize。那既然刚刚放入的UIView是ScrollView的子容器，那么它就有确定ScrollView的contentsize大小的功能，接下来我们要做的就是确定这个UIView的宽和高。</p>
<p>现在我们让ScrollView中的View与Container View等高，与Scroll View等宽。</p>
<p>接下来我们创建一个固定高度的界面，这个界面内容的高度是超过iPhone4的屏幕宽度的，我们要在不管理ScrollView的contentsize的情况下让ScrollView自动适配。</p>
<p>我在界面中添加了一个label(toplabel)，一个棕色的uiview(colorview)，一个底部的label(bottomlabel)</p>
<ul>
<li>toplabel<ul>
<li>距container view的顶约束：35pt</li>
<li>位于container view横向居中的约束</li>
<li>底部约束与colorview的顶部：Standard</li>
</ul>
</li>
<li>colorview<ul>
<li>顶部约束与toplabel的底部：Standard</li>
<li>left:8</li>
<li>right:8</li>
<li>底部约束与bottomlabel的顶部:Standard</li>
</ul>
</li>
<li>bottomlabel<ul>
<li>顶部约束与colorview的底部：Standard</li>
<li>left:8</li>
<li>right:8</li>
<li>bottom:Standard</li>
</ul>
</li>
</ul>
<p>上面是2张模拟器的效果图，一张是iPhone4的，另外一张是iPhone6的效果图。我们可以看到刚刚我们制作的界面已经完美适配成功了，由于本人水平有限不会做gif图，所以效果不是很明显。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>适配Scrollview的过程中只要搞懂了Scrollview中有一个特性，那就是需要让编译器知道Scrollview的contentsize，只有知道了这个才能够做好适配，接下来的适配工作都是围绕着这点出发的，相信知道了这一点之后的你只要稍加思考就能够轻松驾驭Scrollview的适配。<br>而且使用Autolayout制作界面会比用绝对坐标方便很多也快很多，也不容易出错。刚刚做的适配根本就没有写一句代码就做到了完美适配，是不是很方便。希望越来越多的人能喜欢上Autolayout</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/03/22/%E4%BD%BF%E7%94%A8Autolayout%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6%E7%9A%84ScrollView%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/03/17/%E5%88%9D%E6%8E%A2Size%20Classes%E7%AC%94%E8%AE%B0%20/"
                            aria-label=": 初探Size Classes笔记"
                        >
                            初探Size Classes笔记
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-03-17T11:12:19+08:00">
	
		    17 3月 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>====================</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>自从苹果推出了iPhone6和plus，宣布苹果正式进入大屏时代。不单单设计师哭了，连我们这些苦逼的工程师也跟着要一起哭。因为本身iOS不需要和安卓那样考虑自适应的问题，原本这个只有做android的同学才会碰到的问题现在也终于轮到我们iOS开发工程师了。而且相信正在赶项目的同学，听到此消息估计是一口老血喷在屏幕上了。那我们该如何轻松的适配如此多的尺寸呢？</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><hr>
<p>查阅了官方文档，苹果给出了这样一个解决方案。</p>
<blockquote>
<p>Use size classes to enable a storyboard or xib file to work with all<br>available screen sizes. This enables the user interface of your app to<br>work on any iOS device.</p>
</blockquote>
<p>Size Classes<br>单从名字上我是这么理解的，apple把所有设备的尺寸分成了几种类型。以前我们一个页面需要创建多个xib来适配，现在我们不需要那么做了。这次iOS8的更新可以说是在设计界面上的一大突破。从iOS7更新的Auto<br>Layout之后，我们设计界面从以前的绝对坐标这种概念转换成了约束来指定视图的坐标和大小，致使我们不必再考虑设备的具体尺寸和方向了。但从iPhone6等新设备出来之后，我们不得不考虑Auto<br>Layout这种布局方案在不同设备上的体验还是有一些缺点的。可能你正在设计一个iPhone6的界面，但是你用的是一张4-inch的xib，这个时候你会明显的发现这样的界面完全设计不出你想要的效果。这个时候我们就需要用到Size<br>Classes了。<br>Size Classes有两种类型，compact（紧凑）和 regular（正常）。</p>
<p>这样我们可以根据官方文档给出的介绍，可以针对不同的设备不同的方向采用不用的Size<br>Class。\</p>
<p>看过这2张图之后相信能够很清晰的了解我们该如何使用Size<br>Classes了。总的来说iPad两个方向都是Regular，而iPhone的话，竖的是width-Compact,height-Regular。横向的话因为iPhone<br>6plus的屏幕尺寸比较特殊，所以就按照它的尺寸选择width-Regular，height-Compact。那也就是说Auto<br>Layout本身已经解决了我们在设计界面过程中确定视图的尺寸和坐标，而Size<br>Classes帮我们解决了Auto<br>Layout在布局方案对于不同设备的缺点也解决掉了，想想一套布局就可以完美解决所有设备的适配问题，那酸爽！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>在iOS7时代，以为Auto<br>Layout会是设计界面的神器，没想到更新到了iOS8之后更新了Size<br>Classes这个革命性的功能。起初发布会一结束还被做android的同事开过玩笑，你们做iOS也来感受下我们做android的苦的时候Apple更新了如此人性化的功能。相信这个功能绝对是以后开发界面的核心！</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/03/17/%E5%88%9D%E6%8E%A2Size%20Classes%E7%AC%94%E8%AE%B0%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/03/16/%E4%BD%BF%E7%94%A8Cocoapods%E5%81%9AiOS%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%20/"
                            aria-label=": 使用Cocoapods做iOS项目依赖管理"
                        >
                            使用Cocoapods做iOS项目依赖管理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-03-16T11:12:19+08:00">
	
		    16 3月 2015
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E7%AE%A1%E7%90%86/">管理</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=====================</p>
<p><strong>文档版本更新说明</strong></p>
<p>2015-03-30 初稿v1.0​</p>
<p>最近项目积累的越来越多，也开始更加注重提升自己的开发效率，而且平时在做项目的时候越来越发觉得每次导入第三方库尤其浪费时间，所以特地使用pods来管理这些第三方库，好让我在开发时少花些时间在这种没有任何意义的事情上。</p>
<p><strong>CocoaPods简介</strong></p>
<p>CocoaPods项目的源码在Github上管理，所以多多推荐大家使用Github。该项目开始于2011年8月12日，经过多年发展，现在已经成为iOS开发过程中不可缺少的依赖管理标准工具。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间​。</p>
<p><strong>CocoaPods的安装和使用介绍​</strong></p>
<p>安装方式很简单, 因为Mac下都自带ruby，使用ruby的gem命令即可下载安装：<br>￼$ sudo gem install cocoapods</p>
<p><code>$ pod setup</code></p>
<p>然后因为gem使用的时国外亚马逊的服务器，所以被墙了，我们只要把ruby源改成淘宝的源就行：</p>
<p><code>gem sources --remove https://rubygems.org/</code></p>
<p><code>gem sources -a http://runy.taobao.org/</code></p>
<p><code>gem sources -l​</code></p>
<p><strong>使用pods</strong></p>
<p>首先得在项目中创建Podfile文件</p>
<p><strong>touch Podfile</strong></p>
<p>​然后在Podfile文件中编辑</p>
<p><code>platform :ios, &#39;7.0&#39;</code></p>
<p><code>pod &#39;RegexKitLite&#39;, &#39;~&gt; 4.0&#39;</code></p>
<p><code>pod &#39;ASIHTTPRequest&#39;, &#39;~&gt; 1.8.2&#39;</code></p>
<p>编辑完成后</p>
<p><strong>安装pods</strong></p>
<p><code>pod install</code></p>
<p>这里有可能还会遇到被墙的问题，​因为intall这个命令执行后，pod会首先对自己进行update，所以会一直卡在Analyzing<br>dependencies 这个状态。</p>
<p>这个时候只要使用下面这个命令</p>
<p><code>pod install --verbose --no-repo-update</code></p>
<p>绕过pod的自更新就行了。包括以后更新Podfile文件后，想更新本地的pods，使用这个命令</p>
<p><code>pod update --verbose --no-repo-update</code></p>
<p>等安装完成后项目中会多几个文件，会看到xxx.workspace这个文件，直接打开它就行了。<br>这个时候项目中会多了个叫Pods的工程，并且已经集成了你所需要的第三方库了。不用管它，直接使用自己的工程就可以了。</p>
<p>暂时就写这么多，接下来有时间会继续深入研究cocoapods</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/03/16/%E4%BD%BF%E7%94%A8Cocoapods%E5%81%9AiOS%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/03/04/UITableViewCell%E8%87%AA%E5%8A%A8%E8%AE%A1%E7%AE%97%E9%AB%98%E5%BA%A6%E4%BC%98%E5%8C%96%20/"
                            aria-label=": UITableViewCell自动计算高度优化"
                        >
                            UITableViewCell自动计算高度优化
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-03-04T11:12:19+08:00">
	
		    04 3月 2015
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=======================</p>
<p>之前有段时间一直被UITableViewCell的自动计算高度困扰着，查阅过很多资料试过很多种方法，有些勉强能用，有些计算高度不是很稳定会有错误，有些方法太过复杂影响开发效率,再加上苹果的2次发布会推出了2次针对UITableViewCell自动计算高度的改进，但效果都不是很好。所以这次正好有空就在这里统一整理出来，做一次总结，找出我个人觉得目前最好的方法出来。</p>
<p>在这之前我做过一些调查，发现iOS7和iOS6的市场占有比还是有一点的，这个是iOS9发布三周后的数据</p>
<p>发现现在还使用iOS7和iOS6的还是蛮多的，占了10%，所以接下来要做的适配起码要兼容iOS7甚至兼容iOS6。</p>
<h3 id="estimatedRowHeight"><a href="#estimatedRowHeight" class="headerlink" title="estimatedRowHeight"></a>estimatedRowHeight</h3><p>这个是在iOS7发布会上推出的一个UITableView的属性：</p>
<blockquote>
<p>If the table contains variable height rows, it might be expensive to<br>calculate all their heights when the table loads. Using estimation<br>allows you to defer some of the cost of geometry calculation from load<br>time to scrolling time.</p>
</blockquote>
<p>官方文档是这么解释这个属性的。</p>
<p>一开始以为这个方法好像蛮有道理的，但仔细一想其实这个方法并不好。首先我们给了tableview一个估高确实能减少一部分开销，在tableview初次加载的时候没有对每个cell的高度去计算，它会对没出现的cell做估算，给了它们一个估算值，然后通过这个估算值计算出contentsize，从而决定tableview是否可以滑动以及滚动条的长度。<br>但是经过我几次测试之后我发现了几个很重要的问题，就是当tableview在持续滚动的时候它会去不断的重新计算cell的高度，因为这个时候需要精确计算了，所以你会发现tableview的滚动条的长度会在不停的跳动，并且下面这个回调函数在不断的被执行。</p>
<p>对的，这部分的开销一样很大，并且旁边的滚动条的跳动的情况十分影响体验。这次iOS7的改动并不是十分完美，纰漏之处还是很明显的，这也是我不使用这个方法的原因。</p>
<h3 id="self-sizing-cell"><a href="#self-sizing-cell" class="headerlink" title="self-sizing cell"></a>self-sizing cell</h3><p>iOS8 WWDC 中推出了 self-sizing cell 的概念，旨在让 cell<br>自己负责自己的高度计算，使用 frame layout 和 auto layout 都可以享受到：</p>
<p>看来苹果也确实发现了iOS7的estimatedRowHeight<br>的问题确实太明显了，果然还是在iOS8的时候解决了这个问题。这个方法推出后我也用了一段时间，虽然它对约束的要求及其严格，在使用的时候需要先确定内容的宽度，所以会用到这个<code>preferredMaxLayoutWidth</code>，但是如果你的约束稍微有点问题的话，这个方法就会返回0造成计算错误。<br>但是这个新特性的要求是iOS8，低于iOS8是不能使用这种功能的，那也就是说我们在开发过程中还要另外再做一套针对低于iOS8系统的方法，也就是上面那个方案。一次适配要写2套代码，太麻烦，所以我个人认为也不是最好的方案。</p>
<h3 id="UITableView-FDTemplateLayoutCell"><a href="#UITableView-FDTemplateLayoutCell" class="headerlink" title="UITableView + FDTemplateLayoutCell"></a>UITableView + FDTemplateLayoutCell</h3><p>这个是我在逛github时无意发现的，抱着好奇的态度看了下介绍发现出乎意料的满足了我现在对自动计算UITableViewCell高度的所有需求，能够解决我之前提到的所有困惑。抱着试一试的态度fork下来简单使用了下，确实解决了算高的问题，滑动也十分流畅，同时也支持iOS6。<br>其实它主要是综合了以前3个版本的计算高度的优点，既有一个单独计算cell高度的TemplateLayourCell,也有不影响cell动态变化的自动缓存机制和自动缓存清理机制，也有iOS8的self-sizing的特性。</p>
<p>总结：据可靠数据统计，使用该工具之后再效率上面也有了明显的提升，因为使用了预缓存的机制大大缩短了计算高度的所消耗的时间。使用方法完全整合了iOS6，iOS7，iOS8三中计算高度的优点并做了缓存的优化，使用方法也很简单不会有想iOS8那种对约束十分严格的情况出现，并且支持的最低系统是iOS6.所以本人还是很提倡使用这个工具的，并且该工具的开发者是著名的sunnyxx,相信不会突然烂尾不管这个项目，肯定还会持续更新维护项目，完全可以放心使用。</p>
<p>github：<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a></p>
<p>使用 cocoapods：</p>
<pre><code>pod search UITableView+FDTemplateLayoutCell</code></pre>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/03/04/UITableViewCell%E8%87%AA%E5%8A%A8%E8%AE%A1%E7%AE%97%E9%AB%98%E5%BA%A6%E4%BC%98%E5%8C%96%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2015/02/16/%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93podspec%20/"
                            aria-label=": 使用Cocoapods创建私有库podspec"
                        >
                            使用Cocoapods创建私有库podspec
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2015-02-16T11:12:19+08:00">
	
		    16 2月 2015
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/%E7%AE%A1%E7%90%86/">管理</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=======================</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>最近忽然有种莫名的想自己做点开源项目的想法，再加上自己平时积累的东西越来越多，时候后把这些东西整理出来分享给大家。</p>
<p>之前有写过一篇<a href="http://fuer4869.github.io/2015/02/25/%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93podspec/" target="_blank" rel="noopener">如何使用Cocoapods的文章</a>,之前查阅过它的文档，发现它还有个更神奇的功能，你可以通过podspec创建自己的私有库，对自己的库进行管理和维护，同时能上传到cocoapods,通过审核后就能使用cocoapods安装自己的库。</p>
<p><strong>如何创建并使用podspec</strong></p>
<p>本文章的前提是已经有git和cocoapods环境的前提下，如果没有可查看<a href="http://fuer4869.github.io/2015/02/25/%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93podspec/" target="_blank" rel="noopener">这篇文章</a>。<br>接下来我们要做的有以下几点：</p>
<ol>
<li>创建私有的 <code>Spec Repo</code></li>
<li>创建带有pod的工程项目</li>
<li>编辑podspec文件，同时创建pod项目相关的github项目</li>
</ol>
<p><strong>创建私有的Spec Repo</strong></p>
<p>什么是Spec<br>Repo？按照我的理解它就是一个存储pods的容器，相当于是一个git仓库的remote端。</p>
<pre><code>.
├── Specs
    └── [SPEC_NAME]
        └── [VERSION]
            └── [SPEC_NAME].podspec</code></pre><p>在创建本地私有Spec<br>Repo仓库前，你首先得创建一个与工程相对应的git仓库，并且创建协议文件License（在创建项目的时候可以勾选，一般选择MIT格式）。</p>
<p>创建完git仓库后</p>
<pre><code>pod repo add GKit https://github.com/fuer4869/GKit.git</code></pre><p>cocoapods 已在 <code>~/.cocoapods/repos</code>创建好项目,私有Sepc<br>Repo已经创建好了。接下来要做的就是创建整个的pod项目。</p>
<p><strong>创建pod项目工程文件</strong></p>
<p>创建pod项目有2种方式，一种是你自己本身已经有项目并且有git版本控制环境的话就无需创建pod项目工程了。这里主要讲的还是你还没有一个自己的pod项目的情况下，你改如何创建工程文件。<br>ps：建议执行这个过程的时候先翻墙，否则创建项目过程会很慢。</p>
<p>首先cd到你需要创建项目的路径</p>
<pre><code>$ pod lib create GKit</code></pre><p>之后它会问你几个问题：</p>
<ol>
<li>是否需要example，也就是例子工程文件。</li>
<li>选择一个测试框架</li>
<li>是objectC还是swift</li>
<li>是否基于view测试</li>
<li>类的前缀</li>
</ol>
<p>这个按照具体情况具体选择。之后它就会自动帮你创建项目，过程需要点时间，因为网络的关系，翻墙之后会快很多。</p>
<pre><code>$ tree GKit -L 2
GKit
├── Example
│   ├── GKit
│   ├── GKit.xcodeproj
│   ├── GKit.xcworkspace
│   ├── Podfile
│   ├── Podfile.lock
│   ├── Pods
│   └── Tests
├── LICENSE
├── Pod
│   ├── Assets
│   └── Classes
├── GKit.podspec
└── README.md

9 directories, 5 files</code></pre><p>这是整个工程的目录介绍。</p>
<p><strong>上传到远端仓库</strong></p>
<p>接下来我们要做的就是把项目推送到远端库中。并且设置tag，因为podspec文件如果要获取git版本控制需要tag号，否则无法通过验证。</p>
<pre><code>$ git add .
$ git commit -s -m &quot;Initial Commit&quot;
$ git remote add origin https://github.com/fuer4869/GKit.git
$ git push origin master</code></pre><p>打上标签tag</p>
<pre><code>$ git tag -m &quot;first commit&quot; 0.1.0
$ git push --tags</code></pre><p>然后就可以编辑podspec文件了，很简单的一个步骤，以下都是必填项：<br>这里面唯一要注意的是source_files，public_header_files,这里的路径是相对podspec文件的位置来填写的,需要注意的是这里，其他的没什么。</p>
<pre><code>Pod::Spec.new do |s|
  s.name             = &quot;GKit&quot;
  s.version          = &quot;0.1.0&quot;
  s.summary          = &quot;Testing Private Podspec&quot;

  s.description      =  &lt;&lt;-DESC
                   Testing Private Podspec.

                   * Markdown format.
                   * Don&apos;t worry about the indent, we strip it!
                   DESC

  s.homepage         = &quot;https://github.com/fuer4869/GKit&quot;
  s.license          = &apos;MIT&apos;
  s.author           = { &quot;fuer4869&quot; =&gt; &quot;fuer4869@gmail.com&quot; }
  s.source           = { :git =&gt; &quot;https://github.com/fuer4869/    GKit.git&quot;, :tag =&gt; s.version.to_s }
  s.platform     = :ios, &apos;7.0&apos;
  s.requires_arc = true

  s.source_files = &apos;Pod/Classes/**/*&apos;
  s.resource_bundles = {
    &apos;GKit&apos; =&gt; [&apos;Pod/Assets/*.png&apos;]
  }
 s.public_header_files = &apos;Pod/Classes/**/*.h&apos;
 s.frameworks = &apos;UIKit&apos;
 s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;
end</code></pre><p>编辑完podspec文件后就需要对这个文件做一次验证，保证刚刚填写的格式是否正确，否则会影响接下来的上传。</p>
<pre><code>$ pod lib lint</code></pre><p>等待一点时间后，如果你看到<br><code>XXX passed validation.</code>说明验证已经通过，否则就是你编辑的podspec文件有错误，一般都是路径错误或者缺少必填项这种错。</p>
<p>目前已经知道的podspec文件是可用的，但是还没有知道整个pod项目是否符合安装环境，pod还不一定能够使用。所以这时候我们可以自己做一次本地的测试。</p>
<p>创建一个新项目，新建并编辑podfile文件，</p>
<pre><code>platform :ios, &apos;7.0&apos;

pod &apos;GKit&apos;, :path =&gt; &apos;~/.cocoapods/repos/GKit</code></pre><p>安装pod <code>pod install --verbose --no-repo-update</code></p>
<p>在项目中引入自己的包测试无误后就可以做最后的步骤啦！把podspec 提交到Spec<br>Repo，之前上传到远端仓库的步骤总算起到作用了。</p>
<p>cd到pod项目中</p>
<pre><code>pod repo push WTSpecs GKit.podspec</code></pre><p>目前我的环境是Xcode7 beta，EI<br>Captain，终端给我提示了这样的一个错误<code>Assertion failed: _initializationCompletedSuccessfully</code>,很是无语，今天又被xcode7<br>坑了一次。后来在网上查阅了下资料找到了个比较靠谱的解答：<a href="http://stackoverflow.com/questions/31085306/error-generating-pods-project-pod-install" target="_blank" rel="noopener">Error<br>generating pods project - Pod<br>install</a><br>因为目前我安装的是xcode-beta版本，只要把现在的xcode-select退到Xcode<br>release版本就可以了。</p>
<pre><code>sudo xcode-select -s /Applications/Xcode-beta.app/Contents/Developer</code></pre><p>好了上传成功，你可以通过pod search直接搜索自己的库了。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2015/02/16/%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93podspec%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">Seite 1 von 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 loannes. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">loannes</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
