
<!DOCTYPE html>
<html lang="zh-CN">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="loannes&#39;s blog">
    <title>loannes&#39;s blog</title>
    <meta name="author" content="loannes">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"http://yoursite.com","author":{"@type":"Person","name":"loannes","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"name":"loannes's blog","description":"","url":"http://yoursite.com"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="loannes&#39;s blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="loannes&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="loannes">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/%20"
            aria-label=""
        >
            loannes&#39;s blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/%20"
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Kategorien"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Kategorien</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archiv"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archiv</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Suche"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Suche</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="Über"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Über</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/" target="_blank" rel="noopener" title="Google Plus">
                    
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google Plus</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/profile/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/mailto"
                            title="E-Mail"
                        >
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">E-Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/16/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20/"
                            aria-label=": 算法图解笔记（三）\-\--快速排序"
                        >
                            算法图解笔记（三）\-\--快速排序
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-16T11:12:19+08:00">
	
		    16 11月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>===============================</p>
<h6 id="算法的核心思想—–分而治之（D-amp-C）"><a href="#算法的核心思想—–分而治之（D-amp-C）" class="headerlink" title="算法的核心思想—–分而治之（D&amp;C）"></a>算法的核心思想—–分而治之（D&amp;C）</h6><p>D&amp;C的理解过程：</p>
<ol>
<li>找出基线条件，这种条件必须尽可能简单。</li>
<li>不断将问题分解，直到符合基线条件。</li>
</ol>
<p>通过下面这道题来加深对D&amp;C的理解:<br><img src="./%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20_%20%E9%A3%9E%E5%A5%94%E7%9A%84%E8%9C%97%E7%89%9B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_files/M0JAOA.png" alt="图片"></p>
<p><strong>将这块长为1680m，宽640m的地均匀的分成方块，且分出的方块尽可能的大。</strong></p>
<p>按照D&amp;C的解题步骤：</p>
<ol>
<li>基线条件：<br>如果长是宽的整数倍，那么就可以正好将他们分割成等分的正方形。然后通过从大到小的顺序进行筛选优先找到的肯定是最大的正方形。</li>
</ol>
<p>按照题目中的理解就是：<em>只需找出1680余64之间的最大公约数即可。</em></p>
<ol start="2">
<li>递归条件：<br>通过欧几里得算法可以得知：’适用于这小块地的最大方块同样也适用于整块地的最大方块’。这句话正好符合了分而治之的核心思想。</li>
</ol>
<p><img src="./%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20_%20%E9%A3%9E%E5%A5%94%E7%9A%84%E8%9C%97%E7%89%9B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_files/M0wGgf.png" alt=""></p>
<p>先按照最大的值来分割正方形，以640作为最大正方形得出上面这张图。可以看到最右边的方块不是正方形，所以接下来对它进行相同的算法处理。</p>
<p>以此类推，最终得到了这样一张图：</p>
<p><img src="./%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20_%20%E9%A3%9E%E5%A5%94%E7%9A%84%E8%9C%97%E7%89%9B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_files/M00LlV.png" alt=""></p>
<p>所以最终的结果是80*80的方块。</p>
<h6 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h6><p>给定一个数字数组，以递归的方式计算出该数组的总和。<br>如：[2,4,6]</p>
<p>+———————————–+———————————–+<br>|     1                             |     def sum(arr):                 |<br>|     2                             |                                   |<br>|     3                             |    if len(arr) == 0:  // 基线条件 |<br>|     4                             |             return 0              |<br>|     5                             |       return                      |<br>|     6                             |  arr[0] + sum(arr[1:]) //递归条件 |<br>|                                   |                                   |<br>|                                   |     print(sum([2,3,4,5]))         |<br>+———————————–+———————————–+</p>
<h6 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h6><p>用递归的形式计算列表中包含的元素数:</p>
<p>+———————————–+———————————–+<br>|     1                             |     def count(list):              |<br>|     2                             |       if len(list) == 0:          |<br>|     3                             |             return 0              |<br>|     4                             |       return (list                |<br>|     5                             | [0] == list[0]) + count(list[1:]) |<br>|     6                             |                                   |<br>|                                   |     print(count([1,5,3,5]))       |<br>+———————————–+———————————–+</p>
<h6 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h6><p>用递归的形式找出列表中最大的数字</p>
<p>+———————————–+———————————–+<br>|     1                             |     def large(list):              |<br>|     2                             |         if list == []:return      |<br>|     3                             |       if len(list) == 1:          |<br>|     4                             |             return list[0]        |<br>|     5                             |         else:                     |<br>|     6                             |          ret                      |<br>|     7                             | urn max(list[0], large(list[1:])) |<br>|     8                             |                                   |<br>|                                   |     print(large([1,2,3,4,5]))     |<br>+———————————–+———————————–+</p>
<h6 id="例题5"><a href="#例题5" class="headerlink" title="例题5"></a>例题5</h6><p>找出二分查找算法的基线条件和递归条件<br>基线条件：数组长度等于1<br>递归条件：二分查找的核心，去掉数组一半，对另一半进行二分查找，直到满足基线条件。</p>
<hr>
<h3 id="D-amp-C算法之-—-快速排序"><a href="#D-amp-C算法之-—-快速排序" class="headerlink" title="D&amp;C算法之 — 快速排序"></a>D&amp;C算法之 — 快速排序</h3><ol>
<li>从数组中找到一个基准值（pivot），这个基准值可以是数组中的任何一个数值。</li>
<li>把小于基准值的放到一边，把大于基准值的放到另外一边。然后再对它们进行快速排序，直到满足基线条件位置。快速排序相当于是递归和二分查找的结合。</li>
<li>快速排序的递归条件其实就是二分查找，通过不停的分割最终合并n个数组从而形成一个排好序的新数组。</li>
</ol>
<p>+———————————–+———————————–+<br>|     1                             |     ## 快速排序                   |<br>|     2                             |     def quicksort(list):          |<br>|     3                             |         if len(list) &lt; 2:         |<br>|     4                             |           return list             |<br>|     5                             |        else:                      |<br>|     6                             |          pivot = list[0]          |<br>|     7                             |            less = [i              |<br>|     8                             |  for i in list[1:] if i &lt;= pivot] |<br>|     9                             |          greater = [              |<br>|     10                            | i for i in list[1:] if i &gt; pivot] |<br>|     11                            |            return quicksort(les   |<br>|     12                            | s) + [pivot] + quicksort(greater) |<br>|                                   |                                   |<br>|                                   |                                   |<br>|                                   |     prin                          |<br>|                                   | t(quicksort([1,3,2,6,5,9,0,7,4])) |<br>+———————————–+———————————–+</p>
<h4 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h4><p>二分查找：<br>$$O(log_2 n)$$</p>
<p>简单查找<br>$$O(n)$$</p>
<p>选择排序<br>$$O(n^2)$$</p>
<p>快速排序<br>$$O(nlogn)$$<br>最糟糕的情况下是<br>$$O(n^2)$$</p>
<p>旅行商问题算法<br>$$O(n!)$$</p>
<p>还有一种算法是合并排序，时间复杂度稳定在<br>$$O(nlogn)$$</p>
<h5 id="快速排序时间复杂度的由来"><a href="#快速排序时间复杂度的由来" class="headerlink" title="快速排序时间复杂度的由来"></a>快速排序时间复杂度的由来</h5><p>以数组[1,2,3,4,5,6,7,8]为例，我们取到的基数是4。这里的分割方式与二分查找相同，所以执行次数为<code>logn</code>。分割完成后对每个数组的再次遍历进行分割，也就是递归条件的时间复杂度为<code>O(n)</code>。所以快速排序的时间复杂度是<code>O(n) + logn</code>。<br>$$O(nlogn)$$</p>
<p>如果是在最糟糕的情况下，这个数组本身就是排好序的时候，那么它的时间复杂度就是<br>$$O(n^2)$$</p>
<h4 id="快速排序与合并排序的区别"><a href="#快速排序与合并排序的区别" class="headerlink" title="快速排序与合并排序的区别"></a>快速排序与合并排序的区别</h4><p>因为算法有时候会带有常量，在有常量的时候它们的运算时间就不一样了。<br>同样是时间复杂度为<code>nlogn</code><br>的快速排序和合并排序，在某些情况下它们的运行时间是不一样的。因为这中间n指的是执行次数，比如双方都执行了10000次，按照时间复杂度来看的话执行时间是差不多的，但是快速排序每次执行花了1毫秒，而合并排序花了10毫秒，那10000次下来时间差距就不是一点点了。</p>
<p>这里做个总结：快速排序在执行过程中也很快。</p>
<p>同样在有常量的时候，对快速排序和合并排序的运行时间也会有影响。如果出现快速查找的常量比合并查找的常量小，那么运行时间上也是快速查找占优。</p>
<h4 id="平均情况和最糟情况"><a href="#平均情况和最糟情况" class="headerlink" title="平均情况和最糟情况"></a>平均情况和最糟情况</h4><p>最糟情况指的是：比方说在快速排序的时候，取的基准值是第一个而且是整个数组中最小的一个，整个时候数组是不会被分成两半的。如果数组中第二是值是第二小的话，也会造成这种情况。这个时候就是最糟情况。</p>
<h5 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h5><p>用大O法表示：</p>
<ol>
<li>打印数组中每个元素的值：<br>O(n)</li>
<li>将数组中每个元素的值都乘以2：<br>O(n)</li>
<li>只将数组中第一个元素乘以2：<br>O(1)</li>
<li>根据数组包含的元素创建一个乘法表，如果数组为[2,3,7,8,10]。首先将每个元素都乘以2，再将每个元素都乘以3，然后将每个元素都乘以7以此类推。<br>$$O(n^2)$$</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>递归的核心是D&amp;C,基线条件一般都是空数组或者只包含一个元素的数组。</li>
<li>找到了基线条件后，执行递归条件让它通过递归的方式慢慢靠拢基线条件即可。</li>
<li>在使用快速排序的时候，为了避免最糟情况基准值最好随机的去找。</li>
<li>在列表数据很长的时候，简单查找和二分查找不管在任何情况下速度都没得比。</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/16/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89---%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/16/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20---%20%E9%80%92%E5%BD%92%20/"
                            aria-label=": 算法图解笔记（二） \-\-- 递归"
                        >
                            算法图解笔记（二） \-\-- 递归
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-16T11:12:19+08:00">
	
		    16 11月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=============================</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>每当调用函数时，计算机会将函数调用设计的所有变量存贮到内存中。</li>
<li>在函数内调用函数时，内部的函数在调用完成后会返回到上一次函数并且会被踢出栈堆。未完成的函数不会被踢出栈堆。</li>
<li>创建递归函数时刻要记得基线条件和递归条件</li>
</ul>
<p>一段关于栈的代码解读</p>
<p>+———————————–+———————————–+<br>|     1                             |     def fact(x):                  |<br>|     2                             |       if x==1:                    |<br>|     3                             |         return 1                  |<br>|     4                             |       else:                       |<br>|     5                             |         return x*fact(x-1)        |<br>+———————————–+———————————–+</p>
<p>代码解读：（以x=3为例）</p>
<ol>
<li>当x=3，程序进入了else条件并且执行递归，随后创建了x=2的内存块被将其放入栈堆中。</li>
<li>执行x=2的函数，因为此时x不等于1所以还是进入了else条件执行递归，随后创建了x=1的内存块并将其放入栈堆中。</li>
<li>此时x=1则进入第一个条件返回1，该轮函数执行完毕被踢出栈堆，同时上一层函数也因为该函数的结束而结束，被踢出栈堆，后面以此类推。</li>
<li>在此函数中，<code>x==1</code>为基线条件，它决定了什么时候跳出递归循环。而<code>else</code>为递归条件，它决定了递归中执行操作来慢慢接近基线条件。</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>递归有两种操作，压入和弹出</li>
<li>每个递归函数都有两个条件：基线条件和递归条件</li>
<li>所有的函数调用都将进入调用栈</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/16/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%20---%20%E9%80%92%E5%BD%92%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/09/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%20/"
                            aria-label=": 大话数据结构第二章 算法"
                        >
                            大话数据结构第二章 算法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-09T11:12:19+08:00">
	
		    09 11月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=======================</p>
<h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p>算法表示决绝特定问题的求解步骤，由一个或多个操作组成。</p>
<h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><p>输入输出、有穷性、确定性、可行性。</p>
<p><strong>输入输出：</strong> 不一定有输入但必须有输出<br><strong>有穷性</strong> 造成死循环的代码不是算法<br><strong>确定性</strong> 算法的每一个步骤都有确定的含义，无需存在多余的步骤。<br><strong>可行性</strong> 算法的每一步都必须在计算机上运行</p>
<h4 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h4><p>公式:</p>
<p>+———————————–+———————————–+<br>|     1                             |     T(n) = O(f(n))                |<br>+———————————–+———————————–+</p>
<p>表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同。f（n）表示算法的工作量。</p>
<p>也就是说随着n的增大，T(n)增长最慢的算法为最优算法。</p>
<h4 id="推导大O阶"><a href="#推导大O阶" class="headerlink" title="推导大O阶"></a>推导大O阶</h4><ol>
<li>用常数1取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是1，则去除与整个项相乘的常数。</li>
</ol>
<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>+———————————–+———————————–+<br>|     1                             |     int sum = 0, n=100;           |<br>|     2                             |     sum = (1+n)*n/2;              |<br>|     3                             |     printf(“%d”,sum);             |<br>+———————————–+———————————–+</p>
<p>这里执行了3次，所以f(n)=3。<br>通过f(n)=3计算出大O阶：</p>
<ol>
<li><p>把常数项3改为1.<br>f(n) = 1。</p>
<p>由于没有最高阶项，所以时间复杂度为0(1)。</p>
<p>然后假设<code>sum=(1+n)*n/2</code>这条语句有10句：<br>那么f(n) = 12，最后推导的结果还是0(1)</p>
<p>类似这种执行时间恒定，时间复杂度为0(1)的又叫做<strong>常数阶</strong></p>
</li>
</ol>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>算法中带有循环结构部分的称为线性阶。它的时间复杂度呈线性增长。</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><p>+———————————–+———————————–+<br>|     1                             |     int count = 1;                |<br>|     2                             |     while(count &lt; n)              |<br>|     3                             |     {                             |<br>|     4                             |       count = count * 2;          |<br>|     5                             |     }                             |<br>+———————————–+———————————–+</p>
<p>它的时间复杂度与上例中的2有关，也与n有关。<br>此例中常数为2，我们可以得到</p>
<p>$$2^x = n$$</p>
<p>或者</p>
<p>$$x=log_2 n$$<br>所以对数阶的时间复杂度为O(logn)</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><p>+———————————–+———————————–+<br>|     1                             |     int i,j;                      |<br>|     2                             |     for (i = 0; i&lt;n; i++){        |<br>|     3                             |       for(j=0; j&lt;n;j++){          |<br>|     4                             |                                   |<br>|     5                             |      }}                           |<br>+———————————–+———————————–+</p>
<p>这是一个线性阶内嵌在另外一个线性阶中。<br>当i=0时，它执行了n此，当i=1时，执行了n-1次 ……<br>当i=n-1时，执行了1次。<br>总的执行次数为:<br>n + (n-1) + (n-2) … +1 =</p>
<p>$$\frac{n(n+1)}{2}$$</p>
<p>=</p>
<p>$$\frac {n^2} 2 + \frac n 2$$</p>
<p>以最终推导的公式：</p>
<p>$$\frac {n^2} 2 + \frac n 2$$</p>
<p>来计算<br>按照第二步 去除加号中的常数：</p>
<p>$$\frac n 2$$</p>
<p>保留最高阶：</p>
<p>$$\frac {n^2} 2$$</p>
<p>然后按照第三步去除相乘的常数，也就是去除1/2。最终得到的时间复杂度为：<br>$$O(n^2)$$</p>
<p>常用的时间复杂度<br>|执行次数函数|阶|非正式术语|<br>|—|—|—|<br>|12|O(1)|常数阶|<br>|2n+3|O(n)|线性阶|<br>|3n^2+2n+1|O(n^2)|平方阶|<br>|5log2n+20|O(logn)|对数阶|<br>|2n+3nlog2n+19|O(nlogn)|nlogn阶|<br>|6n^3+2n^2+3n+4|O(n^3)|立方阶|<br>|2^n|O(2^n)|指数阶|</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/09/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/09/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0(%E4%B8%80)---%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"
                            aria-label=": 算法图解笔记(一) \-\-- 选择排序、二分查找"
                        >
                            算法图解笔记(一) \-\-- 选择排序、二分查找
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-09T11:12:19+08:00">
	
		    09 11月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=========================================</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>是一个在有序元素列表中的查找的算法<br>原理：如这个列表长度是10000，通过算法排除不满足条件的另一半来查找。</p>
<p>比如从100个数字中找到某个数字的索引，可以先找到50进行比较来缩小范围。如果大于50就再拿75做比较，以此类推，直到找到该数字。</p>
<p>这样的二分算法能从原先的暴力查找（最坏情况下）100次减少到7次。</p>
<p>记做公式：<br>$$log_2 n$$</p>
<h3 id="算法运行时间"><a href="#算法运行时间" class="headerlink" title="算法运行时间"></a>算法运行时间</h3><p>运行时间的增速:随着数据量的增加，运行时间会出现递增的情况。优秀的算法增速越少，比如二分查找和简单查找在10亿个算法的情况下，简单查找需要11天才能查找玩，而二分查找只需要32毫秒。</p>
<p>算法的速度指的的操作数的增速。也就是时间复杂度</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>缺点：添加新元素如果遇到内存空间被占用，需要额外申请空间，效率会降低。频繁插入和删除操作不适合数组。</p>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>优点：每个元素都存储着下一个元素的地址，如果是有序的读取那读取速度将快于数组。适合大批量列表</p>
<p>如果是有序读取，插入操作频繁的话是链表占优<br>如果是无序读取，插入操作比较少的话是数组占优</p>
<p>数组：<br>读取：O(1)<br>插入：O(n)<br>删除：O(n)</p>
<p>链表：<br>读取：O(n)<br>插入：O(1)<br>删除：O(1)</p>
<h4 id="选择排序例题"><a href="#选择排序例题" class="headerlink" title="选择排序例题"></a>选择排序例题</h4><p>对一个数组进行从小到大排列<br>思路就是遍历整个数组，将每个数字与其他数字进行比较。选择排序的优化在于第一轮被拿出来做比较确定为最小的数字将会被踢出数组，不会参与到下一轮的比较。</p>
<p>+———————————–+———————————–+<br>|     1                             |     def smallest(list):           |<br>|     2                             |       small_value = list[0]       |<br>|     3                             |      small_index = 0              |<br>|     4                             |                                   |<br>|     5                             |      for i in range(1,len(list)): |<br>|     6                             |                                   |<br>|     7                             |         if list[i] &lt; small_value: |<br>|     8                             |                                   |<br>|     9                             |             small_value = list[i] |<br>|     10                            |              small_index = i      |<br>|     11                            |        return small_index         |<br>|     12                            |                                   |<br>|     13                            |     # 选择排序                    |<br>|     14                            |     def select_sort(list):        |<br>|     15                            |       newlist = []                |<br>|     16                            |       for i in range(len(list)):  |<br>|                                   |                                   |<br>|                                   |            small = smallest(list) |<br>|                                   |                                   |<br>|                                   |   newlist.append(list.pop(small)) |<br>|                                   |        return newlist             |<br>+———————————–+———————————–+</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>需要存储多个元素时可以考虑使用数组或者链表，时刻记得他们之间的优缺点。</li>
<li>数组的读取速度很快</li>
<li>链表的插入和删除速度很快</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/09/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E7%AC%94%E8%AE%B0(%E4%B8%80)---%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/11/08/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20/"
                            aria-label=": 大话数据结构第一章 数据结构"
                        >
                            大话数据结构第一章 数据结构
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-11-08T11:12:19+08:00">
	
		    08 11月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>===========================</p>
<p>所有能够被计算机程序处理和可以输入到计算机中的都可以作为数据。不单单只有数值、数值类型，MP3,图片等都是数据。</p>
<h4 id="数据元素与数据项的区别"><a href="#数据元素与数据项的区别" class="headerlink" title="数据元素与数据项的区别"></a>数据元素与数据项的区别</h4><p>数据元素是由数据项组成的单位，如某公司中的一名程序员就是数据元素。<br>而数据项则是由数据元素拆分而成的最小单位，这名程序员的姓名，年龄就是数据项了。</p>
<h4 id="数据对象-简称为数据"><a href="#数据对象-简称为数据" class="headerlink" title="数据对象(简称为数据)"></a>数据对象(简称为数据)</h4><p>数据对象就是性质相同的数据元素的集合。某个数据元素是程序员A，程序员A、程序员B、程序员C统称为程序员，这个程序员就是数据对象。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>是相互之间存在一种或多种特定关系的数据元素的集合。<br>比方说：N名iOS程序员 + N名Android程序员 +<br>N名后端程序员可以组成移动开发小组。<br>N名Unity程序员 + N名后端开发可以组成游戏开发小组。</p>
<h3 id="数据结构有哪些？"><a href="#数据结构有哪些？" class="headerlink" title="数据结构有哪些？"></a>数据结构有哪些？</h3><p>逻辑结构<br>集合结构、线性结构、树形结构、图形结构。<br>线性结构——是一个有序数据元素的集合。如1、2、3、4、5、6、7、8、9<br>树型结构——<br>顾名思义，数据呈现成树形结构。像公司成员结构就是树形结构。<br>图形结构—— 最乱的一种结构，呈现为多对多的结构形式。</p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>数据的逻辑结构在计算机中的存储形式。相当于是把私房钱是叠起来放在花瓶里还是揉成一团放在花瓶里。</p>
<ul>
<li>顺序存储结构 类似于数组，而且是个不可变的数组。适用于查询</li>
<li>链式存储结构：把数据元素存放在任意位置。如银行，医院等排队系统，频繁插入，更新的需要链式结构。</li>
</ul>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>原子类型：整型、字符型等不可再分解的都是原子类型<br>结构类型：如字典、数组</p>
<p>抽象数据类型<br>它可能是一个数据模型、可以是一个viewmodel。针对不同的业务或者功能所创造的数据类型。也可以称之为自定义数据类型</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/11/08/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/10/22/leetcode%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"
                            aria-label=": leetcode第一周刷题总结"
                        >
                            leetcode第一周刷题总结
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-10-22T11:12:19+08:00">
	
		    22 10月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>======================</p>
<h3 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h3><p>=========================================================================================================================</p>
<p>在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。</p>
<p>「黑皇后」在棋盘上的位置分布用整数坐标数组 queens<br>表示，「白国王」的坐标用数组 king 表示。</p>
<p>「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。</p>
<p>请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。</p>
<p><img src="./leetcode%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%20_%20%E9%A3%9E%E5%A5%94%E7%9A%84%E8%9C%97%E7%89%9B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_files/untitled-diagram.jpg" alt=""></p>
<ul>
<li><p>输入：queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]],<br>king = [0,0]</p>
</li>
<li><p>输出：[[0,1],[1,0],[3,3]]</p>
</li>
</ul>
<p><strong>解释：</strong></p>
<ul>
<li>[0,1] 的皇后可以攻击到国王，因为他们在同一行上。</li>
<li>[1,0] 的皇后可以攻击到国王，因为他们在同一列上。</li>
<li>[3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。</li>
<li>[0,4] 的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。</li>
<li>[4,0] 的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。</li>
<li>[2,4] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。</li>
</ul>
<p><strong>提示</strong></p>
<ul>
<li>1 &lt;= queens.length &lt;= 63</li>
<li>queens[0].length == 2</li>
<li>0 &lt;= queens[i][j] &lt; 8</li>
<li>king.length == 2</li>
<li>0 &lt;= king[0], king[1] &lt; 8</li>
<li>一个棋盘格上最多只能放置一枚棋子。</li>
</ul>
<h4 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h4><p>从解释和提示中我们可以得到两条重要的线索：</p>
<ul>
<li>king的取值范围：0 &lt;= x &lt; 8</li>
<li>皇后只能走一个方向，不能绕路走。要么走横线，要么走竖线，要么走对角线。</li>
<li>只需找到离king最近的能攻击到king的皇后</li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>无需考虑king在棋盘的什么位置，直接以king为中心进行八方向探索，直到找到最近的皇后。我们可以创建一个含有八个不同方向的坐标，如（1，0）就是往右一格一格进行搜索。</p>
<p>(一开始浪费时间在考虑king的位置上了，后来一想直接限定king的探索范围就好了)</p>
<p>+———————————–+———————————–+<br>|     1                             |     class Solution:               |<br>|     2                             |         def queensAttacktheKing(s |<br>|     3                             | elf, queens: List[List[int]], kin |<br>|     4                             | g: List[int]) -&gt; List[List[int]]: |<br>|     5                             |                                   |<br>|     6                             |           # 上    右上   右    右 |<br>|     7                             | 下    下    左下    左     左上   |<br>|     8                             |             d                     |<br>|     9                             | irection = [[-1,0],[-1,1],[0,1],[ |<br>|     10                            | 1,1],[1,0],[1,-1],[0,-1],[-1,-1]] |<br>|     11                            |             q                     |<br>|     12                            | ueens = {(x,y) for x,y in queens} |<br>|     13                            |             res = []              |<br>|     14                            |             # 八方向查找          |<br>|     15                            |             for a,b in direction: |<br>|     16                            |                 # 找到皇后后，x,  |<br>|     17                            | y回到初始位置继续往另外个方向探索 |<br>|     18                            |                 x = king[0]       |<br>|     19                            |                 y = king[1]       |<br>|                                   |                                   |<br>|                                   |  while 0 &lt;= x &lt; 8 and 0 &lt;= y &lt; 8: |<br>|                                   |                     x += a        |<br>|                                   |                     y += b        |<br>|                                   |                     # 这里本      |<br>|                                   | 身是想对queens做for循环遍历来做比 |<br>|                                   | 对的，因为这里本身已经在for循环中 |<br>|                                   | 了，会造成多余的操作。后来借鉴了  |<br>|                                   | 别人的代码，把queens改为字典了。  |<br>|                                   |                                   |<br>|                                   |                if(x,y) in queens: |<br>|                                   |                                   |<br>|                                   |                 res.append([x,y]) |<br>|                                   |                         break     |<br>|                                   |             return res            |<br>+———————————–+———————————–+</p>
<p>+———————————–+———————————–+<br>|     1                             |     执行用时 :                    |<br>|     2                             |     48 ms                         |<br>|     3                             |     内存消耗 :                    |<br>|     4                             |     14 MB                         |<br>+———————————–+———————————–+</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>解题思路基本上有了，但是花了很多时间在处理for循环上始终找不到最优的方式去匹配坐标。学到了可以通过字典的形式来做匹配，既方便还不用再创建个循环。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/10/22/leetcode%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/02/03/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%20/"
                            aria-label=": iOS内存管理那些事"
                        >
                            iOS内存管理那些事
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-02-03T11:12:19+08:00">
	
		    03 2月 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>=================</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>今天在网上看到一道蛮有趣的问题，内容是”对于已经会使用ARC的iOS开发者来说还有必要学习手动内存管理吗？”<br>。换做一年前的我可能会觉得那必须不用学啊，手动管理内存管理太麻烦了而且很容易出错。ARC现在用下来完全能够解决我日常开发中的所有内存管理的问题，而且苹果在WWDC2011上已经强烈推荐开发者使用ARC，为什么不用ARC呢?</p>
<p>直到我有一次使用了第三方组件，当时这个组件是不支持ARC的。有一天在我做新功能的时候突然出现了一个没有任何踪迹的崩溃，经过了1个通宵的排查和网友的帮助最后才得知原来是非ARC和ARC的代码混用出现的问题，后来还是自己重新写了个非ARC的功能才解决了这个问题。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><hr>
<p>每当一个对象被创建的时候它的引用计数为1，为保证对象的存在不造成悬挂指针的情况出现，每当创建引用到对象需要为其的引用计数加1。否则如果其中一个引用被释放的时候因为对象的引用计数被清零，但是对象没有被彻底释放而造成崩溃。</p>
<blockquote>
<p>管理引用计数的目的就是在确保程序运行正常的情况下，能够合理的管理引用计数的递增或者递减。</p>
</blockquote>
<p>管理引用计数有一下3个消息：</p>
<ul>
<li>retain 对象的引用计数加1</li>
<li>release 对象的引用计数减1</li>
<li>autorelease 将对象放入自动释放池中</li>
</ul>
<h4 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h4><p>retain一般用在对象被创建或者引用被赋值的情况下</p>
<pre><code>NSArray * array = [[NSArray array] retain];</code></pre><p>这里创建了一个<code>array</code>的数组，它的引用计数为1。</p>
<pre><code>self.data = array;</code></pre><p><code>array</code> 的引用被赋值给了<code>self.data</code>。</p>
<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>当某个对象不再使用的时候，可以给对象发送<code>release</code>消息。这个时候该对象的引用计数就会减1,如果引用计数为0的时候，在dealloc函数被调用的之后会释放内存。</p>
<p>也就是说如果给对象发送release消息不一定会马上销毁该对象，有可能它还有其他对象引用着。</p>
<h4 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h4><p>有时候可能会遇到一些release不能解决的问题，如在一个函数中返回一个对象，这个时候必须给该对象发送autorelease消息,把对象放入<code>autoreleasepool</code>（自动释放池）中，当runloop执行自动释放池的时候，会从池中的对象列表中一一释放。</p>
<h3 id="assign-copy-retain之间的区别"><a href="#assign-copy-retain之间的区别" class="headerlink" title="assign,copy,retain之间的区别"></a>assign,copy,retain之间的区别</h3><p>在使用成员变量时，会给property传入上面三种参数，不同情况不同用法。</p>
<h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><p>assign<br>相当于是unsafe_unretained,它不会为变量做引用计数。所以一般都是用在基础数据类型上，如int<br>float等。这种类型的变量会由系统自动释放，程序员不用管理。</p>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>copy 会对旧对象另外分配内存给新对象，新对象引用计数加1，就对象不变。</p>
<pre><code>self.data = [array copy];</code></pre><p>这种情况下，<code>self.data</code> 和 <code>array</code><br>虽然是相同的，引用计数也都是1，但是它们不存在同一块内存中，也就是说即使<code>array</code>被释放了，<code>self.data</code>也不会受到任何影响。</p>
<h4 id="retain-1"><a href="#retain-1" class="headerlink" title="retain"></a>retain</h4><p>retain则是会对对象做引用计数，只有在引用计数为0的时候，执行dealloc才会释放对象。</p>
<h3 id="强变量"><a href="#强变量" class="headerlink" title="强变量"></a>强变量</h3><p>首先我们得知道所有的对象的指针都是强变量，也就是说当你把一个对象赋值给一个强变量的时候，强变量会引用到这个对象，旧对象则在赋值前会被释放，强变量会自动保持。不管是实例变量还是全局变量都是这么回事。<br>有一点需要注意，成员变量默认不是strong，其默认是assign。也就是说他默认不会被自动保持。</p>
<h3 id="弱变量"><a href="#弱变量" class="headerlink" title="弱变量"></a>弱变量</h3><p>弱变量的存在主要是为了解决循环保持（retain<br>cycle）的问题。也就是说当两个对象互相存在彼此的强引用时，比如说对象A中有一个强变量B，对象B有个强变量A，这样就会造成循环保持。当其中一个对象需要销毁的时候因为另外一个对象引用着它而造成无法销毁。解决这个问题可以通过在2个对象之间建立一个弱引用的方法。可以在父对象中声明一个强变量子对象，在子对象中声明一个弱变量父对象，这样就不会造成循环保持，因为弱变量不能阻止引用的对象被销毁，在这里就是子对象无法阻止父对象被销毁。而且这个时候子对象会被设置为nil，所以即使无意中给它发送了消息也不会造成奔溃现象。</p>
<h3 id="内存管理的规则总结"><a href="#内存管理的规则总结" class="headerlink" title="内存管理的规则总结"></a>内存管理的规则总结</h3><ul>
<li>一个对象执行了retain消息之后，它的引用计数会加1，这样它就不会被销毁，直到执行release消息之后。也就是说当对象的引用计数为0的时候，对象才会被销毁，然后系统会发送dealloc消息来释放内存。</li>
<li>如果想让一个对象在release之后不被销毁，只要让它的引用计数不为0就行了或者多执行一次retain。</li>
<li>所有发送过autorelease的对象都会被放入自动释放池中，当自动释放池执行至末尾时，会对池中的所有对象发送release消息。</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/02/03/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2017/01/08/%E5%AF%B9%E4%BA%8E%20iOS10%20%E4%B8%AD%20ATS%20%E7%9A%84%E7%90%86%E8%A7%A3%20/"
                            aria-label=": 对于 iOS10 中 ATS 的理解"
                        >
                            对于 iOS10 中 ATS 的理解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-01-08T11:12:19+08:00">
	
		    08 1月 2017
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>WWDC 15 后，对其中有一项新引入的 features 特别在意，那就是苹果将在 2017<br>年初即将强制实施的一项隐私保护功能 ATS(App Transport Security)。<br>在 WWDC 16 中也提到了 ATS，当时声明了 ATS 安全功能与 iOS 9 和 OS X 10.11<br>一同发布，旨在强制性地使用<br>HTTPS，以保护应用程序可安全地接入服务器。所有提交到 App Store<br>的应用程序都需要在 2016 年底执行 ATS 协议。</p>
<blockquote>
<p>此处更新于 2016 年 12 月 21 日。</p>
</blockquote>
<blockquote>
<p>收到消息称苹果将延后强制加入 HTTPS<br>服务，原因各说纷纭就不详细说明了。至于延期到什么时候还未曾有消息。</p>
</blockquote>
<h3 id="ATS（NSAppTransportSecurity）"><a href="#ATS（NSAppTransportSecurity）" class="headerlink" title="ATS（NSAppTransportSecurity）"></a>ATS（NSAppTransportSecurity）</h3><hr>
<blockquote>
<p>It improves privacy and data integrity by ensuring your app’s network<br>connections employ only industry-standard protocols and ciphers<br>without known weaknesses</p>
</blockquote>
<p>它为你的 app 在与规范的协议的网络连接当中对数据起到完美的保护作用。<br>意思就是在 app<br>的平时的网络连接中所涉及到的数据起到保护作用，防止外界的窃听或者盗用。能够逐渐对用户建立起一种信任，那就是你的<br>app 不会意外或者恶意传播用户隐私数据。</p>
<p><strong>NSAppTransportSecurity</strong> 这个功能仅在 iOS9.0 和 OS X v10.11<br>及以上才能使用。对于我们开发者来说将面临的是在苹果正式实施限制 HTTP<br>请求之后，我们最好要保证 app 中所有的请求都是 HTTPS<br>的，否则将会在审核过程中遇到麻烦。</p>
<p><strong>要使用 ATS 必须要满足以下条件</strong></p>
<ul>
<li>安全传输协议(TLS)必须是 1.2 版本，如果是老版本的话将不会使用 ATS</li>
<li>为了保证数据安全性，传输过程中须加密方式是 AES-128 或者 AES-256</li>
<li>客户端与服务端用到的数字证书必须是有可靠的由数字证书认证机构（CA）来负责签发和管理并承担<br>PKI 体系中公钥合法性的检验责任。一般 HTTPS 使用的是 SSL 数字证书</li>
<li>TLS 的密钥必须支持完全前向保密（PFS）</li>
<li>这个功能仅在 iOS9.0 和 OS X v10.11 及以上才能使用</li>
</ul>
<hr>
<p><strong>接下来讲讲在这次 ATS 功能中你需要注意到的规则</strong></p>
<ol>
<li>ATS<br>主要涉及到<strong>NSURLConnection</strong>,<strong>NSURLSession</strong>,<strong>UIWebView</strong>,<strong>WKWebView</strong>这几个类和<strong>AVFoundation</strong>框架中所有加载的<br>API。</li>
<li>如果 app 中涉及到的服务器暂时不支持 https，你可以使用<strong>Allow<br>Arbitrary Loads</strong>来禁用 ATS，但这项规则只有暂时的再过不久 Apple<br>将禁用这项功能。所以得在 Apple 正式禁用这项功能前把该升级成 https<br>的全部升级成 https，否则会在将来难以通过审核。</li>
<li>app<br>中也会用到一些多媒体文件，你可以通过<strong>NSAllowsArbitraryLoadsInWebContent</strong><br>和 <strong>NSAllowsArbitraryLoadsForMedia</strong> 从而不受 ATS 的限制。</li>
<li>其实 Apple 并不推荐直接将<strong>NSAllowsArbitraryLoads</strong>改为<strong>YES</strong>来禁用<br>ATS，所以它的默认值为<strong>NO</strong>。有一个比较容易被审核团队接受的方案那就是使用<strong>NSExceptionDomains</strong>来支持特定的域名。通过设置该域名下的<strong>NSExceptionAllowsInsecureHTTPLoads</strong>来让<br>ATS 接受此域名。</li>
</ol>
<h3 id="配置-ATS"><a href="#配置-ATS" class="headerlink" title="配置 ATS"></a>配置 ATS</h3><hr>
<p>在配置之前先来整理下我们将会用到哪些 key</p>
<ul>
<li><p><strong>NSAllowsArbitraryLoads</strong> 如果设定为<strong>YES</strong>将禁用<br>ATS，在上传的时候需要填写理由</p>
</li>
<li><p><strong>NSAllowsArbitraryLoadsForMedia</strong><br>如果设定为<strong>YES</strong>,将会禁用所有<strong>AV Foundation</strong>框架中的 ATS<br>约束。优先级高于<strong>NSAllowsArbitraryLoads</strong>，也就是说系统会优先看<strong>NSAllowsArbitraryLoadsForMedia</strong>来决定是否禁用<br>ATS。如果 app 需要兼容 iOS10<br>以下的话还是使用<strong>NSAllowsArbitraryLoads</strong>，因为<strong>NSAllowsArbitraryLoadsForMedia</strong>是从<br>iOS10 开始才有效。</p>
</li>
<li><p><strong>NSAllowsArbitraryLoadsInWebContent</strong> 如果设定为<strong>YES</strong>将会禁用 ATS<br>对特定的网页内容以及关于 NSURLSession<br>连接的限制。同样优先级会高于<strong>NSAllowsArbitraryLoads</strong>，和<strong>NSAllowsArbitraryLoadsForMedia</strong>是同级别的。同上，如果要支持老版本的话还是得用<strong>NSAllowsArbitraryLoads</strong>。</p>
</li>
<li><p><strong>NSAllowsLocalNetworking</strong> 如果设定为<strong>YES</strong> 会禁用 ATS<br>对不规则域名和本地域名的保护措施，不会禁用其他功能。并且在 iOS10<br>之后会忽略掉<strong>NSAllowsArbitraryLoads</strong>，如果为在 iOS10<br>以前那它的效果和<strong>NSAllowsArbitraryLoads</strong>一样。</p>
</li>
<li><p><strong>NSExceptionDomains</strong> 针对特定域名的字典，用于避开 ATS<br>规则的特殊域名，这个字段需要搭配<strong>NSAllowsArbitraryLoads</strong>使用，当<br>NSAllowsArbitraryLoads 为<strong>YES</strong>时会生效</p>
<ul>
<li>每个参数的 key<br>都为域名，例如：<a href="http://www.apple.com/" target="_blank" rel="noopener">www.apple.com</a></li>
<li>必须是小写字母</li>
<li>不能包含端口号</li>
<li>不能是一串 IP 地址</li>
<li>末尾不能为一个点</li>
</ul>
</li>
<li><p><strong>NSIncludesSubdomains:</strong> 为<strong>YES</strong>时 ，会对该域名的子域名做 ATS<br>保护</p>
</li>
<li><p><strong>NSRequiresCertificateTransparency</strong><br>为<strong>YES</strong>时，在请求合法的情况下，证书会被提交到 CT logs<br>的服务器来获得 SCT。(具体作用可以查看 <a href="https://imququ.com/post/certificate-transparency.html#toc-2-0" target="_blank" rel="noopener">Certificate Transparency<br>那些事 | JerryQu<br>的小站</a><br>)</p>
</li>
<li><p><strong>NSExceptionAllowsInsecureHTTPLoads</strong></p>
<ul>
<li>为<strong>YES</strong>时，允许加载不安全的 HTTP 并且不会去调整 TLS。</li>
<li>使用这个 key 时，上传时需要填写理由</li>
<li>可以连接安全的服务器和不安全的服务器</li>
</ul>
</li>
<li><p><strong>NSExceptionRequiresForwardSecrecy</strong></p>
<ul>
<li>支持(FS)完全前向保密，为<strong>YES</strong>时，加密方式会受到<strong>ATS<br>Configuration<br>Basics</strong>的限制。为<strong>NO</strong>时，以下这些会不支持<strong>FS</strong>但也能接受<ul>
<li>TLS_RSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_RSA_WITH_AES_128_GCM_SHA256</li>
<li>TLS_RSA_WITH_AES_256_CBC_SHA256</li>
<li>TLS_RSA_WITH_AES_256_CBC_SHA</li>
<li>TLS_RSA_WITH_AES_128_CBC_SHA256</li>
<li>TLS_RSA_WITH_AES_128_CBC_SHA</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>NSExceptionMinimumTLSVersion</strong></p>
<ul>
<li>配合 <strong>NSExceptionAllowsInsecureHTTPLoads</strong>使用，当服务器的 TLS<br>版本低于 1.2 的时候，需要在这里填写相应的版本 如：TLSv1.0</li>
<li>上传需要填写理由</li>
</ul>
</li>
</ul>
<hr>
<h3 id="这里做一个简单的总结"><a href="#这里做一个简单的总结" class="headerlink" title="这里做一个简单的总结"></a>这里做一个简单的总结</h3><p>如果 app 想兼容 iOS10 一下版本的，那么在配置 ATS<br>的时候只需要将<strong>NSAllowsArbitraryLoads</strong>设定为<strong>YES</strong>就可以了，因为 iOS9<br>只看这个。如果是在 iOS 10<br>的情况下，如果<strong>NSAllowsArbitraryLoadsForMedia</strong>，<strong>NSAllowsArbitraryLoadsInWebContent</strong>和<strong>NSAllowsArbitraryLoads</strong>同时存在那么会优先看<strong>NSAllowsArbitraryLoadsForMedia</strong>和<strong>NSAllowsArbitraryLoadsInWebContent</strong>。如果前<br>2 者不存在，那就看<strong>NSAllowsArbitraryLoads</strong>的设定了。</p>
<hr>
<p>下面是针对不同情况整理出来的 ATS 配置方案</p>
<p>![](./对于 iOS10 中 ATS 的理解 _<br>飞奔的蜗牛的博客_files/https_ats_01.png)</p>
<p>有一点忘记说了，要配置 ATS 只需在 Info.plist<br>文件中添加<strong>NSAppTransportSecurity</strong>，具体的结构如下：</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<dl><dt>NSAppTransportSecurity : Dictionary {<br>NSAllowsArbitraryLoads : Boolean<br>NSAllowsArbitraryLoadsForMedia : Boolean<br>NSAllowsArbitraryLoadsInWebContent : Boolean<br>NSAllowsLocalNetworking : Boolean<br>NSExceptionDomains : Dictionary {</dt><dd>Dictionary {<br>NSIncludesSubdomains : Boolean<br>NSExceptionAllowsInsecureHTTPLoads : Boolean<br>NSExceptionMinimumTLSVersion : String<br>NSExceptionRequiresForwardSecrecy : Boolean // Default value is YES<br>NSRequiresCertificateTransparency : Boolean<br>}<br>}<br>}￼</dd></dl><hr>
<p>此次 ATS<br>的更新苹果在安全方面跨出了很大的一步，或者讲总算实施强制措施了。虽说不能达到百分之百的开发者都能够落实到这一计划当中，但起码很大一部分人都会去做这一件事情。这里唯一要吐槽的是因为此次举动只针对<br>iOS 10 用户，所以很大部分的开发者都不会原因去抛弃 iOS 10<br>以下的用户，所以才会导致此次措施只有<br>5%的完成度，相信再过一段时间会有更多的开发者会采用<br>ATS，因为安全始终是每个开发者最关心的事情也是对用户来说最重要的事情。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2017/01/08/%E5%AF%B9%E4%BA%8E%20iOS10%20%E4%B8%AD%20ATS%20%E7%9A%84%E7%90%86%E8%A7%A3%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2016/06/22/WWDC15%20%E6%80%BB%E7%BB%93%20/"
                            aria-label=": WWDC15 总结"
                        >
                            WWDC15 总结
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-06-22T11:12:19+08:00">
	
		    22 6月 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>===========</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>好吧，总算盼到了这次的WWDC，自从开始写博客后越来越喜欢关注这些比较前沿的技术动向。果然这次我热血澎湃的泡了杯咖啡穿上了大裤衩坐在电脑前等待着库克的”Good<br>Morning！”</p>
<p>这次发布会总体看下来对于我们这些开发者来说并没有什么颠覆性的改变，库克还穿着去年的那件深蓝色的T恤，Craig还是那么的幽默风趣。其实这次给我印象比较深刻的也就Multitasking和Swift2开源。</p>
<h3 id="Multitasking"><a href="#Multitasking" class="headerlink" title="Multitasking"></a>Multitasking</h3><hr>
<p>刚刚听到这个功能的时候有点没反应过来，在移动设备上做多任务处理是不是有点鸡肋。首先考虑运行的流畅性，在一个设备上同时运行两个程序我想如果使用以前的旧设备的话那肯定会非常卡。然后如果是在手机上做多任务的话，会因为屏幕太小导致操作起来十分不便，还好仅仅支持ipad。但是我觉得在我们这种ipad和手机分工明确的生活环境下，抱着ipad看电影的同时用手机回复微信已经算是多任务了，表示我等屌丝用到的机会不是很多。</p>
<p>不过既然是苹果出的新功能我相信还是有很多人会接受这种功能的，所以还是要稍微做些准备的。在iOS9中的多任务总共分三种形式，分别是Slide<br>Over(暂且称之为滑动覆盖吧，其实就是从侧边划出一个视图，可以打开支持Slide<br>Over的应用程序在这个视图中显示),Picture in picture（视频画中画），Splite<br>View(分割视图，相比Slide Over这个才算是真正的同时运行2个程序)。</p>
<p>虽说是新功能，但苹果在开发新功能的时候还是很考虑我们这些开发者的，对于Slider<br>Over和Splite View这2个功能我觉得只要会使用AutoLayout +<br>SizeClasses就行了。看似复杂的分屏功能就是要让app同时兼容ipad和iPhone尺寸。而视频画中画只要使用原本就已经存在的AVPlayerViewController<br>或者 AVPlayerLayer，其他什么都不用做，就可以完美支持了。<br>PS:据可靠消息，Media Player将不再维护，所以如果还在用Media<br>Player的同学要赶紧转移到AVKit了。</p>
<h3 id="App-Thinning"><a href="#App-Thinning" class="headerlink" title="App Thinning"></a>App Thinning</h3><hr>
<p>以前一直顾虑的问题这次苹果终于帮助我们解决了这个问题。平时在外面突发奇想去下载个app的时候看到庞大的程序和你那少的可怜的流量就只恨自己不是个土豪。</p>
<p>以前现在iOS<br>App都是同时包含了32bit和64bit两种包的，再加上iOS8更新的@3x的资源后app会变得很大。现在苹果终于发现了这个问题，在iOS9中可以自动为我们分配适合我们的slice下载了。</p>
<h3 id="Swift-2"><a href="#Swift-2" class="headerlink" title="Swift 2"></a>Swift 2</h3><hr>
<p>Swift<br>2将于年底开源，虽然不知道苹果有史以来第一次开源的决定会造成什么影响，但苹果确实有心想要把Swift拓展成一门普遍性语言，将来可能还会出现Swift后端，Swift开发的xxx工具等，未来出现Swift全栈工程师并不是不可能。</p>
<h3 id="watchOS-2"><a href="#watchOS-2" class="headerlink" title="watchOS 2"></a>watchOS 2</h3><hr>
<p>watchOS 这次跟新也并没有什么亮点，唯一值得庆幸的是Watch<br>App总算是摆脱了iPhone讲独立存在于iWatch中了。估计去年iwatch的销量并没有想象中那么好，收到的反馈意见可能很少，所以此次更新还是相对比较保守的，并没有添加一些很浮夸的功能。希望下个版本watchOS能有更惊人的表现吧。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><hr>
<p>其他的一些什么Homekit，HealthKit，CloudKit等框架也没什么亮点，稍微更新了些无关紧要的特性。虽说现在智能硬件可能会很火，但是一直到现在还是不温不火的状态所以我还是保持着期待的态度，暂时不会着手去接触。希望下次更新能有更出色的特性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>总的来说此次大会最重量级的就是Swift2的开源了，其他个人表示都不是很看好，勉强有点突破的就是Multitasking了。这段时间正好可以学一下Swift，巩固一下自己的专业技能吧。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2016/06/22/WWDC15%20%E6%80%BB%E7%BB%93%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2016/05/18/%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%83%8FClear%E7%9A%84%E6%97%B6%E9%AB%A6%E7%9A%84%E6%89%8B%E5%8A%BF%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95app%20/"
                            aria-label=": 学习如何制作一个像Clear的时髦的手势驱动的备忘录app"
                        >
                            学习如何制作一个像Clear的时髦的手势驱动的备忘录app
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-05-18T11:12:19+08:00">
	
		    18 5月 2016
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>==================================================</p>
<p>原文链接：<a href="https://www.raywenderlich.com/21842/how-to-make-a-gesture-driven-to-do-list-app-part-13" target="_blank" rel="noopener">https://www.raywenderlich.com/21842/how-to-make-a-gesture-driven-to-do-list-app-part-13</a></p>
<p>[译]如何制作一个类似Clear支持手势驱动的备忘录App (一)</p>
<p>学习如何制作一个像Clear的时髦的手势驱动的备忘录app</p>
<p>这是由教程组的成员<a href="https://www.raywenderlich.com/?page_id=9#colineberhardt" target="_blank" rel="noopener">Colin<br>Eberhardt</a>,<br><a href="http://www.shinobicontrols.com/" target="_blank" rel="noopener">ShinobiControls</a>的CTO,<br>一名会打造有趣又强大的iOS控件的开发者。看看他们的app，<a href="http://click.linksynergy.com/fs-bin/stat?id=9QfxPcziZp0&offerid=146261&type=3&subid=0&tmpid=1826&RD_PARM1=https%253A%252F%252Fitunes.apple.com%252Fus%252Fapp%252Fshinobiplay%252Fid545634307%253Fmt%253D8%2526uo%253D4%2526partnerId%253D30" target="_blank" rel="noopener">ShinobiPlay</a>。你还能在<a href="https://plus.google.com/u/0/104181672098184856535?rel=author" target="_blank">Google+</a><br>和 <a href="https://twitter.com/ColinEberhardt" target="_blank" rel="noopener">Twitter</a>上找到Colin的踪迹。</p>
<p>这三部分教程将会带你通过开发一个简单的备忘录应用，并且没有button，switch<br>和其他常见的UI控件。</p>
<p>换言之，用户将会通过一系列直觉性的手势动作来与你的app产生交互行为，包括挥动，拖动添加，捏。<br>为了避免常见的界面组件，你将会提供给用户一个更加亮眼的又不杂乱的界面。这并不是意味着一个空的手势！</p>
<p>这个教程是给中级和更高级的开发者的-你将会做一些棘手的东西像倾斜的图层，执行动画，甚至创建一个自定义个tableview。如果你是个初级开发者，你应该先去学习我们的<a href="https://www.raywenderlich.com/?page_id=2519" target="_blank" rel="noopener">其他课程</a>。</p>
<p>如果你想让你的应用在手势方面更加好用，这里就有一个适合你的教程。读一读然后亲手操练起来吧！</p>
<h3 id="拟物化和触摸界面"><a href="#拟物化和触摸界面" class="headerlink" title="拟物化和触摸界面"></a>拟物化和触摸界面</h3><hr>
<p>在写代码之前，在UI设计中手势起到的作用这一点值得我们花一点时间去讨论下。不要急，这是一个很值得注意的话题。</p>
<p>手机的多点触控界面允许了更多直接的交互-因此也产生了更多的控制方式和表现方式-远超了一个单点触碰的设备。</p>
<p>一些非常酷又具有直觉性的手势被开发了出来，比如捏/张开,轻拍，拖曳，和点击长按。但是它们很少被使用！（有一个例外是捏/张开,这是将成为处理图像的标准机制。）</p>
<p>尽管现在的触摸技术已经表现的很自然了，我们的开发者仍旧会倒退到使用那些旧的UI组件，buttons，sliders，和<br>toggle switches。为什么？</p>
<p>我们继续使用这些旧的UI组件其中一个原因是我们所知的设计理念就是拟物化。</p>
<p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2012/09/Skeuomorph-480x147.jpg" alt=""></p>
<p>为了帮助用户理解这样一个计算机界面，我们把UI设计成像物体这样来给用户一种亲切感。Apple<br>已经在他们的应用中彻底接受了拟物化设计，那些物体甚至实现了照片般的效果，例如笔记本和书架。</p>
<p>但是没关系-设计会像科技一样容易演变。图形计算机界面已经有将近40年的历史了。那我们是不是该反问下自己，”按钮真的还有必要吗?”</p>
<p>我强烈推荐去看看Josh Clarke写的<a href="http://www.lukew.com/ff/entry.asp?1566" target="_blank" rel="noopener">Buttons are a<br>Hack</a>,文中他鼓励开发者能想出更多有创造性的手势和触摸交互。下次你在你的界面中去添加一个新的控制的时候，问下你自己，”我能不能通过手势来执行相同的方法？”</p>
<p>当一个应用出现时产生了很多好用的手势，那将会十分引人注目的。一个最近的例子就是Realmac<br>software 出的Clear。可以通过检查<a href="http://www.youtube.com/watch?v=S00H-rz7fGo" target="_blank" rel="noopener">great demo on<br>YouTube</a>,甚至可以<a href="http://click.linksynergy.com/fs-bin/stat?id=9QfxPcziZp0&offerid=146261&type=3&subid=0&tmpid=1826&RD_PARM1=https%253A%252F%252Fitunes.apple.com%252Fus%252Fapp%252Fclear%252Fid493136154%253Fmt%253D8%2526uo%253D4%2526partnerId%253D30" target="_blank" rel="noopener">download<br>the<br>app</a>来确认。</p>
<p>这个教程介绍了一个和Clear非常相似的备忘录应用的开发过程。这个教程的目的是为了鼓励你去思考如何为你的应用做出更好的手势，而不是去创造一个Clear的克隆版。我鼓励你的下载购买Clear，它确实能够给你带来灵感。</p>
<p>无论如何，我想是时候从我的soapbox中撤下来然后给你们展示所有的代码！</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><hr>
<p>打开Xcode并且通过<br>File\New\Project创建一个新的iPhone应用，选择<code>iOS\Application\Single View Application</code>模板然后点击<code>Next</code>。在下一个界面中，在项目名中输入<code>ClearStyle</code>，然后按照下图填写其他类似的详情：<br><img src="https://cdn4.raywenderlich.com/wp-content/uploads/2012/09/NewProject-471x320.jpg" alt=""><br>注意你将会使用 Automatic Reference Counting<br>(ARC)，但不使用Storyboards，因为它是个单个页面的应用。同样要注意的是类的前缀是在这里设置的-不过你可以无视它，如果你设置了，那你要注意自动生成的文件名将会和本课程中的不一样。</p>
<p>备忘录从本质上来说其实就是呈现在屏幕上的一列项目。在iPhone应用程序中想呈现一个滑动的列表最标准的做法就是使用UITableView。接下来你会从已经被创建好的项目模板中添加一个到View<br>Controller。</p>
<p>点击<code>SHCViewController.xib</code>来打开界面构建器然后拖一个table<br>view到view层:<br><img src="https://cdn4.raywenderlich.com/wp-content/uploads/2012/09/AddingTableView-420x320.jpg" alt=""></p>
<p>为了访问到UITableview，你必须添加一个相关的outlet。因此，打开Assistant<br>Editor（点击Xcode<br>Toolbar右上角按钮组中间那个按钮）并且把tableview拖到<code>SHCViewController.h</code>中，就像下面显示的，命名outlet为<code>tableview</code>:<br><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2012/09/TableViewOutlet-480x304.jpg" alt=""></p>
<p>至此，你的用户界面已经完成了！</p>
<p>眼神锐利的你可能觉得疑惑为什么我是以UIViewController配合UITableView使用，而不是用UITableViewController?<br>我先不透露太多，我会在下一教程说明，你将会把UITableView替换为自定义UITableView。</p>
<p>要呈现一个备忘录列表，你必须创建一个表示为每个任务的对象。因此让我们开始做这个！</p>
<p>在项目导航中右键根项目，然后选择<code>New File…</code>，然后选择<code>iOS\Cocoa Touch\Objective-C class</code>模板然后添加一个名为<code>SHCToDoItem</code>的类.继承于<code>NSObject</code>:</p>
<p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2012/09/AddToDoItemClass-469x320.jpg" alt=""></p>
<p>打开<code>SHCToDoItem.h</code>然后添加一系列属性和接口(在@interface和@end<br>line之间)：</p>
<p>// A text description of this item.<br>@property (nonatomic, copy) NSString *text;</p>
<p>// A Boolean value that determines the completed state of this item.<br>@property (nonatomic) BOOL completed;</p>
<p>// Returns an SHCToDoItem item initialized with the given text.<br>-(id)initWithText:(NSString*)text;</p>
<p>// Returns an SHCToDoItem item initialized with the given text.<br>+(id)toDoItemWithText:(NSString*)text;</p>
<p>一个备忘录项只是纯粹的有一个文本字符串，一个Boolean用来表示该项是否已经完成。</p>
<p>如果这部分你以前是按照老的课程来做的，你可能希望合成你刚刚添加的属性。Surprise!从Xcode4.5之后你不必再这么做了，以后编译器都会自动为你合成属性。非常方便对吧？</p>
<p>接下来你必须在<code>initWithText:</code>中做些动作了，<br>初始化一个支持text的SHCToDoItem实例。为了方便起见，使对象创建起来更方便就加了这个<code>toDoItemWithText:</code>类接口。</p>
<p>在<code>SHCToDoItem.m</code>的@implementation这行后添加如下代码：</p>
<p>-(id)initWithText:(NSString*)text {<br>if (self = [super init]) {<br>self.text = text;<br>}<br>return self;<br>}</p>
<p>+(id)toDoItemWithText:(NSString *)text {<br>return [[SHCToDoItem alloc] initWithText:text];<br>}</p>
<p>现在你有了自己的备忘录项的类，接下来创建一个备忘录项的数组然后通过UITableView来显示它们是相当标准的，所以我们尽快做接下来的几步。</p>
<p>在<code>SHCViewController.m</code>顶部添加如下代码（在已存在的#import<br>这行下面，替换空的类扩折和@implemetation 这行）:</p>
<p>#import “SHCToDoItem.h”</p>
<p>@implementation SHCViewController {<br>// an array of to-do items<br>NSMutableArray* _toDoItems;<br>}</p>
<p>-(id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle<br>*)nibBundleOrNil {<br>self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];<br>if (self)<br>{<br>// create a dummy to-do list<br>_toDoItems = [[NSMutableArray alloc] init];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Feed the<br>cat”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Buy eggs”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Pack bags for<br>WWDC”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Rule the<br>web”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Buy a new<br>iPhone”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Find missing<br>socks”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Write a new<br>tutorial”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Master<br>Objective-C”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Remember your<br>wedding anniversary!”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Drink less<br>beer”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Learn to<br>draw”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Take the car to<br>the garage”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Sell things on<br>eBay”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Learn to<br>juggle”]];<br>[_toDoItems addObject:[SHCToDoItem toDoItemWithText:@”Give up”]];<br>}<br>return self;<br>}</p>
<p>到了这里当你导入了备忘录项类的头文件后，添加一个实例变量<br>_toDoItems,然后重写 <code>initWithNibName:bundle:</code><br>来构成一个由虚拟数据组成的数组。上面的代码表示了<code>toDoItemWithText</code>接口的值：已经去掉了重复的alloc/init<br>备忘录对象。</p>
<p>你必须为tableview提供一个datasource。对于一个简单的应用，使用view<br>controller来当做datasource是明智的选择，所以接着编辑<code>SHCViewController.h</code>文件采用UITableViewDataSource协议：</p>
<p>@interface SHCViewController : UIViewController</p>
<p>你必须设置view<br>controller来作为tableview的datasource。通常，你应该通过Interface<br>Builder来链接datasource tableview 的datasource 到<br>SHCViewController。但是你也能通过在<code>SHCViewController.m</code>的<code>viewDidLoad</code>中添加以下代码也能做到：</p>
<p>self.tableView.dataSource = self;<br>[self.tableView registerClass:[UITableViewCell class]<br>forCellReuseIdentifier:@”cell”];</p>
<p>以上代码也注册了UITableViewCell类这样这个类会给tableview提供cells。</p>
<p>UITableViewDataSource协议定义了2个接口并且在任何类中都必须采取这个协议。一个是（tableView:numberOfRowsInSection:）在每个分组中的行数，而另一个(tableView:cellForRowAtIndexPath:)是为一个特定行/组请求cell的实例。</p>
<p>执行那些接口十分简单-只要在<code>SHCViewController.m</code>的地步添加如下代码：</p>
<p>#pragma mark - UITableViewDataSource protocol methods<br>-(NSInteger)tableView:(UITableView *)tableView<br>numberOfRowsInSection:(NSInteger)section {<br>return _toDoItems.count;<br>}</p>
<p>-(UITableViewCell *)tableView:(UITableView *)tableView<br>cellForRowAtIndexPath:(NSIndexPath *)indexPath {<br>NSString *ident = @”cell”;<br>// re-use or create a cell<br>UITableViewCell *cell = [tableView<br>dequeueReusableCellWithIdentifier:ident forIndexPath:indexPath];<br>// find the to-do item for this index<br>int index = [indexPath row];<br>SHCToDoItem *item = _toDoItems[index];<br>// set the text<br>cell.textLabel.text = item.text;<br>return cell;<br>}</p>
<p>你只有一个单独的分组，这是tableview的默认行为，所以上面只通过<code>tableView:numberOfRowsInSection:</code>简单的返回了项目的数量。</p>
<p><code>tableView:cellForRowAtIndexPath:</code>的执行代码基本上都是模板：一个cell已经创建了，相关的备忘录项查找，cell上的文本已经设置了。</p>
<p>Note:在iOS6以前，当创建一个新的UITableViewCell,你不得不从队列中得到cell，如果你没能通过重用池得到一个cell，那你必须通过代码创建这个cell。这个在iOS6已经没有必要了，因为<code>dequeueReusableCellWithIdentifier:forIndexPath:</code>会当重用池中未能找到cell的情况下自动创建一个新的cell给你，只要你预先为这个cell注册过id。(这个你已经在<code>viewDidLoad</code>中做过了)</p>
<p>编译你的代码，你将会看到一个完美的简介备忘录，如下：</p>
<p><img src="https://cdn4.raywenderlich.com/wp-content/uploads/2012/09/ToDoListFirstCut.jpg" alt=""></p>
<h3 id="定制你的Cell"><a href="#定制你的Cell" class="headerlink" title="定制你的Cell"></a>定制你的Cell</h3><hr>
<p>在你开始添加手势之前，让我们把列表做的从视觉上更简便点。</p>
<p>UITableView<br>有一个分离的协议可以用来定制UITableViewDelegate。切换到<code>SHCViewController.h</code>然后为列表添加协议：</p>
<p>@interface SHCViewController : UIViewController<br>&lt;UITableViewDataSource, UITableViewDelegate&gt;</p>
<p>当然，tableview的委托可以通过Interface Builder 或者<br>代码来设置。现在用代码的方式来添加到<code>SHCViewController.m</code>的<code>viewDidLoad</code>中：</p>
<p>self.tableView.delegate = self;</p>
<p>self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;<br>self.tableView.backgroundColor = [UIColor blackColor];</p>
<p>这些代码移除了tableview的分割线并且设置了背景色。</p>
<p>现在你能添加下面这些代码在文件底部来增加每行的高度和设置每行的背景色：</p>
<p>-(UIColor_)colorForIndex:(NSInteger) index {<br>NSUInteger itemCount = <em>toDoItems.count - 1;<br>float val = ((float)index / (float)itemCount)</em> 0.6;<br>return [UIColor colorWithRed: 1.0 green:val blue: 0.0 alpha:1.0];<br>}</p>
<p>#pragma mark - UITableViewDataDelegate protocol methods<br>-(CGFloat)tableView:(UITableView *)tableView<br>heightForRowAtIndexPath:(NSIndexPath *)indexPath {<br>return 50.0f;<br>}</p>
<p>-(void)tableView:(UITableView *)tableView<br>willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath<br>*)indexPath {<br>cell.backgroundColor = [self colorForIndex:indexPath.row];<br>}</p>
<p>这个是从colorForIndex返回的由红变黄的渐变色，只是考虑到审美的关系。编译项目你就会看到：</p>
<p><img src="https://cdn3.raywenderlich.com/wp-content/uploads/2012/09/ToDoListColored.jpg" alt=""></p>
<p>现在我们要为每一行设置了一个特定的颜色。当用户往下滑动的时候整体的颜色也会随着改变，注意这个很难说明哪一个cell开始变化哪一个cell结束变化，尤其在接近顶部的时候，几乎每个cell都是红色背景。</p>
<p>所以接下来的步骤就是为每个cell添加一个渐变效果这样来更方便地区分cell。你能通过datasource和delegate更方便的修改cell的样式，不过还有更优雅的解决方案就是继承UITableViewCell来自定义cell。</p>
<p>在项目中添加一个<code>iOS\Cocoa Touch\Objective-C class</code>模块的新类。命名为<code>SHCTableViewCell</code>，然后让它继承<code>UITableViewCell</code>：</p>
<p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2012/09/AddCustomCell-473x320.jpg" alt=""></p>
<p>替换一下内容到<code>SHCTableViewCell.m</code>中：</p>
<p>#import &lt;QuartzCore/QuartzCore.h&gt;<br>#import “SHCTableViewCell.h”</p>
<p>@implementation SHCTableViewCell<br>{<br>CAGradientLayer* _gradientLayer;<br>}</p>
<p>-(id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString<br>*)reuseIdentifier {<br>self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];<br>if (self) {<br>// add a layer that overlays the cell adding a subtle gradient effect<br>_gradientLayer = [CAGradientLayer layer];<br>_gradientLayer.frame = self.bounds;<br>_gradientLayer.colors = @[(id)[[UIColor colorWithWhite:1.0f<br>alpha:0.2f] CGColor],<br>(id)[[UIColor colorWithWhite:1.0f alpha:0.1f] CGColor],<br>(id)[[UIColor clearColor] CGColor],<br>(id)[[UIColor colorWithWhite:0.0f alpha:0.1f] CGColor]];<br>_gradientLayer.locations = @[@0.00f, @0.01f, @0.95f, @1.00f];<br>[self.layer insertSublayer:_gradientLayer atIndex:0];<br>}<br>return self;<br>}</p>
<p>-(void) layoutSubviews {<br>[super layoutSubviews];<br>// ensure the gradient layers occupies the full bounds<br>_gradientLayer.frame = self.bounds;<br>}</p>
<p>@end</p>
<p>这里你添加了一个CAGradientLayer<br>实例变量并且在初始化接口中创建了一个四层色阶。注意到的是色阶中的白色值在最顶端，黑色的在最底部。这会覆盖在已存在的颜色顶部，会产生高亮部分在顶部而暗部分在底部的效果，这样就能创建出一个从上到下都很流畅的模拟发光效果。</p>
<p>Note:仍旧要尝试如何做出合适的覆盖效果和其他的模拟发光效果？看看Vicki写的<a href="http://www.vickiwenderlich.com/2011/09/three-dimensional-characters-objects-light-sources/" target="_blank" rel="noopener">this<br>lighting<br>tutorial</a>。</p>
<p>试着编译代码，你会发现会报一堆链接上的错。这是因为上面的代码使用了QuartzCore框架。</p>
<p>为了让编译器满意，点击项目的根目录切换到project<br>settings，然后展开<code>Build Phases</code>标签的<code>Link Binary With Libraries</code>分组，然后点击(+)按钮把框架添加到你的项目中。你会发现QuartzCore在列表中。</p>
<p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2012/09/AddFramework-480x250.jpg" alt=""></p>
<p>到此框架添加完成，但是你现在还是不能使用你的自定义UITableViewCell！你必须使用自定义cell。</p>
<p>切换到<code>SHCViewController.m</code> 然后在顶部导入以下代码：</p>
<p>#import “SHCTableViewCell.h”</p>
<p>然后在<code>viewDidLoad</code>中替换下面这行代码：</p>
<p>[self.tableView registerClass:[UITableViewCell class]<br>forCellReuseIdentifier:@”cell”];</p>
<p>到 ：</p>
<p>[self.tableView registerClass:[SHCTableViewCell class]<br>forCellReuseIdentifier:@”cell”];</p>
<p>最后，在<code>tableView:cellForRowAtIndexPath:</code>类中把cell的类替换成SHCTableCelClass,像如下代码：</p>
<pre><code>SHCTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ident forIndexPath:indexPath];</code></pre><p>cell.textLabel.backgroundColor = [UIColor clearColor];</p>
<p>这样就可以了！因为你在<code>viewDidLoad</code>中被注册用来创建新的tableview cell<br>在执行<code>tableView:cellForRowAtIndexPath:</code>时需要这个table<br>cell，你的新类将会被自动调用</p>
<p>编译你的项目，然后你的备忘录项会有一个比较明显的坡度，这样能使每行之间更容易区分：</p>
<p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2012/09/ToDoListGradient.jpg" alt=""></p>
<h3 id="滑动删除"><a href="#滑动删除" class="headerlink" title="滑动删除"></a>滑动删除</h3><hr>
<p>现在你的列表已经呈现出来了，是时候添加你的第一个收拾啦。真是令人兴奋啊！</p>
<p>就用户的交互而言多点触碰设备提供了app开发者更加复杂和详尽的信息。当每个手指位于屏幕上是，它会把跟踪到的点位通过一系列的touch事件反馈到你的应用。设计这些低等级的touch事件到高等级的手势，比如拖动或者捏，都是很有挑战性的。</p>
<p>对大部分需要精确定位的设备来说一根手指是不够的!而且手势必然会有内置的偏差。举个例子，手指准备拖动的前不得不移动一段距离。</p>
<p>幸运的是，iOS的框架已经提供了完完整整的一套手势。那些方便又轻便的类管理着低等级的touch事件，节省你从复杂的事件中标记手势类型所花的时间并且允许你把注意力放在更高级的任务上来响应每个手势。</p>
<p>这篇课程会跳过这些细节，如果你想学习更多相关知识的话可以去看下我们的<a href="https://www.raywenderlich.com/?p=6567" target="_blank" rel="noopener">UIGestureRecognizer<br>tutorial</a>。</p>
<p>在你的自定义table view<br>cell中<code>SHCTableViewCell.m</code>的init中方法添加一个滑动手势，如下面代码:</p>
<p>UIGestureRecognizer* recognizer = [[UIPanGestureRecognizer alloc]<br>initWithTarget:self action:@selector(handlePan:)];<br>recognizer.delegate = self;<br>[self addGestureRecognizer:recognizer];</p>
<p>这样任何滑动手势都会被发送到<code>handlePan:</code>事件中，但是在添加该接口之前，你需要几个实例变量。如下面已存在的实例变量_gradientLayer:</p>
<p>CGPoint _originalCenter;<br>BOOL _deleteOnDragRelease;</p>
<p>然后添加如下代码:</p>
<p>#pragma mark - horizontal pan gesture methods<br>-(BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer<br>*)gestureRecognizer {<br>CGPoint translation = [gestureRecognizer translationInView:[self<br>superview]];<br>// Check for horizontal gesture<br>if (fabsf(translation.x) &gt; fabsf(translation.y)) {<br>return YES;<br>}<br>return NO;<br>}</p>
<p>-(void)handlePan:(UIPanGestureRecognizer *)recognizer {<br>// 1<br>if (recognizer.state == UIGestureRecognizerStateBegan) {<br>// if the gesture has just started, record the current centre location<br>_originalCenter = self.center;<br>}</p>
<pre><code>// 2
if (recognizer.state == UIGestureRecognizerStateChanged) {
    // translate the center
    CGPoint translation = [recognizer translationInView:self];
    self.center = CGPointMake(_originalCenter.x + translation.x, _originalCenter.y);
    // determine whether the item has been dragged far enough to initiate a delete / complete
    _deleteOnDragRelease = self.frame.origin.x &lt; -self.frame.size.width / 2;

}

// 3
if (recognizer.state == UIGestureRecognizerStateEnded) {
    // the frame this cell would have had before being dragged
    CGRect originalFrame = CGRectMake(0, self.frame.origin.y,
                                      self.bounds.size.width, self.bounds.size.height);
    if (!_deleteOnDragRelease) {
        // if the item is not being deleted, snap back to the original location
        [UIView animateWithDuration:0.2
                         animations:^{
                             self.frame = originalFrame;
                         }
         ];
    }
}</code></pre><p>}</p>
<p>这些代码中做了不少的事情。我们先执行<code>handlePan</code>:,一步一步来。</p>
<ol>
<li>手势处理，比如这个接口，它通过手势的生命周期调在各种各样的点上调用：手势的开始，变化（前提是手势在执行中），然后是结束。当滑动手势第一次执行的时候，cell的中心点会被记录到_originalCenter。</li>
<li>当滑动过程中（当用户移动他们的手指时），这个接口确定了cell和通过手势而产生的新的点之间的偏差，然后就相应地偏移了center属性。如果偏移量超过cell宽度的一般，接下来你要考虑删除操作了。用_deleteOnDragRelease实例变量来作为标签来标记当前的行为是删除动作。</li>
<li>当然，当手势结束时，你通过检查这个标签来确定当前的动作是不是删除动作（用户可能拖到一半的时候又拖回去了，其实这根本没执行删除操作）。</li>
</ol>
<p>接下来是<code>gestureRecognizerShouldBegin</code>-<br>它做了什么?你可能注意到了当<code>handlePan:</code>作为手势的动作时，上面的代码也说明了cell<br>这个类被用来作为滑动手势的委托。</p>
<p>这个借口将允许你在它开始之前取消手势。在这个例子中，你要确定滑动的方向是横向还是竖向。如果是竖向就取消，因为你不必要处理任何竖向滑动。</p>
<p>这是非常重要的一步！你的cells是存在于一个竖向滑动的view中。所以如果取消竖向的滑动那scrollview<br>就会失效，这样任务列表将不能滑动。</p>
<p>编译项目，你将会发现你可以向左或者向右滑动item。当你释放的时候，该项就会返回到中心，除非你往左拖动它超过半个屏幕的时候，这就表示该项将要被删除:</p>
<p><img src="https://cdn4.raywenderlich.com/wp-content/uploads/2012/09/DeleteItem.jpg" alt=""></p>
<p>当然，你也会注意到项目并没有被删除。那么你该如何从你的列表中删除一个项目？</p>
<p>任务清单的项目是被存储在你的view<br>controller中的NSMutableArray中。所以你应该找到一些方法来标记这个view<br>controller这样当一个项目被删除的时候可以从数组中删除该项。</p>
<p>UI<br>controls是通过协议来标记状态变化和用户交互。你也同样可以在这里采用它。</p>
<p>在项目中通过<code>iOS\Cocoa Touch\Objective-C protocol</code>模板添加一个新的协议。命名为<code>SHCTableViewCellDelegate</code>。</p>
<p>现在打开<code>SHCTableViewCellDelegate.h</code> 然后替换内容为：</p>
<p>#import “SHCToDoItem.h”</p>
<p>// A protocol that the SHCTableViewCell uses to inform of state change<br>@protocol SHCTableViewCellDelegate</p>
<p>// indicates that the given item has been deleted<br>-(void) toDoItemDeleted:(SHCToDoItem*)todoItem;</p>
<p>@end</p>
<p>上面的代码添加了一个简单的接口用来说明一个项目已经被删除了。</p>
<p>自定义cell类必须声明这个委托，并且它需要知道它呈现了哪个项目。在<code>SHCTableViewCell.h</code>中替换这些内容来添加这些信息：</p>
<p>#import “SHCToDoItem.h”<br>#import “SHCTableViewCellDelegate.h”</p>
<p>// A custom table cell that renders SHCToDoItem items.<br>@interface SHCTableViewCell : UITableViewCell</p>
<p>// The item that this cell renders.<br>@property (nonatomic) SHCToDoItem *todoItem;</p>
<p>// The object that acts as delegate for this cell.<br>@property (nonatomic, assign) id delegate;</p>
<p>@end</p>
<p>为了能够使用这个委托，在<code>SHCTableViewCell.h</code>中<code>handlePan:</code>中需要添加如下代码来更新逻辑：</p>
<p>if (_deleteOnDragRelease) {<br>// notify the delegate that this item should be deleted<br>[self.delegate toDoItemDeleted:self.todoItem];<br>}</p>
<p>上面的代码是指当用户拖动这个项目足够距离的时候就会调用委托接口。</p>
<p>接下来该利用上面的代码来做些修改。切换到<code>SHCViewController.h</code><br>并且声明这个类让它支持新的协议（也就是添加有必要的#import）:</p>
<p>#import “SHCTableViewCellDelegate.h”</p>
<p>@interface SHCViewController : UIViewController<br>&lt;UITableViewDataSource, UITableViewDelegate, SHCTableViewCellDelegate&gt;</p>
<p>然后，打开<code>SHCViewController.m</code>然后在<code>tableView:cellForRowAtIndex:</code>中添加如下代码:</p>
<p>cell.delegate = self;<br>cell.todoItem = item;</p>
<p>最后，在新增的委托接口中添加删除项目：</p>
<p>-(void)toDoItemDeleted:(id)todoItem {<br>// use the UITableView to animate the removal of this row<br>NSUInteger index = [_toDoItems indexOfObject:todoItem];<br>[self.tableView beginUpdates];<br>[_toDoItems removeObject:todoItem];<br>[self.tableView deleteRowsAtIndexPaths:@[[NSIndexPath<br>indexPathForRow:index inSection:0]]<br>withRowAnimation:UITableViewRowAnimationFade];<br>[self.tableView endUpdates];<br>}</p>
<p>上面的代码移除了任务清单的项目，然后使用了UITableView的动画去删除，用的是默认动画之一。</p>
<p>##滑动完成</p>
<p>你的任务清单应用允许用户删除项目，但是如何把它们标记成完成呢？为了这个，你将要使用到右滑的手势。</p>
<p>当一个项目标记成完成的时候，它会变成绿色的背景并且在文本上有一条删除线。不幸的是，iOS不支持删除线，所以你不得不自己做出来！</p>
<p>我通过在<a href="http://stackoverflow.com/" target="_blank" rel="noopener">StackOverfolw</a>找到了一些关于UILabel的删除线效果的方法，但是都是通过使用drawRect和Quartz<br>2D来实现的。我更倾向于layers这类方式，因为这些代码更易读，而且<br>layers更容易通过它们的隐藏属性来打开或者关闭删除线。</p>
<blockquote>
<p>注意:此外，你也可以通过iOS6更新的<br>NSAttributedString的功能来实现。若想知道更多，可以查看iOS6教程的第15章，”What’s<br>New with Attributed Strings.”</p>
</blockquote>
<p>那么，在<code>iOS\Cocoa Touch\Objective-C class</code>模板中创建一个新文件.一个继承于UILabel的名为<code>SHCStrikethroushLabel</code>。</p>
<p>// A UILabel subclass that can optionally have a strikethrough.<br>@interface SHCStrikethroughLabel : UILabel</p>
<p>// A Boolean value that determines whether the label should have a<br>strikethrough.<br>@property (nonatomic) bool strikethrough;</p>
<p>@end</p>
<p>切换到<code>SHCStrikethroushLabel.m</code>中替换如下内容到类中：</p>
<p>#import &lt;QuartzCore/QuartzCore.h&gt;<br>#import “SHCStrikethroughLabel.h”</p>
<p>@implementation SHCStrikethroughLabel {<br>bool _strikethrough;<br>CALayer* _strikethroughLayer;<br>}</p>
<p>const float STRIKEOUT_THICKNESS = 2.0f;</p>
<p>-(id)initWithFrame:(CGRect)frame {<br>self = [super initWithFrame:frame];<br>if (self) {<br>_strikethroughLayer = [CALayer layer];<br>_strikethroughLayer.backgroundColor = [[UIColor whiteColor]<br>CGColor];<br>_strikethroughLayer.hidden = YES;<br>[self.layer addSublayer:_strikethroughLayer];<br>}<br>return self;<br>}</p>
<p>-(void)layoutSubviews {<br>[super layoutSubviews];<br>[self resizeStrikeThrough];<br>}</p>
<p>-(void)setText:(NSString *)text {<br>[super setText:text];<br>[self resizeStrikeThrough];<br>}</p>
<p>// resizes the strikethrough layer to match the current label text<br>-(void)resizeStrikeThrough {<br>CGSize textSize = [self.text sizeWithFont:self.font];<br>_strikethroughLayer.frame = CGRectMake(0, self.bounds.size.height/2,<br>textSize.width, STRIKEOUT_THICKNESS);<br>}</p>
<p>#pragma mark - property setter<br>-(void)setStrikethrough:(bool)strikethrough {<br>_strikethrough = strikethrough;<br>_strikethroughLayer.hidden = !strikethrough;<br>}</p>
<p>@end</p>
<p>删除线是基本上就是一个放在文本上的图层。因为删除线的属性已经设置了，删除线图层的显示和隐藏就变得很有必要。</p>
<p>好了，现在你有了自己的删除线标签，接下来需要添加到自己的自定义cell中。打开<code>SHCTableViewCell.m</code>然后把你的新类导进去:</p>
<p>#import “SHCStrikethroughLabel.h”</p>
<p>然后在实例变量_deleteOnDragRelease下面添加如下一系列的实例变量:</p>
<p>SHCStrikethroughLabel *_label;<br>CALayer *_itemCompleteLayer;</p>
<p>接下来在<code>initWithStyle:reuseIdentifier:</code> 的顶部添加如下代码:</p>
<p>// create a label that renders the to-do item text<br>_label = [[SHCStrikethroughLabel alloc] initWithFrame:CGRectNull];<br>_label.textColor = [UIColor whiteColor];<br>_label.font = [UIFont boldSystemFontOfSize:16];<br>_label.backgroundColor = [UIColor clearColor];<br>[self addSubview:_label];<br>// remove the default blue highlight for selected cells<br>self.selectionStyle = UITableViewCellSelectionStyleNone;</p>
<p>仍旧是在<code>initWithStyle:reuseIdentifier:</code>,在添加手势前添加如下代码:</p>
<p>// add a layer that renders a green background when an item is complete<br>_itemCompleteLayer = [CALayer layer];<br>_itemCompleteLayer.backgroundColor = [[[UIColor alloc]<br>initWithRed:0.0 green:0.6 blue:0.0 alpha:1.0] CGColor];<br>_itemCompleteLayer.hidden = YES;<br>[self.layer insertSublayer:_itemCompleteLayer atIndex:0];</p>
<p>上面添加到你的自定义cell的代码中既有删除线标签也有一个军绿色图层，它们将会在项目完成的时候显示出来。</p>
<p>现在在<code>layoutSubviews</code>中替换一下代码:</p>
<p>const float LABEL_LEFT_MARGIN = 15.0f;</p>
<p>-(void)layoutSubviews {<br>[super layoutSubviews];<br>// ensure the gradient layers occupies the full bounds<br>_gradientLayer.frame = self.bounds;<br>_itemCompleteLayer.frame = self.bounds;<br>_label.frame = CGRectMake(LABEL_LEFT_MARGIN, 0,<br>self.bounds.size.width - LABEL_LEFT_MARGIN,self.bounds.size.height);<br>}</p>
<p>然后按照一下代码为<code>todoItem</code>属性setter:</p>
<p>-(void)setTodoItem:(SHCToDoItem *)todoItem {<br>_todoItem = todoItem;<br>// we must update all the visual state associated with the model item<br>_label.text = todoItem.text;<br>_label.strikethrough = todoItem.completed;<br>_itemCompleteLayer.hidden = !todoItem.completed;<br>}</p>
<p>现在你通过setter设置了标签的文本，打开<code>SHCViewController.m</code>注释的那行就是用来设置label的：</p>
<p>//cell.textLabel.text = item.text;</p>
<p>最后你要做的事就是发现当cell往右拖动超过一半的时候，任务清单项被设置为完成。这里有一个非常相似的处理方式，想要用自己的方式尝试下吗？你想吗?好，我会等你尝试一下，走你！</p>
<p>。。。</p>
<p>。。。</p>
<p>。。。</p>
<p><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2010/09/Tsan_angry.jpg" alt=""></p>
<p>你是不是还在试？继续，我在这里等着! :]<br>…</p>
<p>…</p>
<p>…</p>
<p>修复好了吗？如果没有，让我们来检查一下。<br>你开始添加一个新的实例变量到<code>SHCTableViewcell.m</code>中，它会作为一个标记项目是否完成的标签：</p>
<p>BOOL _markCompleteOnDragRelease;</p>
<p>接下来，在<code>handlePan:</code>函数中的<code>UIGestureRecognizerStateChanged</code>这块，你设置的标签依赖于cell向右滑动多少距离，如下（当_deleteOnDragRelease被设置的时候你可以添加如下代码）：</p>
<p>_markCompleteOnDragRelease = self.frame.origin.x &gt;<br>self.frame.size.width / 2;</p>
<p>最后，仍旧在<code>handlePan:</code>不过是在<code>UIGestureRecognizerStateEnded</code>块中，如果完成的标签被设置了你标记cell为完成：</p>
<p>if (_markCompleteOnDragRelease) {<br>// mark the item as complete and update the UI state<br>self.todoItem.completed = YES;<br>_itemCompleteLayer.hidden = NO;<br>_label.strikethrough = YES;<br>}</p>
<p>如你所注意到的，这些代码把项目标记为完成，显示了完成的图层并且在label上产生了删除线效果。</p>
<p>完成！现在你能过通过滑动项目来完成或者删除。最新添加的绿色图层位于你的删除线后面，所以完成的行仍旧会有阴影效果。</p>
<p>现在编译项目，然后你就能看到如下效果：</p>
<p><img src="https://cdn4.raywenderlich.com/wp-content/uploads/2012/09/ToDoListMarkComplete.jpg" alt=""></p>
<p>现在它看起来棒多了！</p>
<p>##</p>
<p>任务清单现在已经有了一个新颖的，简洁的交互方式…当你知道这是怎么回事的话。有一个关于手势的小问题那就是它们和传统的拟物化相比没有直接显示给用户。</p>
<p>有一样东西你是可以做到的那就是通过用户对基于界面的手势的理解，除了妥协于简单朴素的界面之外。为了一个更棒的手势效果，我推荐阅读这篇我朋友Graham<br>Odds写的<a href="http://www.scottlogic.co.uk/blog/graham/2010/05/contextual-cues-in-ui-design/" target="_blank" rel="noopener">博客</a>，这里有很多这种例子。</p>
<p>这种手势交互通常通过这些功能和行为来给用户的所作所为得到响应。举个例子，鼠标指针从桌面浏览器被用户移到在一个超链接上的时候。</p>
<p>同样的方法会被用到基于界面的手势上。当一个用户开始与界面产生交互的时候，你可以提供很微妙的可见的线索来促进进一步的交互来表示这个功能，这样的话这个手势就会被触发。</p>
<p>对于你的任务清单，可以用一个简单的标记来表示当用户往左或者往右拖动一个项目的时候是删除还是完成。所以记下来就要添加它们！</p>
<p>添加一系列<strong>UILabel</strong>的实例变量到<code>SHCTableViewCell.m</code>中，</p>
<p>如下:</p>
<p>UILabel *_tickLabel;<br>UILabel *_crossLabel;</p>
<p>接下来，在<code>initWithStyle:reuseIdentifier：</code>上面上面定义一些常量：</p>
<p>const float UI_CUES_MARGIN = 10.0f;<br>const float UI_CUES_WIDTH = 50.0f;</p>
<p>现在在<code>initWithStyle:reuseIdentifier：</code>中的<code>if(self)</code>的结构里添加如下代码:</p>
<p>// add a tick and cross<br>_tickLabel = [self createCueLabel];<br>_tickLabel.text = @”\u2713”;<br>_tickLabel.textAlignment = NSTextAlignmentRight;<br>[self addSubview:_tickLabel];<br>_crossLabel = [self createCueLabel];<br>_crossLabel.text = @”\u2717”;<br>_crossLabel.textAlignment = NSTextAlignmentLeft;<br>[self addSubview:_crossLabel];</p>
<p>然后添加下面这个创建label的接口:</p>
<p>// utility method for creating the contextual cues<br>-(UILabel<em>) createCueLabel {<br>UILabel</em> label = [[UILabel alloc] initWithFrame:CGRectNull];<br>label.textColor = [UIColor whiteColor];<br>label.font = [UIFont boldSystemFontOfSize:32.0];<br>label.backgroundColor = [UIColor clearColor];<br>return label;<br>}</p>
<p>对于标记和叉的图标来说与其用图片素材，还不如使用Unicode编码就像上面的代码一样来得好。你可能找到了一些比较漂亮的素材，但是这些编码能够很快执行出这样的效果，所以无需添加图片素材。</p>
<blockquote>
<p>注意：为什么我知道这些代表着对号和叉号的unicode值？可以通过<a href="http://en.wikibooks.org/wiki/Unicode/List_of_useful_symbols" target="_blank" rel="noopener">list of<br>useful Unicode<br>symbols</a>很方便的找到!</p>
</blockquote>
<p>现在在<code>layoutSubviews</code>函数末尾添加如下代码来重定位这些标签:</p>
<pre><code>_tickLabel.frame = CGRectMake(-UI_CUES_WIDTH - UI_CUES_MARGIN, 0,</code></pre><p>UI_CUES_WIDTH, self.bounds.size.height);<br>_crossLabel.frame = CGRectMake(self.bounds.size.width +<br>UI_CUES_MARGIN, 0,<br>UI_CUES_WIDTH, self.bounds.size.height);</p>
<p>上面的代码让标签位于屏幕外，勾号再左边叉号再右边。</p>
<p>最后，在<code>handlePan:</code>中添加代码，在block中处于<code>UIGestureRecognizerStateChanged</code>状态哪里添加如下代码，用来在用户拖动cell的时候调整label的透明度:</p>
<p>// fade the contextual cues<br>float cueAlpha = fabsf(self.frame.origin.x) / (self.frame.size.width /<br>2);<br>_tickLabel.alpha = cueAlpha;<br>_crossLabel.alpha = cueAlpha;</p>
<p>// indicate when the item have been pulled far enough to invoke the<br>given action<br>_tickLabel.textColor = _markCompleteOnDragRelease ?<br>[UIColor greenColor] : [UIColor whiteColor];<br>_crossLabel.textColor = _deleteOnDragRelease ?<br>[UIColor redColor] : [UIColor whiteColor];</p>
<p>这个勾和叉号通过改变颜色更加明显的体现了用户拖动的项目是否足够远-接下来编译项目你就会注意到这个现象了：</p>
<p>完成这个最后的功能之后，你已经完成了整套系列的三分之一！</p>
<h3 id="接下来该做什么"><a href="#接下来该做什么" class="headerlink" title="接下来该做什么?"></a>接下来该做什么?</h3><hr>
<p>这里有一些<a href="http://www.raywenderlich.com/downloads/ClearStyle1Final.zip" target="_blank" rel="noopener">示例</a>，里面包含了这个部分的所有源代码。</p>
<p>下一步做什么呢？好遥远，现在这个app只是能够允许用户标记项目完成或者删除项目。这里显然需要更多的手势或者特性来是的应用更丰富。</p>
<p>不过，我不是很想用很常见的UITableView提供的删除动画。我肯定这里应该需要用一个更加炫的方法。</p>
<p>不幸的是，使用继承UITableView多多少少限制了一些功能，这也是为什么接下来的一部分将会替换这部分你写的自定义功能。不过它一直都是一个很大的话题，你会等到第二部分才能找出所有有关它的一切。</p>
<p>其实，为什么不自己思考更多有趣的东西和手势来想替换现有的控件。当然，如果你使用手势，不要忘记怎么去提醒用户来发现它们和使用它们的可能性。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2016/05/18/%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%83%8FClear%E7%9A%84%E6%97%B6%E9%AB%A6%E7%9A%84%E6%89%8B%E5%8A%BF%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95app%20/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Kommentieren und teilen
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/page/2/"
                aria-label="ÄLTERE BEITRÄGE"
            >
              <span>ÄLTERE BEITRÄGE</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">Seite 1 von 3</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 loannes. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">loannes</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
